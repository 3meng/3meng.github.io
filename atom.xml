<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[一千二百年的清风明月]]></title>
  <subtitle><![CDATA[历劫由来谁一笑，仙踪尽飞羽衣飘。]]></subtitle>
  <link href="/atom.xml" rel="self"/>
  <link href="http://3meng.github.io/"/>
  <updated>2016-02-10T13:01:47.000Z</updated>
  <id>http://3meng.github.io/</id>
  
  <author>
    <name><![CDATA[一粒尘埃]]></name>
    <email><![CDATA[hp839259646@hotmail.com]]></email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title><![CDATA[最大子数组查找算法]]></title>
    <link href="http://3meng.github.io/2016/02/08/Algorithm-of-Finding-Maximum-SubArray/"/>
    <id>http://3meng.github.io/2016/02/08/Algorithm-of-Finding-Maximum-SubArray/</id>
    <published>2016-02-08T06:10:07.000Z</published>
    <updated>2016-02-10T13:01:47.000Z</updated>
    <content type="html"><![CDATA[<p>最近开始看<strong>《算法导论（第三版）》</strong>这本书，在第4章讲解<em>分治策略</em>的时候，举了一个例子：<strong>最大子数组</strong>问题（<code>4.1节</code>），简单来说，就是在一个给定的数组中，找出一个非空<strong>连续</strong>子数组，使这个数组中元素的<strong>总和最大</strong>，我们称这样的子数组为<strong>最大子数组</strong>。</p>
<p>在书中讲解分析了两种解决方法，一种就是最容易想到的暴力求解方法，另一种自然就是主题相关的分治法；然后在结束的时候，提到了可以实现一种更快速的线性时间的算法，这里将给出我的思路（原书这里描述有误，不知道是作者/译者笔误还是印刷错误）。</p>
<a id="more"></a>
<p>下面先给出书中提到的两种方案，然后附上最后的线性时间的解决方法。</p>
<blockquote>
<p>对于讨论的子数组问题，只有当被查找的数组中存在负数的时候才有意义，因为对于一个全部为正数的数组，最大子数组自然是其本身。</p>
</blockquote>
<p><strong>2016年2月10日更新：加入另一种线性时间的代码（来源于网络，地址见下文）和分析。</strong></p>
<h2 id="u66B4_u529B_u6C42_u89E3_u65B9_u6CD5"><a href="#u66B4_u529B_u6C42_u89E3_u65B9_u6CD5" class="headerlink" title="暴力求解方法"></a>暴力求解方法</h2><p>暴力求解，自然就是<strong>枚举</strong>所有的子数组，计算每个子数组的和，然后查找出和最大的那个子数组。对于一段长度为n的数组，我们需要检查<code>n + (n-1) + ... + 1 = n(n+1)/2</code>个子数组，时间复杂度可以表示为<code>O(n^2)</code>，另一方面，虽然计算一个子数组之和所需的时间是线性的，但是当计算所有子数组之和时，我们可以通过缓存之前计算出的子数组和来计算当前子数组的和，使得每个子数组和的计算时间为<code>O(1)</code>，因此暴力求解方法所花费的时间为<code>O(n^2)</code>。</p>
<blockquote>
<p>暴力求解算法很简单，就不附加相关代码了。</p>
</blockquote>
<h2 id="u5206_u6CBB_u7B56_u7565_u6C42_u89E3_u65B9_u6CD5"><a href="#u5206_u6CBB_u7B56_u7565_u6C42_u89E3_u65B9_u6CD5" class="headerlink" title="分治策略求解方法"></a>分治策略求解方法</h2><p>假定我们需要寻找子数组<code>A[low..high]</code>的最大子数组。</p>
<blockquote>
<p>下面的描述中，也将采用这种描述数组的方式，方括号中使用一对由<code>..</code>分开的整数（变量），分别指示数组下标的下限和上限（包含上下限）。</p>
</blockquote>
<p>使用<strong>分治策略</strong>意味着需要将子数组划分为两个规模尽量相等的子数组，将子数组<code>A[low..high]</code>的中央位置下标记为<code>mid</code>，然后考虑求解两个子数组<code>A[low..mid]</code>和<code>A[mid+1..high]</code>，那么<code>A[low..high]</code>的任何连续子数组<code>A[i..j]</code>所处的位置必然是以下三种情况之一：</p>
<ul>
<li>完全位于子数组<code>A[low..mid]</code>中，因此 <em>low &lt;= i &lt;= j &lt;= high</em>。</li>
<li>完全位于子数组<code>A[mid+1..high]</code>中，因此 <em>mid &lt; i &lt;= j &lt;= high</em>。</li>
<li>跨越了中点，因此 <em>low &lt;= i &lt;= mid &lt; j &lt;= high</em>。</li>
</ul>
<p>因此，<code>A[low..high]</code>的一个最大子数组所处位置必然是这三种情况之一。实际上，<code>A[low..high]</code>的一个最大子数组必然是完全位于<code>A[low..mid]</code>中、完全位于<code>A[mid+1..high]</code>中或者跨越中点的<strong>所有</strong>子数组中和的最大者。我们可以递归的求解<code>A[low..mid]</code>和<code>A[mid+1..high]</code>的最大子数组，因为这两个子问题仍是最大子数组问题，只是规模更小。因此剩下的问题就是寻找跨越中点的最大子数组，然后在三种情况中选择最大者。</p>
<blockquote>
<p>寻找跨越中点的最大子数组，并不是原问题的规模更小的实例，因为它加入了限制：求和的子数组必须跨越中点，因为任何跨越中点的子数组都是由两个子数组<code>A[i..mid]</code>和<code>A[mid+1..j</code>组成，其中 <em>low &lt;= i &lt;= mid</em> 且 <em>mid &lt; j &lt;= high</em>。因此我们只需要找出形如<code>A[i..mid]</code>和<code>A[mid+1..j]</code>的最大子数组，然后将其合并即可。</p>
</blockquote>
<h3 id="FIND_MAX_CROSSING_SUBARRAY"><a href="#FIND_MAX_CROSSING_SUBARRAY" class="headerlink" title="FIND_MAX_CROSSING_SUBARRAY"></a>FIND_MAX_CROSSING_SUBARRAY</h3><p>使用过程<code>FIND_MAX_CROSSING_SUBARRAY</code>描述这个方法，这个过程接收数组<em>A</em>和下标<em>low</em>、<em>mid</em>、<em>high</em>为输入，返回一个具有三个元素的元组，这三个元素分别表示最大子数组的上下边界以及值得和。</p>
<p>下面给出伪代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">FIND_MAX_CROSSING_SUBARRAY(A, low, mid, high)</span><br><span class="line">left_sum = -<span class="number">1</span></span><br><span class="line">sum = <span class="number">0</span></span><br><span class="line">max_left = mid</span><br><span class="line"><span class="keyword">for</span> (i = mid; i &gt;= low; --i)</span><br><span class="line">    sum += A[i]</span><br><span class="line">    <span class="keyword">if</span> (sum &gt; left_sum)</span><br><span class="line">        left_sum = sum</span><br><span class="line">        max_left = i</span><br><span class="line">        </span><br><span class="line">right_sum = -<span class="number">1</span></span><br><span class="line">sum = <span class="number">0</span></span><br><span class="line">max_right = mid + <span class="number">1</span></span><br><span class="line"><span class="keyword">for</span> (j = mid + <span class="number">1</span>; j &lt;= high; ++j)</span><br><span class="line">    sum += A[j]</span><br><span class="line">    <span class="keyword">if</span> (sum &gt; right_sum)</span><br><span class="line">        right_sum = sum</span><br><span class="line">        max_right = j</span><br><span class="line">        </span><br><span class="line"><span class="keyword">return</span> (max_left, max_right, left_sum + right_sum)</span><br></pre></td></tr></table></figure>
<p>两个循环分别向左向右搜索使<code>left_sum</code>和<code>right_sum</code>取值最大的下标，然后返回结果：子数组<code>A[max_left..max_right]</code>和相应的和<code>left_sum + right_sum</code>。可以很容易看出上面两个循环迭代一共执行了<code>(mid - lwo + 1) + (high - mid) = high - low + 1 = n</code>次，因此这个计算过程的时间复杂度可以记为<code>O(n)</code>。</p>
<h3 id="FIND_MAXIMUM_SUBARRAY"><a href="#FIND_MAXIMUM_SUBARRAY" class="headerlink" title="FIND_MAXIMUM_SUBARRAY"></a>FIND_MAXIMUM_SUBARRAY</h3><p>有了这个<code>FIND_MAX_CORSSING_SUBARRAY</code>在手，就可以设计求解最大子数组的分治算法的伪代码了：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">FIND_MAXIMUM_SUBARRAY(A, low, high)</span><br><span class="line"><span class="keyword">if</span> (high == low)</span><br><span class="line">    <span class="keyword">return</span> (low, high, A[low])  // 递归底层，开始回归</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    mid = (low + high) / <span class="number">2</span>  // C语言整数计算方式，结果向下取整</span><br><span class="line">    (left_low, left_high, left_sum) = FIND_MAXIMUM_SUBARRAY(A, low, mid)</span><br><span class="line">    (right_low, right_high, right_sum) = FIND_MAXIMUM_SUBARRAY(A, mid+<span class="number">1</span>, high)</span><br><span class="line">    (cross_low, cross_high, cross_sum) = FIND_MAX_CROSSING_SUBARRAY(A, low, mid, high)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (left_sum &gt;= right_sum &amp;&amp; left_sum &gt;= cross_sum)</span><br><span class="line">        <span class="keyword">return</span> (left_low, left_high, left_sum)</span><br><span class="line">    <span class="keyword">if</span> (right_sum &gt;= left_sum &amp;&amp; right_sum &gt;= cross_sum)</span><br><span class="line">        <span class="keyword">return</span> (right_low, right_high, right_sum)</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> (cross_low, cross_high, cross_sum)</span><br></pre></td></tr></table></figure>
<p>初始调用<code>FIND_MAXIMUM_SUBARRAY(A, 0, A.length-1)</code>。</p>
<p>时间复杂度不再细述，由递归深度<code>lg(n)</code>可以得出过程<code>FIND_MAXIMUM_SUBARRAY</code>的时间复杂度为<code>O(n*lg(n))</code>。</p>
<h2 id="u4E00_u4E2A_u7EBF_u6027_u65F6_u95F4_u7684_u7B97_u6CD5"><a href="#u4E00_u4E2A_u7EBF_u6027_u65F6_u95F4_u7684_u7B97_u6CD5" class="headerlink" title="一个线性时间的算法"></a>一个线性时间的算法</h2><p>在书中分治算法分析结束的时候，提到了对于这个求解最大子数组的问题，存在一个线性时间的算法，并在附加的练习题目中给出了提示：</p>
<blockquote>
<p>使用如下思想为最大子数组问题设计一个非递归的、线性时间的算法。从数组的左边界开始，由左至右处理，记录到目前为止已经处理过的最大子数组。若已知<code>A[0..j]</code>的最大子数组，那么基于如下性质将解扩展为<code>A[0..j+1]</code>的最大子数组：<code>A[0..j+1]</code>的最大子数组要么是<code>A[0..j]</code>的最大子数组，要么是某个子数组<code>A[i..j+1]</code>（<em>0 &lt;= i &lt;= j+1</em>）。在已知<code>A[0..j]</code>的最大子数组的情况下，可以在<strong><em>线性时间</em></strong>内找出形如<code>A[i..j+1]</code>的最大子数组。</p>
</blockquote>
<p>上面引用中最后一句话中被标记为加粗斜体的文字，是我认为书中记录失误的地方，很显然，如果找出最大子数组的时间仍然是线性的，那么总的时间必然是<code>O(n^2)</code>，可以想象为一个双重循环样式。而实际上，通过缓存一些中间结果的方式，我们可以做到在<strong>常量时间</strong>内从前一个最大子数组推出下一个最大子数组。</p>
<h3 id="u5206_u6790"><a href="#u5206_u6790" class="headerlink" title="分析"></a>分析</h3><p>根据题目的提示，我们很容易可以推断出这个迭代过程中，第一个最大子数组就是<code>A[0]</code>，然后开始下一步迭代。在我们将数组扩展到下一个元素的时候（从<code>A[0..j]</code>扩展到<code>A[0..j+1]</code>），那么下一个最大子数组将只有以下两种形式：</p>
<ul>
<li>包含原来的最大子数组。</li>
<li>不包含原来的最大子数组。</li>
</ul>
<p>而不会出现跨越原来的最大子数组的情况。我们将原来的最大子数组记为<code>A[m..n]</code>，假设可以跨越原来的最大子数组的话，我们将新的最大子数组记为<code>A[x..y]</code>，其中<em>m &lt; x &lt;= n</em>且<em>n &lt;= y</em>，那么很显然我们可以构造一个新的子数组<code>A[m..y]</code>，这个子数组完全包含了原来的最大子数组<code>A[m..n]</code>，<code>A[x..y]</code>和<code>A[m..y]</code>可表示如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">A[x..y] = A[x..n] + A[n..y] // 去掉重合的A[n]</span><br><span class="line">A[m..y] = A[m..n] + A[n..y] // 去掉重合的A[n]</span><br></pre></td></tr></table></figure>
<p>由于<code>A[x..n]</code>被<strong>最大</strong>子数组<code>A[m..n]</code>所包含，那么很容易得知<code>A[m..n]</code>的和大于<code>A[x..n]</code>的和，所以可推得<code>A[m..y]</code>的和大于<code>A[x..y]</code>的和，那么<code>A[x..y]</code>就不是最大子数组了，与假设矛盾，因此不存在部分包含原来的最大子数组的情况。</p>
<p>现在我们考虑推导下一个最大子数组的问题。首先要想通下面几条规则：</p>
<blockquote>
<ul>
<li>如果包含原来的最大子数组的话，那么下一个最大子数组起始下标必然等于原来的最大子数组起始下标。</li>
<li>如果不包含原来的最大子数组的话，那么下一个最大子数组起始下标必然是原来的最大子数组结束下标之后的某一个<strong>正数</strong>的位置。不可能是负数，那是在做负功。</li>
</ul>
</blockquote>
<h3 id="u6C42_u89E3"><a href="#u6C42_u89E3" class="headerlink" title="求解"></a>求解</h3><p>为了方便说明，从现在开始，我们将原来的最大子数组记为<code>A[p..q]</code>，而下一个最大子数组记为<code>A[r..s]</code>。<strong>请丢掉上面反证法中定义的各种东西</strong>。</p>
<p>那么现在第一个问题是如何确定下一个最大子数组是否要包含原来的最大子数组呢？先考虑一种最简单的情况，根据最大子数组的定义，如果包含的话（<code>p == r &amp;&amp; s &gt; q</code>），很显然必须有<code>A[q+1..s]</code>的和大于0，否则岂不是做了负功，让<code>A[r..s]</code>的和比<code>A[p..q]</code>的和还要小。</p>
<blockquote>
<p>因此可以顺便提一下，当我们遍历数组元素的时候，就可以顺便计算出上面需要的<code>A[q+1..s]</code>的和并缓存了，而不用等到需要的时候又再去重复遍历计算。</p>
</blockquote>
<p>而在这里，我们也可以确定触发计算下一个最大子数组的几乎必要的条件：当前元素必须为正数，如果为负数，我们只需要简单的将其用来计算<code>A[q+1..s]</code>的和；否则如果计算确定需要包含的话，那么可以很简单的将原最大子数组“扩容”即可，也就是将结束下标更改为当前遍历时刻的元素下标，并重置各种中间缓存变量的值，比如我们缓存的从当前最大子数组结束下标到下一个可能的最大子数组开始坐标之间的元素之和，就需要重置为0了。</p>
<p>那么第二个问题也来了，当我们确定不包含原来的最大子数组之和，那么下一个最大子数组的起始下标该如何获取？按照上面说的，这个位置是个正数元素，但未必是原来的最大子数组结束之后的第一个正数位置，考虑下面的序列：</p>
<blockquote>
<p>8, -10, 3, -4, 9</p>
</blockquote>
<p>如果当前最大子数组为第一个元素，那么当遍历到第三个元素（值为3）的时候，由于<code>-10 + 3 = -7 &lt; 0</code>，因此新的最大子数组不可能为<code>8, -10, 3</code>，而<code>3 &lt; 8</code>，所以新的最大子数组也不可能为<code>3</code>，我们需要继续遍历，但是要记录当前这个正数位置，万一它后面就是个非常大的正数呢。当然在这里，为了说明情况，我给它后面弄了个比-3还小的元素，因此我们就可以丢掉刚刚记录的正数位置了，因为没有用，如果新的最大子数组不包含原来的话，那么也不应该从这个记录的正数位置开始，因为它的值被后面的负数“中和”了，如果带上它，我们将会被迫同时带上它后面的那个负数，结果就很容易想到了。</p>
<p>所以继续遍历，第五个元素是9，是个正数，我们可以更新记录位置的那个变量了。很显然，<code>-10 + 3 - 4 + 9 = -2 &lt; 0</code>，新的可能的最大子数组开始位置就应该是刚刚记录的正数位置了，而<code>9 &gt; 8</code>，因此，新的最大子数组起始位置应该为第五个元素了（当然，目前结束位置也应该是）。</p>
<p><strong>现在考虑一点例外。</strong></p>
<p>把上面的结论推广，也就是从当前最大子数组开始考虑，如果为了方便思考的话，可以将当前最大子数组等价替换为当前位置的一个元素，其值等于最大子数组的和。那么有时候即使上面的<code>A[q+1..s]</code>计算为正，我们也不能直接包含当前最大子数组。考虑下面这个序列：</p>
<blockquote>
<p>6, -8, 10</p>
</blockquote>
<p>最开始的最大子数组为<code>6</code>，然后我们按照前面的计算方式，可以得到<code>-8 + 10 = 2 &gt; 0</code>，但是这个时候，很明显可以看出正确的最大子数组应该为<code>10</code>，而不是<code>6, -8, 10</code>。至于原因，也很容易根据上面计算需要的正数位置的方法来解释，因为<code>6 - 8 = -2</code>，所以我们的下一个可能的最大子数组不可以从<code>6</code>开始，这个正数指针（此处不一定代表C语言中的那种指针，只是意义类似）应该被更新到下一个正数，然后继续进行相似的验证。</p>
<p>到这里，恰好统一了，初始情况下我们的正数指针应该指向第一个最大子数组的起始位置。而任何时候我们更新了当前最大子数组，也需要同步设置这个正数指针的值。而只要这个指针的值不等于当前最大子数组的起始地址，说明如果需要更新最大子数组的信息的话，需要从当前这个正数地址开始。</p>
<p>最后，还有个例外也需要考虑，那就是数组中全负数的情况，这时候就完全不需要上面这么麻烦了，只需要找出整个序列的最大值即可。</p>
<h3 id="u603B_u7ED3"><a href="#u603B_u7ED3" class="headerlink" title="总结"></a>总结</h3><blockquote>
<ul>
<li>当正数指针值等于当前最大子数组的起始地址时，如果从当前最大子数组结束后被遍历元素之和大于0，则需要“扩容”当前最大子数组。</li>
<li>当正数指针值不等于当前最大子数组的起始地址时，如果从这个正数指针开始的一个序列元素的和大于当前子数组的和，则需要将这个序列设置为当前最大子数组。</li>
<li>当开头一段序列全部是负数的时候，可以忽略掉这些元素；作为一个特例的情况，序列如果全部是负数，那么只需要返回其中的最大值。</li>
</ul>
</blockquote>
<p>好了，现在基本分析可以说已经完毕了，剩下的还是通过代码来理顺吧。</p>
<p>伪<code>C++</code>代码</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line">tuple&lt;<span class="keyword">unsigned</span> <span class="keyword">int</span>, <span class="keyword">unsigned</span> <span class="keyword">int</span>, <span class="keyword">int</span>&gt; find_maximum_subarray(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;<span class="built_in">array</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* 不考虑异常等情况，比如array为空之类的 */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> start = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> end = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> cur_sum = <span class="built_in">array</span>[<span class="number">0</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (cur_sum &lt;= <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (; i &lt; <span class="built_in">array</span>.size() &amp;&amp; <span class="built_in">array</span>[i] &lt;= <span class="number">0</span>; ++i)   <span class="comment">// 略过开始的非正数序列</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (cur_sum &lt; <span class="built_in">array</span>[i])</span><br><span class="line">            &#123;</span><br><span class="line">                cur_sum = <span class="built_in">array</span>[i];</span><br><span class="line">                start = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (i == <span class="built_in">array</span>.size())  <span class="comment">// 全负数特例</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> tuple&lt;<span class="keyword">unsigned</span> <span class="keyword">int</span>, <span class="keyword">unsigned</span> <span class="keyword">int</span>, <span class="keyword">int</span>&gt;(start, start, cur_sum);</span><br><span class="line">        &#125;</span><br><span class="line">        cur_sum = <span class="built_in">array</span>[i];</span><br><span class="line">        start = end = i;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> temp_sum = <span class="number">0</span>;   <span class="comment">// 缓存当前最大子数组后面被遍历元素之和</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> next_start = start;  <span class="comment">// 下一个候选最大子数组，以正数开始</span></span><br><span class="line">    <span class="keyword">int</span> next_sum = cur_sum;   <span class="comment">// 下一个候选最大子数组的累积和</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (; i &lt; <span class="built_in">array</span>.size(); ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        temp_sum += <span class="built_in">array</span>[i];</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">array</span>[i] &gt; <span class="number">0</span> &amp;&amp; next_sum &lt;= <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">/* 出现正数被负数抵消情况 */</span></span><br><span class="line">            next_start = i;</span><br><span class="line">            next_sum = <span class="built_in">array</span>[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            next_sum += <span class="built_in">array</span>[i];</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (next_start == start &amp;&amp; temp_sum &gt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            end = i;</span><br><span class="line">            cur_sum += temp_sum;</span><br><span class="line">            temp_sum = <span class="number">0</span>;</span><br><span class="line">            next_sum = cur_sum;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (next_start != start &amp;&amp; next_sum &gt; cur_sum)</span><br><span class="line">        &#123;</span><br><span class="line">            start = next_start;</span><br><span class="line">            end = i;</span><br><span class="line">            cur_sum = next_sum;</span><br><span class="line">            temp_sum = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> tuple&lt;<span class="keyword">unsigned</span> <span class="keyword">int</span>, <span class="keyword">unsigned</span> <span class="keyword">int</span>, <span class="keyword">int</span>&gt;(start, end, cur_sum);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>大概代码最终如上，还没有进行测试，也许考虑仍有不周。但是就上述代码来说，运行时间为线性的，第一个循环是针对开始的负数序列，同时也包括了全负数的形式。而当进入第二个循环的时候，两个保存元素和的变量<code>cur_sum</code>、<code>next_sum</code>均为正值，因此这个循环中的代码可以只针对正数/正负数混合优化，而不用考虑有全负数序列，也不用测试<code>cur_sum</code>等是否为负。而通过变量<code>i</code>的值可知，迭代次数一共为n（==<code>array.size()</code>）次，因此，整个过程的时间复杂度为<code>O(n)</code>。</p>
<h3 id="u53E6_u4E00_u79CD_u89E3_u6CD5"><a href="#u53E6_u4E00_u79CD_u89E3_u6CD5" class="headerlink" title="另一种解法"></a>另一种解法</h3><p>在<a href="http://clrs.skanev.com/04/01/05.html" target="_blank" rel="external">clrs.skanev.com</a>上又发现了另外一种解决方法，使用<code>C</code>语言实现；<strong>相比较上面的方法，思路更加通俗易懂</strong>，可以很容易的从简单的思考中想到并优化获得最终的优化过的代码。</p>
<p>下面贴出页面的代码，然后简单分析一下。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> left;</span><br><span class="line">    <span class="keyword">unsigned</span> right;</span><br><span class="line">    <span class="keyword">int</span> sum;</span><br><span class="line">&#125; max_subarray;</span><br><span class="line"></span><br><span class="line"><span class="function">max_subarray <span class="title">find_maximum_subarray</span><span class="params">(<span class="keyword">int</span> A[], <span class="keyword">unsigned</span> low, <span class="keyword">unsigned</span> high)</span> </span><br><span class="line"></span>&#123;</span><br><span class="line">    max_subarray suffixes[high - low];</span><br><span class="line"></span><br><span class="line">    suffixes[<span class="number">0</span>].left = low;</span><br><span class="line">    suffixes[<span class="number">0</span>].right = low + <span class="number">1</span>;</span><br><span class="line">    suffixes[<span class="number">0</span>].sum = A[low];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = low + <span class="number">1</span>; i &lt; high; i++) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (suffixes[i - <span class="number">1</span>].sum &lt; <span class="number">0</span>) </span><br><span class="line">        &#123;</span><br><span class="line">            suffixes[i].left = i;</span><br><span class="line">            suffixes[i].right = i + <span class="number">1</span>;</span><br><span class="line">            suffixes[i].sum = A[i];</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">        &#123;</span><br><span class="line">            max_subarray *previous = &amp;suffixes[i - <span class="number">1</span>];</span><br><span class="line">            suffixes[i].left = previous-&gt;left;</span><br><span class="line">            suffixes[i].right = i + <span class="number">1</span>;</span><br><span class="line">            suffixes[i].sum = previous-&gt;sum + A[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    max_subarray *max = &amp;suffixes[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = low + <span class="number">1</span>; i &lt; high; i++) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (max-&gt;sum &lt; suffixes[i].sum) </span><br><span class="line">        &#123;</span><br><span class="line">            max = &amp;suffixes[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> *max;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这段代码中一共需要对数组遍历两次，但是每次迭代过程中运行的代码也相对更少一些，与<code>C++</code>版本相比，在时间效率上相差不大，对于全正数序列，这段<code>C</code>代码相对要快一点，而如果是一个全负数序列，上面的<code>C++</code>版本运行应该更快，而其它情况下，则需要视实际序列情况而定，但总的来说，差别不大。而在空间复杂度上，<code>C</code>版本的代码很明显通常就需要更多的空间了，因为在第十行声明了一个长度等于<code>n</code>（==<code>high-low</code>）、大小为<code>sizeof(max_subarray) * n</code>的数组，相比而言，<code>C++</code>版本中总共只使用了大约<code>7 * sizeof(int)</code>字节的空间。</p>
<blockquote>
<p>除此之外，这段C代码由于使用了不定长数组语法，因此需要能支持<code>C99</code>标准的编译器来进行编译，当然，这在现在基本不是问题，只不过目前很多编译器即使支持部分或完整的<code>C99</code>标准，但默认编译选项依然是使用<code>C89</code>（<code>ISO C</code>/<code>ANSI C</code>）标准，需要注意查看。</p>
</blockquote>
<p>回到分析代码上，首先定义了一个结构体用于存储子数组的信息，<code>left</code>指示了子数组开始位置，<code>right</code>代表了子数组结束位置的下一位，注意这个位置是个哨兵位置，并不应该参与子数组和<code>sum</code>的计算。在方法体中声明的<code>suffixes</code>数组中，<code>suffixes[i]</code>存储在原数组<code>A</code>中以<code>A[i]</code>为结束位置的最大子数组的信息（所以<code>suffixes[i].right = i + 1</code>）。</p>
<p>因此，从最简单粗暴的方法入手，要获取以<code>A[i]</code>作为结束位置的最大子数组信息，只需要向前遍历计算就可以，但是这样一来，时间复杂度就达到了<code>O(n^2)</code>了。所以我们就要想办法利用缓存，利用上次计算的数据，在<code>O(1)</code>时间内计算出下一个最大子数组信息，分析一下上面的过程，每次都需要前向遍历，而实际上，每次遍历只比上一次同样的过程多分析一个元素：第一次是<code>A[0]</code>，第二次则是<code>A[0..1]</code>，第三次则是<code>A[0..2]</code>……一直重复，那么我们应该想办法利用上一次的结果以及当前的元素，计算出本次结果。借用上面的分析，如果一个最大子数组开始位置要不同于前一次的结果，那么只有当前一次的结果小于0，否则应该直接在前一次的结果上继续累加，只有前一次结果小于0的时候，才需要以当前位置作为新的开始位置。</p>
<blockquote>
<p>需要始终记住的是：当前元素必须作为结束位置，因此其实我们只有两种选择，要不加入前一次的结果（因为前一次的结果其实就相当于不包括当前元素的遍历结果），要不单独起始。而很容易想到，如果前一次结果已经被加到为负数了，当前元素无论为正为负，都肯定比加一个负数所得结果要大。</p>
</blockquote>
<p>因此出了第一次我们直接把起始元素的值作为<code>sum</code>的值，之后每次只需要利用前一次的结果经过常量时间的运算即可得到本次的结果。当所有结果都计算出来了之后，就很简单了，只需要一次寻找最大值得操作即可。</p>
<p>这段<code>C</code>代码很容易就可以证明其正确性，而有这段分析，类比之下，也许上面的<code>C++</code>算法的正确性也可以更容易验证了。</p>
<h2 id="u5C3E_u6CE8"><a href="#u5C3E_u6CE8" class="headerlink" title="尾注"></a>尾注</h2><p>心血来潮，偶然为之。在最后的完成线性时间的算法时，也是经历了不断的修正，也许结果仍然不完善，待测试。最后所为算法并没有完全按照题目的提示，但是第二个循环中最后的<code>if</code>和<code>else if</code>语句中，由<code>end = i</code>可知，这两个判断都是为了从当前最大子数组获取下一个具有<code>A[i..j+1]</code>形式的最大子数组，而在条件判断之外则没有更新过最大子数组信息，也就是依然等于<code>A[0..j]</code>的最大子数组。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>最近开始看<strong>《算法导论（第三版）》</strong>这本书，在第4章讲解<em>分治策略</em>的时候，举了一个例子：<strong>最大子数组</strong>问题（<code>4.1节</code>），简单来说，就是在一个给定的数组中，找出一个非空<strong>连续</strong>子数组，使这个数组中元素的<strong>总和最大</strong>，我们称这样的子数组为<strong>最大子数组</strong>。</p>
<p>在书中讲解分析了两种解决方法，一种就是最容易想到的暴力求解方法，另一种自然就是主题相关的分治法；然后在结束的时候，提到了可以实现一种更快速的线性时间的算法，这里将给出我的思路（原书这里描述有误，不知道是作者/译者笔误还是印刷错误）。</p>]]>
    
    </summary>
    
      <category term="Algorithm" scheme="http://3meng.github.io/tags/Algorithm/"/>
    
      <category term="Maximum SubArray" scheme="http://3meng.github.io/tags/Maximum-SubArray/"/>
    
      <category term="Algorithm" scheme="http://3meng.github.io/categories/Algorithm/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[将Hexo从Windows迁移到OS X]]></title>
    <link href="http://3meng.github.io/2016/01/14/Migrate-hexo-from-Windows-to-OS-X/"/>
    <id>http://3meng.github.io/2016/01/14/Migrate-hexo-from-Windows-to-OS-X/</id>
    <published>2016-01-14T09:49:00.000Z</published>
    <updated>2016-01-14T14:06:53.000Z</updated>
    <content type="html"><![CDATA[<p>几个月之前就想过，在 <strong>OS X</strong> 上配置一下<code>Hexo</code>，方便偶尔更新一下文章什么的，只是这么长时间了一拖再拖，总是在做着各种其它的事情，甚至Mac都很久没打开过了……</p>
<blockquote>
<p><strong>题外话：</strong>Mac的设计抛开不说，配合<strong>OS X</strong>用起来体验也不错，重点是续航，这都最少一个多月没开，现在开了，电量还有<em>60%</em>多，所有的App状态都还是之前合盖时候的状态。</p>
<p>顺便也得说一下，<strong>OS X</strong>上应用是少了一点，但是能用的基本都是布局很精美，也许部分是系统的一贯主题特色，而<strong>Retina</strong>屏幕的显示效果也是相当赞的。当然，用的也不多，出了系统那个<code>Finder</code>是个真尴尬的东西之外，基本其它的都感觉不错，比如现在正在用来编辑此文的<code>MacDown</code>，除了主题差了一点，各种显示效果是真的不错，文本编辑起来也是很舒服。</p>
</blockquote>
<p>扯远了，继续上文。最近准备弄弄<code>C++</code>，所以又打开了Mac，当然不是说<strong>Windows</strong>上面做不了开发，毕竟<code>Visual Studio</code>不是吹的，只是这次有点问题，一个依赖的项目在<strong>Windows</strong>上编译有问题，使用<code>MinGW</code>+<code>Clion</code>一直编译不通过，连接失败；然后我想着到<strong>OS X</strong>上试试，结果稍微改了一下<code>CMakeLists.txt</code>文件，就通过编译成功执行了。于是将项目搬到了Mac上面。</p>
<p>然后昨天又弄了一下，又将<code>Minecraft</code>给弄到<strong>OS X</strong>上面跑了，这下也基本可以单用<strong>OS X</strong>一阵子了，所以才有了标题所说的，想着准备把<code>Hexo</code>也弄过来了。这次也就没再往下拖延了。</p>
<a id="more"></a>
<h2 id="u8FC1_u79FB"><a href="#u8FC1_u79FB" class="headerlink" title="迁移"></a>迁移</h2><p>说起来当初在<strong>Windows</strong>上面配置<code>Hexo</code>还是<em>2015年3月</em>左右的时候，现在都几乎快忘了当初都对<code>Hexo</code>和上面的自定义主题做了什么修改了，特别是还有部分代码也做了改动，而正是因为这，所以一直就往后拖，没有迁移到Mac上……</p>
<p>不过，想想<code>Hexo</code>是基于<code>node</code>的，而且也是目录式的配置，应该只需要对比迁移在<strong>Windows</strong>上面的文档目录就行了，最关键的地方，基本应该都不用去改，直接拷贝<strong>Windows</strong>的配置就可以了，特别是主题，直接完整的把目录拷贝过来放到相应的<code>Theme</code>文件夹中，基本应该没啥问题。</p>
<h3 id="u521D_u59CB_u5316"><a href="#u521D_u59CB_u5316" class="headerlink" title="初始化"></a>初始化</h3><p>首先当然还是要安装和配置一些基本的东西，<code>git</code>和<code>node.js</code>我都早已经安装了，所以现在可以跳过，如果需要的话，可以直接到对应的官网上去下载安装包，或者直接用<code>Homebrew</code>安装更简单。现在我就直接开始安装<code>Hexo</code>了，很简单，终端中输入下面的命令就好：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$&gt; npm install -g hexo</span><br></pre></td></tr></table></figure>
<p>然后静静等待安装完成，期间我看到还调用了<code>clang</code>，所以也许还需要安装<code>XCode</code>开发环境。</p>
<p>当安装结束之后，就可以进入需要存放Blog文档的根目录了，进行初始化：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$&gt; hexo init</span><br></pre></td></tr></table></figure>
<p>然后还需要按照提示的，更新<code>Hexo</code>依赖：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$&gt; npm install</span><br></pre></td></tr></table></figure>
<h3 id="u8FD8_u539F_u914D_u7F6E"><a href="#u8FD8_u539F_u914D_u7F6E" class="headerlink" title="还原配置"></a>还原配置</h3><p>好了，现在可以开始对比这个默认的设置和目录结构与原来的有什么区别了。而对比之后，其实区别并不是很大，出了有些默认自带的插件以及<code>Hexo</code>本身版本号改变了一点，基本配置文件还是原来的几个，所以先直接覆盖了，主要是那个<code>_config.yml</code>文件，这里对比了一下，配置基本还是一样的，所以直接用上了原来的配置。</p>
<p>然后根目录下面有个<code>package.json</code>文件，这个主要就是记录插件和一些相应版本信息的，因此直接用<code>Visual Studio Code</code>打开这个默认生成的和原来<strong>Windows</strong>上面使用的文件进行对比，看看当初安装了哪些插件，就又重新安装了一遍。下面给出一些常用的插件安装命令：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-generator-index --save</span><br><span class="line">npm install hexo-generator-archive --save</span><br><span class="line">npm install hexo-generator-category --save</span><br><span class="line">npm install hexo-generator-tag --save</span><br><span class="line">npm install hexo-server --save</span><br><span class="line">npm install hexo-deployer-git --save</span><br><span class="line">npm install hexo-deployer-heroku --save</span><br><span class="line">npm install hexo-deployer-rsync --save</span><br><span class="line">npm install hexo-deployer-openshift --save</span><br><span class="line">npm install hexo-renderer-marked --save</span><br><span class="line">npm install hexo-renderer-stylus --save</span><br><span class="line">npm install hexo-generator-feed --save</span><br><span class="line">npm install hexo-generator-sitemap --save</span><br></pre></td></tr></table></figure>
<p>当然，有部分插件其实默认自带了的，只需要注意在全局配置文件中启用就行。我这里就是直接复原当初安装的，然后直接拷贝覆盖当初的配置就好了，里面已经启用插件并进行配置了。</p>
<p>然后再就是主题部分了，这个基本没遇到问题，直接把目录完全拷贝进来就好了，毕竟原先的配置中是已经修改启用主题了。至于对主题中曾经动工过的代码文件，就懒得去翻了。</p>
<h3 id="u8FD8_u539F_u6587_u6863"><a href="#u8FD8_u539F_u6587_u6863" class="headerlink" title="还原文档"></a>还原文档</h3><p>当然，上面的一切，都是为这一步服务，一切的中心当然还是为了能完全还原当初的文档效果，既然上面都准备好了，这里就只需要将整个<code>source</code>目录下面的文档包括文件夹都拷贝过来了。然后开始测试，启动预览：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$&gt; hexo s -g</span><br></pre></td></tr></table></figure>
<p>当然，这里是使用的简写语法，你也可以执行完整的命令，先编译文档：<code>hexo generate</code>，然后启动服务器：<code>hexo server</code>。接着就可以打开浏览器，输入地址进行访问了，默认是<code>http:://0.0.0.0:4000/</code>或者<code>http://localhost:4000/</code>。</p>
<p>这里预览一切正常，效果也和原来的一样，对比了一下生成的<code>public</code>目录，也没有问题，所有插件都运行正常，该有的文件都正常生成了，包括RSS和sitemap之类的xml文档。</p>
<h2 id="u6536_u5DE5"><a href="#u6536_u5DE5" class="headerlink" title="收工"></a>收工</h2><p>得益于<code>node</code>的跨平台性，所以这次迁移基本就没遇到什么困难，就是还原了一下配置而已，而主要也就是确保完整的还原，如果你担心出现兼容问题，可以在安装<code>hexo</code>和对应插件的时候，完整的限制版本号，等到最后确保没有问题的时候，在升级插件之类的即可。</p>
<p>接下来，也就该准备在<code>git</code>上建立一个仓库，用于同步所有的源文档了，也就是各种<code>Markdown</code>文件等，这样才方便在<strong>OS X</strong>和<strong>Windows</strong>之间完整的同步所有数据。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>几个月之前就想过，在 <strong>OS X</strong> 上配置一下<code>Hexo</code>，方便偶尔更新一下文章什么的，只是这么长时间了一拖再拖，总是在做着各种其它的事情，甚至Mac都很久没打开过了……</p>
<blockquote>
<p><strong>题外话：</strong>Mac的设计抛开不说，配合<strong>OS X</strong>用起来体验也不错，重点是续航，这都最少一个多月没开，现在开了，电量还有<em>60%</em>多，所有的App状态都还是之前合盖时候的状态。</p>
<p>顺便也得说一下，<strong>OS X</strong>上应用是少了一点，但是能用的基本都是布局很精美，也许部分是系统的一贯主题特色，而<strong>Retina</strong>屏幕的显示效果也是相当赞的。当然，用的也不多，出了系统那个<code>Finder</code>是个真尴尬的东西之外，基本其它的都感觉不错，比如现在正在用来编辑此文的<code>MacDown</code>，除了主题差了一点，各种显示效果是真的不错，文本编辑起来也是很舒服。</p>
</blockquote>
<p>扯远了，继续上文。最近准备弄弄<code>C++</code>，所以又打开了Mac，当然不是说<strong>Windows</strong>上面做不了开发，毕竟<code>Visual Studio</code>不是吹的，只是这次有点问题，一个依赖的项目在<strong>Windows</strong>上编译有问题，使用<code>MinGW</code>+<code>Clion</code>一直编译不通过，连接失败；然后我想着到<strong>OS X</strong>上试试，结果稍微改了一下<code>CMakeLists.txt</code>文件，就通过编译成功执行了。于是将项目搬到了Mac上面。</p>
<p>然后昨天又弄了一下，又将<code>Minecraft</code>给弄到<strong>OS X</strong>上面跑了，这下也基本可以单用<strong>OS X</strong>一阵子了，所以才有了标题所说的，想着准备把<code>Hexo</code>也弄过来了。这次也就没再往下拖延了。</p>]]>
    
    </summary>
    
      <category term="Hexo" scheme="http://3meng.github.io/tags/Hexo/"/>
    
      <category term="随笔" scheme="http://3meng.github.io/categories/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[深入探究 {x:Bind}]]></title>
    <link href="http://3meng.github.io/2015/12/08/Deep-research-with-x-Bind/"/>
    <id>http://3meng.github.io/2015/12/08/Deep-research-with-x-Bind/</id>
    <published>2015-12-08T09:16:17.000Z</published>
    <updated>2015-12-08T16:08:28.000Z</updated>
    <content type="html"><![CDATA[<p>今天无意间谈到了<code>UWP</code>应用中为数据绑定新引入的一个<code>XAML</code>标记：<code>{x:Bind}</code>，对于这个新的标记的作用和原理，网上的一般说法都是：</p>
<blockquote>
<p>相比较传统的<code>{Binding}</code>方式，<code>{x:Bind｝</code>的效率更高，因为<code>{x:Bind}</code>的数据绑定发生编译期间，绑定工作在编译时期就已经完成了，所以我们在使用<code>{x:Bind}</code>的时候，需要一个明确的数据类型（按：这也符合强类型语言的特点）。</p>
</blockquote>
<p>这些也都基本说的过去，相对于传统的<code>{Binding}</code>方式，这种类型严格的绑定行为，最起码也可以减少对象装箱和拆箱行为的性能损耗，而至于其它的由于强类型带来的可以优化的地方，就要看编译器的行为了。</p>
<p>但是基本上也就到此为止了，大部分关于<code>{x:Bind}</code>的说明文章，接下来就是将示例，陈述简单的用法，不说讲解一下<code>{x:Bind}</code>的实现方式，就连深入一点的用法，比如双向绑定等都没有提到多少。</p>
<blockquote>
<p>这里别说那些示例中写了个<code>Mode=TwoWay</code>就是双向绑定了，如果双向绑定这么简单，那在传统的<code>{Binding}</code>方式中又为什么要弄个<code>INotifyPropertyChanged</code>接口，还要弄个叫依赖属性的东西出来？</p>
</blockquote>
<a id="more"></a>
<h2 id="u7F18_u8D77"><a href="#u7F18_u8D77" class="headerlink" title="缘起"></a>缘起</h2><p>所以今天突然提起了这个新的绑定方式，一时间就突然发现认识的还是太少了，仅仅只是从网上看到了一点关于它的一点概述而已，一旦深入讨论下去，才发现很多东西都没有关注过，也许是我搜索的少了吧，没看到有谁深入的说明这个新加入的标记，即使是MSDN上也是说明了一下用法以及与<code>{Binding}</code>的对比而已。</p>
<p>多的也不多说了，既然找不到，那还不如自己去测试探索一翻。</p>
<p>先把网上总结的一些<code>{x:Bind}</code>特点罗列一下：</p>
<ul>
<li>强类型，因此某些时候你需要使用XAML中的方式强制类型转换。</li>
<li>上下文是<code>Page</code>或者<code>UserControl</code>。</li>
<li>默认的绑定模式是<strong>OneTime</strong>。</li>
<li>在数据模版中使用时，需要指定<code>{x:DataType}</code>。</li>
<li>支持绑定事件到方法。</li>
</ul>
<p>而关于<code>{x:Bind}</code>的更多详细说明，可以参考MSDN文档：<a href="https://msdn.microsoft.com/zh-cn/library/windows/apps/mt204783.aspx" title="{x:Bind} 标记扩展" target="_blank" rel="external">{x:Bind} 标记扩展</a>。关于<code>{x:Bind}</code>和<code>{Binding}</code>标记使用方法和功能的对比，也可以参考MSDN的说明：<a href="https://msdn.microsoft.com/zh-cn/library/windows/apps/mt210946.aspx#_x_bind_____binding______" title="{x:Bind} 和 {Binding} 功能比较" target="_blank" rel="external">{x:Bind} 和 {Binding} 功能比较</a>。</p>
<h2 id="u6D4B_u8BD5"><a href="#u6D4B_u8BD5" class="headerlink" title="测试"></a>测试</h2><p>新建一个UWP项目，然后开始测试了。因为只是看看<code>{x:Bind}</code>的工作方式，因此程序有些设计细节就不用过多关注了……</p>
<h3 id="OneTime_u7ED1_u5B9A"><a href="#OneTime_u7ED1_u5B9A" class="headerlink" title="OneTime绑定"></a>OneTime绑定</h3><p>这是<code>{x:Bind}</code>的默认绑定模式，也基本是比较常用的模式了，这种情况没什么好测试的了，正常的写法都能跑起来，而且也可以想像得到编译器会怎么处理：直接在页面构造的某个时期赋值一次罢了。这里需要注意的所有事项也就是<code>{x:Bind}</code>的基本用法注意事项了。<br><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ** .cs **</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">string</span> Title &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125; = <span class="string">"Title"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ** .xaml **</span></span><br><span class="line">&lt;TextBlock Text=<span class="string">"&#123;x:Bind Title&#125;"</span> /&gt;</span><br></pre></td></tr></table></figure></p>
<h3 id="OneWay__26amp_3B_TwoWay_u7ED1_u5B9A"><a href="#OneWay__26amp_3B_TwoWay_u7ED1_u5B9A" class="headerlink" title="OneWay &amp; TwoWay绑定"></a>OneWay &amp; TwoWay绑定</h3><p>这两个之所以放到一起，是因为我没有测试过<strong>OneWay</strong>模式，而是直接观察<strong>TwoWay</strong>模式下的绑定情况的。</p>
<p>下面是测试用的XAML主要代码：<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#60;Grid Background=&#34;&#123;ThemeResource ApplicationPageBackgroundThemeBrush&#125;&#34;&#62;&#10;    &#60;TextBlock&#10;        Text=&#34;&#123;x:Bind Time, Mode=TwoWay&#125;&#34;&#10;        HorizontalAlignment=&#34;Right&#34;&#10;        VerticalAlignment=&#34;Top&#34;&#10;        Height=&#34;100&#34;/&#62;&#10;    &#60;TextBox&#10;        Text=&#34;&#123;x:Bind Time, Mode=TwoWay&#125;&#34;&#10;        Margin=&#34;0,100,0,0&#34;&#10;        VerticalAlignment=&#34;Top&#34;/&#62;&#10;    &#60;Button&#10;        VerticalAlignment=&#34;Bottom&#34;&#10;        Content=&#34;Update Time&#34;&#10;        Click=&#34;ButtonBase_OnClick&#34;/&#62;&#10;&#60;/Grid&#62;</span><br></pre></td></tr></table></figure></p>
<p>其中中间那个<code>TextBox</code>是测试过程中加入的，是因为<strong>TwoWay</strong>模式的<code>TextBlock</code>不好测试，没有文本框方便。</p>
<p>C#主要代码如下：<br><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">sealed</span> <span class="keyword">partial</span> <span class="keyword">class</span> <span class="title">MainPage</span> : <span class="title">Page</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">string</span> Time &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MainPage</span>(<span class="params"></span>)</span><br><span class="line">    </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.InitializeComponent();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ButtonBase_OnClick</span>(<span class="params"><span class="keyword">object</span> sender, RoutedEventArgs e</span>)</span><br><span class="line">    </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.Time = DateTime.Now.ToString(<span class="string">"D"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这个相对于默认用法来说，其实也就是简单的给<code>{x:Bind}</code>加了一句说明：<code>Mode=TwoWay</code>，这也是网上大部分示例的做法。</p>
<p>在第一次测试中，忽略那个<code>TextBox</code>控件，我们使用按钮更改<code>Time</code>的值，看看界面的变化。而测试结果也在意料之中，不管你怎么点击那个按钮，界面都不会有任何的变化，<code>Time</code>的值根本不能传到控件属性上，这很好解释，这个<code>Time</code>就是一个很简单的自动属性而已，深入一点也就是两个普通的对象方法而已，根本没有地方把属性值传出去，甚至外界也根本不知道这个值已经变化了。</p>
<h3 id="TwoWay_u7ED1_u5B9A_u4E2D_u4ECE_u76EE_u6807_u5230_u6E90"><a href="#TwoWay_u7ED1_u5B9A_u4E2D_u4ECE_u76EE_u6807_u5230_u6E90" class="headerlink" title="TwoWay绑定中从目标到源"></a>TwoWay绑定中从目标到源</h3><p>继续上面那个测试，不同的是这次使用<code>TextBox</code>控件。</p>
<p>给<code>Time</code>属性的<em>set</em>访问器添加断点，然后开始在<code>TextBox</code>中输入一些内容，然后让文本框失去焦点，这时候可以看到断点命中了，当运行完毕之后，<code>Time</code>的值也被设置成为了文本框中输入的内容。当然这个时候<code>TextBlock</code>的内容仍然没有任何变化，原因和上面的一样，这时候的<code>Time</code>只是个普通属性。</p>
<p>但是无论如何，这里可以说明<code>{x:Bind}</code>是具有一般绑定的行为的，那么目前我们就剩下一个问题了，为什么从绑定源到绑定目标的路径不通？也就是绑定源的变化无法反馈给绑定目标？</p>
<h3 id="INotifyPropertyChanged"><a href="#INotifyPropertyChanged" class="headerlink" title="INotifyPropertyChanged"></a>INotifyPropertyChanged</h3><p>既然<code>{x:Bind}</code>和<code>{Binding}</code>如此类似，那么可不可以借鉴在<code>{Binding}</code>方式中使用的一些方式呢？比如<code>INotifyPropertyChanged</code>。上面提到无法报告绑定源的变化，而在传统的绑定中，出了使用依赖属性之外，我们还可以使用<code>INotifyPropertyChanged</code>接口，而在<code>{x:Bind}</code>方式中呢，是不是也可以试试这种方式，将属性的变化通知出去。</p>
<p>那么对C#代码稍微改变一下：<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">public sealed partial class MainPage : Page, INotifyPropertyChanged</span><br><span class="line">&#123;</span><br><span class="line">    public event PropertyChangedEventHandler PropertyChanged;</span><br><span class="line"></span><br><span class="line">    private string _time;</span><br><span class="line"></span><br><span class="line">    public string Time</span><br><span class="line">    &#123;</span><br><span class="line">        get &#123; return _time; &#125;</span><br><span class="line">        set</span><br><span class="line">        &#123;</span><br><span class="line">            if (value != _time)</span><br><span class="line">            &#123;</span><br><span class="line">                _time = value;</span><br><span class="line">                PropertyChanged?.Invoke(this, new PropertyChangedEventArgs("Time"));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>然后在运行测试一下，结果很出人意外。</p>
<p>无论是更改文本框的内容，还是点击按钮主动更新<code>Time</code>的值，都没有任何反应，也就是说，绑定仍然没有起作用，准确来说，是绑定仍然无法完成从绑定源到绑定目标的更新。</p>
<p>这也就是说，传统的方式无法适用于<code>{x:Bind}</code>了。因此需要看看编译器对这个标记扩展做了哪些工作了，而在VS的智能提示中，输入<code>this.</code>之后也可以看到一个新的<code>Page</code>类的字段：<code>Bindings</code>，也许和这种新的编译时绑定有关。</p>
<h2 id="u6DF1_u5165"><a href="#u6DF1_u5165" class="headerlink" title="深入"></a>深入</h2><p>既然要看看编译器究竟对XAML文档中的<code>{x:Bind}</code>做了什么，第一个想法当然是看看编译后生成的代码了，于是找到<strong>obj</strong>目录下临时文件，找到所有的以<em>MainPage</em>开头的文件，然后打开看看其中的内容。而很幸运，在这里找到了答案，具体来说，实在下面三个文件中：</p>
<ul>
<li>MainPage.g.i.cs</li>
<li>MainPage.g.cs</li>
<li>MainPage.xaml</li>
</ul>
<h3 id="MainPage-g-i-cs"><a href="#MainPage-g-i-cs" class="headerlink" title="MainPage.g.i.cs"></a>MainPage.g.i.cs</h3><p>下面是这个文件中的主要内容：<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">partial class MainPage : global::Windows.UI.Xaml.Controls.Page</span><br><span class="line">&#123;</span><br><span class="line">    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("Microsoft.Windows.UI.Xaml.Build.Tasks"," 14.0.0.0")]</span><br><span class="line">    private bool _contentLoaded;</span><br><span class="line"></span><br><span class="line">    /// &lt;summary&gt;</span><br><span class="line">    /// InitializeComponent()</span><br><span class="line">    /// &lt;/summary&gt;</span><br><span class="line">    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("Microsoft.Windows.UI.Xaml.Build.Tasks"," 14.0.0.0")]</span><br><span class="line">    [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]</span><br><span class="line">    public void InitializeComponent()</span><br><span class="line">    &#123;</span><br><span class="line">        // ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    private interface IMainPage_Bindings</span><br><span class="line">    &#123;</span><br><span class="line">        void Initialize();</span><br><span class="line">        void Update();</span><br><span class="line">        void StopTracking();</span><br><span class="line">    &#125;</span><br><span class="line">#pragma warning disable 0169</span><br><span class="line">    private IMainPage_Bindings Bindings;</span><br><span class="line">#pragma warning restore 0169</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>可以看到这里声明了一个私有接口和对应的字段。在这个接口中定义了三个操作方法，而在看完后面两个文件内容之后，就可以知道每个方法的作用了。而这个接口，也是整个绑定环节中的一个重要部分。</p>
<h3 id="MainPage-g-cs"><a href="#MainPage-g-cs" class="headerlink" title="MainPage.g.cs"></a>MainPage.g.cs</h3><p>这个文件内容有点多，也是绑定实现的主要部分。<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br></pre></td><td class="code"><pre><span class="line">partial class MainPage : </span><br><span class="line">    global::Windows.UI.Xaml.Controls.Page, </span><br><span class="line">    global::Windows.UI.Xaml.Markup.IComponentConnector,</span><br><span class="line">    global::Windows.UI.Xaml.Markup.IComponentConnector2</span><br><span class="line">&#123;</span><br><span class="line">    internal class XamlBindingSetters</span><br><span class="line">    &#123;</span><br><span class="line">        public static void Set_Windows_UI_Xaml_Controls_TextBlock_Text(global::Windows.UI.Xaml.Controls.TextBlock obj, global::System.String value, string targetNullValue)</span><br><span class="line">        &#123;</span><br><span class="line">            if (value == null &amp;&amp; targetNullValue != null)</span><br><span class="line">            &#123;</span><br><span class="line">                value = targetNullValue;</span><br><span class="line">            &#125;</span><br><span class="line">            obj.Text = value ?? global::System.String.Empty;</span><br><span class="line">        &#125;</span><br><span class="line">        public static void Set_Windows_UI_Xaml_Controls_TextBox_Text(global::Windows.UI.Xaml.Controls.TextBox obj, global::System.String value, string targetNullValue)</span><br><span class="line">        &#123;</span><br><span class="line">            if (value == null &amp;&amp; targetNullValue != null)</span><br><span class="line">            &#123;</span><br><span class="line">                value = targetNullValue;</span><br><span class="line">            &#125;</span><br><span class="line">            obj.Text = value ?? global::System.String.Empty;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    private class MainPage_obj1_Bindings :</span><br><span class="line">        global::Windows.UI.Xaml.Markup.IComponentConnector,</span><br><span class="line">        IMainPage_Bindings</span><br><span class="line">    &#123;</span><br><span class="line">        private global::TestApp1.MainPage dataRoot;</span><br><span class="line">        private bool initialized = false;</span><br><span class="line">        private const int NOT_PHASED = (1 &lt;&lt; 31);</span><br><span class="line">        private const int DATA_CHANGED = (1 &lt;&lt; 30);</span><br><span class="line"></span><br><span class="line">        // Fields for each control that has bindings.</span><br><span class="line">        private global::Windows.UI.Xaml.Controls.TextBlock obj2;</span><br><span class="line">        private global::Windows.UI.Xaml.Controls.TextBox obj3;</span><br><span class="line"></span><br><span class="line">        private MainPage_obj1_BindingsTracking bindingsTracking;</span><br><span class="line"></span><br><span class="line">        public MainPage_obj1_Bindings()</span><br><span class="line">        &#123;</span><br><span class="line">            this.bindingsTracking = new MainPage_obj1_BindingsTracking(this);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // IComponentConnector</span><br><span class="line"></span><br><span class="line">        public void Connect(int connectionId, global::System.Object target)</span><br><span class="line">        &#123;</span><br><span class="line">            switch(connectionId)</span><br><span class="line">            &#123;</span><br><span class="line">                case 2:</span><br><span class="line">                    this.obj2 = (global::Windows.UI.Xaml.Controls.TextBlock)target;</span><br><span class="line">                    (this.obj2).RegisterPropertyChangedCallback(global::Windows.UI.Xaml.Controls.TextBlock.TextProperty,</span><br><span class="line">                        (global::Windows.UI.Xaml.DependencyObject sender, global::Windows.UI.Xaml.DependencyProperty prop) =&gt;</span><br><span class="line">                        &#123;</span><br><span class="line">                            if (this.initialized)</span><br><span class="line">                            &#123;</span><br><span class="line">                                // Update Two Way binding</span><br><span class="line">                                this.dataRoot.Time = (this.obj2).Text;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;);</span><br><span class="line">                    break;</span><br><span class="line">                case 3:</span><br><span class="line">                    this.obj3 = (global::Windows.UI.Xaml.Controls.TextBox)target;</span><br><span class="line">                    (this.obj3).LostFocus += (global::System.Object sender, global::Windows.UI.Xaml.RoutedEventArgs e) =&gt;</span><br><span class="line">                        &#123;</span><br><span class="line">                            if (this.initialized)</span><br><span class="line">                            &#123;</span><br><span class="line">                                // Update Two Way binding</span><br><span class="line">                                this.dataRoot.Time = (this.obj3).Text;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;;</span><br><span class="line">                    break;</span><br><span class="line">                default:</span><br><span class="line">                    break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // IMainPage_Bindings</span><br><span class="line"></span><br><span class="line">        public void Initialize()</span><br><span class="line">        &#123;</span><br><span class="line">            if (!this.initialized)</span><br><span class="line">            &#123;</span><br><span class="line">                this.Update();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        public void Update()</span><br><span class="line">        &#123;</span><br><span class="line">            this.Update_(this.dataRoot, NOT_PHASED);</span><br><span class="line">            this.initialized = true;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public void StopTracking()</span><br><span class="line">        &#123;</span><br><span class="line">            this.bindingsTracking.ReleaseAllListeners();</span><br><span class="line">            this.initialized = false;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // MainPage_obj1_Bindings</span><br><span class="line"></span><br><span class="line">        public void SetDataRoot(global::TestApp1.MainPage newDataRoot)</span><br><span class="line">        &#123;</span><br><span class="line">            this.bindingsTracking.ReleaseAllListeners();</span><br><span class="line">            this.dataRoot = newDataRoot;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public void Loading(global::Windows.UI.Xaml.FrameworkElement src, object data)</span><br><span class="line">        &#123;</span><br><span class="line">            this.Initialize();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // Update methods for each path node used in binding steps.</span><br><span class="line">        private void Update_(global::TestApp1.MainPage obj, int phase)</span><br><span class="line">        &#123;</span><br><span class="line">            if (obj != null)</span><br><span class="line">            &#123;</span><br><span class="line">                if ((phase &amp; (NOT_PHASED | DATA_CHANGED | (1 &lt;&lt; 0))) != 0)</span><br><span class="line">                &#123;</span><br><span class="line">                    this.Update_Time(obj.Time, phase);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        private void Update_Time(global::System.String obj, int phase)</span><br><span class="line">        &#123;</span><br><span class="line">            if((phase &amp; ((1 &lt;&lt; 0) | NOT_PHASED | DATA_CHANGED)) != 0)</span><br><span class="line">            &#123;</span><br><span class="line">                XamlBindingSetters.Set_Windows_UI_Xaml_Controls_TextBlock_Text(this.obj2, obj, null);</span><br><span class="line">                XamlBindingSetters.Set_Windows_UI_Xaml_Controls_TextBox_Text(this.obj3, obj, null);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        private class MainPage_obj1_BindingsTracking</span><br><span class="line">        &#123;</span><br><span class="line">            global::System.WeakReference&lt;MainPage_obj1_Bindings&gt; WeakRefToBindingObj; </span><br><span class="line"></span><br><span class="line">            public MainPage_obj1_BindingsTracking(MainPage_obj1_Bindings obj)</span><br><span class="line">            &#123;</span><br><span class="line">                WeakRefToBindingObj = new global::System.WeakReference&lt;MainPage_obj1_Bindings&gt;(obj);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            public void ReleaseAllListeners()</span><br><span class="line">            &#123;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    /// &lt;summary&gt;</span><br><span class="line">    /// Connect()</span><br><span class="line">    /// &lt;/summary&gt;</span><br><span class="line">    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("Microsoft.Windows.UI.Xaml.Build.Tasks"," 14.0.0.0")]</span><br><span class="line">    [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]</span><br><span class="line">    public void Connect(int connectionId, object target)</span><br><span class="line">    &#123;</span><br><span class="line">        switch(connectionId)</span><br><span class="line">        &#123;</span><br><span class="line">        case 4:</span><br><span class="line">            &#123;</span><br><span class="line">                global::Windows.UI.Xaml.Controls.Button element4 = (global::Windows.UI.Xaml.Controls.Button)(target);</span><br><span class="line">                #line 23 "..\..\..\MainPage.xaml"</span><br><span class="line">                ((global::Windows.UI.Xaml.Controls.Button)element4).Click += this.ButtonBase_OnClick;</span><br><span class="line">                #line default</span><br><span class="line">            &#125;</span><br><span class="line">            break;</span><br><span class="line">        default:</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">        this._contentLoaded = true;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("Microsoft.Windows.UI.Xaml.Build.Tasks"," 14.0.0.0")]</span><br><span class="line">    [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]</span><br><span class="line">    public global::Windows.UI.Xaml.Markup.IComponentConnector GetBindingConnector(int connectionId, object target)</span><br><span class="line">    &#123;</span><br><span class="line">        global::Windows.UI.Xaml.Markup.IComponentConnector returnValue = null;</span><br><span class="line">        switch(connectionId)</span><br><span class="line">        &#123;</span><br><span class="line">        case 1:</span><br><span class="line">            &#123;</span><br><span class="line">                global::Windows.UI.Xaml.Controls.Page element1 = (global::Windows.UI.Xaml.Controls.Page)target;</span><br><span class="line">                MainPage_obj1_Bindings bindings = new MainPage_obj1_Bindings();</span><br><span class="line">                returnValue = bindings;</span><br><span class="line">                bindings.SetDataRoot(this);</span><br><span class="line">                this.Bindings = bindings;</span><br><span class="line">                element1.Loading += bindings.Loading;</span><br><span class="line">            &#125;</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">        return returnValue;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>不过具体内容也很好理解，抛开几个属于<code>MainPage</code>类的方法先不管，在这里定义了几个内部类：<code>XamlBindingSetters</code>、<code>MainPage_obj1_Bindings</code>，其中<code>MainPage_obj1_Bindings</code>类实现了前面定义的那个接口，同时还定义了一个内部类<code>MainPage_obj1_BindingsTracking</code>作为所谓跟踪的一个实现，具体在这里我们不管它的作用。</p>
<p>首先看第一个类<code>XamlBindingSetters</code>，这个类中定义的方法很明显是给控件属性赋值使用的，而且是专门真对声明了<code>{x:Bind}</code>标记的控件和属性。</p>
<p>然后是主要的类<code>MainPage_obj1_Bindings</code>了，这个实现了所谓绑定接口的类中，我们重点关注接口声明的三个方法。而对于另外有个相对比较长的方法<code>Connect</code>，可以看出来就是实现从绑定目标到绑定源的更新了，这里就不分析了，很简单的代码。</p>
<p>对于接口中三个方法的实现中，可以抛去<code>StopTracking()</code>方法不管，这个方法和上面所说的<code>MainPage_obj1_BindingsTracking</code>类有关，也许是我的例子过于简单，在这个类中看不出来有什么特殊的工作要做，除了保持了一个弱引用。</p>
<p>而剩下的两个方法，最后的调用都指向了一个名叫<code>Update_</code>的私有方法，在这个方法里面有调用了一个针对具体属性的<code>Update_Time</code>方法，而从这里，我们就可以看到对<code>XamlBindingSetters</code>类的调用了，而这个类是为了设置控件的绑定属性的值的。那么很显然，<strong>在</strong><code>{x:Bind}</code><strong>方式的绑定中，从绑定源到绑定目标的更新是由上述内部接口中定义的</strong><code>Update</code><strong>方法来完成的</strong>。</p>
<p>具体为什么跳跃这么远，又扯到了上一个文件中定义的接口，我们可以上面最后一个方法的内容：<br><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">MainPage_obj1_Bindings bindings = <span class="keyword">new</span> MainPage_obj1_Bindings();</span><br><span class="line"><span class="keyword">this</span>.Bindings = bindings;</span><br></pre></td></tr></table></figure></p>
<p>因此，具体来说，是<strong>使用私有字段</strong><code>Bindings</code><strong>来完成更新的</strong>。</p>
<p>到这里已经基本结束了，也许关于那些<code>switch</code>分支中的数字感到有些莫名其妙，那么可以再看看最后一个文件。</p>
<h3 id="MainPage-xaml"><a href="#MainPage-xaml" class="headerlink" title="MainPage.xaml"></a>MainPage.xaml</h3><p>内容很少，可以很容易看出那些奇怪的数字来源：<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#60;Page x:ConnectionId=&#39;1&#39;&#10;    x:Class=&#34;TestApp1.MainPage&#34;&#10;    xmlns=&#34;http://schemas.microsoft.com/winfx/2006/xaml/presentation&#34;&#10;    xmlns:x=&#34;http://schemas.microsoft.com/winfx/2006/xaml&#34;&#10;    xmlns:local=&#34;using:TestApp1&#34;&#10;    xmlns:d=&#34;http://schemas.microsoft.com/expression/blend/2008&#34;&#10;    xmlns:mc=&#34;http://schemas.openxmlformats.org/markup-compatibility/2006&#34;&#10;    mc:Ignorable=&#34;d&#34;&#62;&#10;&#10;    &#60;Grid Background=&#34;&#123;ThemeResource ApplicationPageBackgroundThemeBrush&#125;&#34;&#62;&#10;        &#60;TextBlock x:ConnectionId=&#39;2&#39;&#10;                                             &#10;            HorizontalAlignment=&#34;Right&#34;&#10;            VerticalAlignment=&#34;Top&#34;&#10;            Height=&#34;100&#34;/&#62;&#10;        &#60;TextBox x:ConnectionId=&#39;3&#39;&#10;                                             &#10;            Margin=&#34;0,100,0,0&#34;&#10;            VerticalAlignment=&#34;Top&#34;/&#62;&#10;        &#60;Button x:ConnectionId=&#39;4&#39;&#10;            VerticalAlignment=&#34;Bottom&#34;&#10;            Content=&#34;Update Time&#34;&#10;                                      /&#62;&#10;    &#60;/Grid&#62;&#10;&#60;/Page&#62;</span><br></pre></td></tr></table></figure></p>
<p>所谓留空的地方也不是我故意弄得，使本来就如此，对比一下，可以发现留空的位置就是我们使用了绑定或者声明事件的位置。</p>
<h3 id="u989D_u5916_u7684"><a href="#u989D_u5916_u7684" class="headerlink" title="额外的"></a>额外的</h3><p>其实关于上面三个文件，特别是第二个里面，有些地方我们不用深究，最起码对于这个简单的例子不用，比如那些奇怪的数字和常量定义，还有那条件判断等。除非你打算在深入研究这个框架，不过那时候也不应该看这些代码了。</p>
<p>而对于上面这些具体代码，具体的方法，我们也不用过分深究究竟是什么时候被调用的，我们只需要知道当你在XAML中使用了<code>{x:Bind}</code>的时候，<code>Bindings</code>字段就处于可用的情况了，至于那些<code>Initialize</code>、<code>Initialize</code>、<code>GetBindingConnector</code>方法是什么时候调用的，可以不用管了。而如果不放心，你可以像我下面调用的那样使用。</p>
<h2 id="u6700_u540E"><a href="#u6700_u540E" class="headerlink" title="最后"></a>最后</h2><p>最后就留下测试之后的正确工作的代码吧，改动也不大，就是换了一个通知方式而已。<br><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">sealed</span> <span class="keyword">partial</span> <span class="keyword">class</span> <span class="title">MainPage</span> : <span class="title">Page</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">string</span> _time;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">string</span> Time</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">get</span> &#123; <span class="keyword">return</span> _time; &#125;</span><br><span class="line">        <span class="keyword">set</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">value</span> != _time)</span><br><span class="line">            &#123;</span><br><span class="line">                _time = <span class="keyword">value</span>;</span><br><span class="line">                <span class="keyword">this</span>.Bindings?.Update();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MainPage</span>(<span class="params"></span>)</span><br><span class="line">    </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.InitializeComponent();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ButtonBase_OnClick</span>(<span class="params"><span class="keyword">object</span> sender, RoutedEventArgs e</span>)</span><br><span class="line">    </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.Time = DateTime.Now.ToString(<span class="string">"D"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>重点就是属性的<em>set</em>访问器中的对<code>Bindings.Update()</code>方法的调用了。</p>
<h2 id="u7ED3_u8BED"><a href="#u7ED3_u8BED" class="headerlink" title="结语"></a>结语</h2><p>关于<code>{x:Bind}</code>目前就告一段落吧，其实还有很多细节可以去深究，比如针对依赖属性的行为。如果你多去试试，未尝不能和<code>{Binding}</code>一样玩出各种花样来。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>今天无意间谈到了<code>UWP</code>应用中为数据绑定新引入的一个<code>XAML</code>标记：<code>{x:Bind}</code>，对于这个新的标记的作用和原理，网上的一般说法都是：</p>
<blockquote>
<p>相比较传统的<code>{Binding}</code>方式，<code>{x:Bind｝</code>的效率更高，因为<code>{x:Bind}</code>的数据绑定发生编译期间，绑定工作在编译时期就已经完成了，所以我们在使用<code>{x:Bind}</code>的时候，需要一个明确的数据类型（按：这也符合强类型语言的特点）。</p>
</blockquote>
<p>这些也都基本说的过去，相对于传统的<code>{Binding}</code>方式，这种类型严格的绑定行为，最起码也可以减少对象装箱和拆箱行为的性能损耗，而至于其它的由于强类型带来的可以优化的地方，就要看编译器的行为了。</p>
<p>但是基本上也就到此为止了，大部分关于<code>{x:Bind}</code>的说明文章，接下来就是将示例，陈述简单的用法，不说讲解一下<code>{x:Bind}</code>的实现方式，就连深入一点的用法，比如双向绑定等都没有提到多少。</p>
<blockquote>
<p>这里别说那些示例中写了个<code>Mode=TwoWay</code>就是双向绑定了，如果双向绑定这么简单，那在传统的<code>{Binding}</code>方式中又为什么要弄个<code>INotifyPropertyChanged</code>接口，还要弄个叫依赖属性的东西出来？</p>
</blockquote>]]>
    
    </summary>
    
      <category term="Binding" scheme="http://3meng.github.io/tags/Binding/"/>
    
      <category term="XAML" scheme="http://3meng.github.io/tags/XAML/"/>
    
      <category term="UWP" scheme="http://3meng.github.io/categories/UWP/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[开发问题记录]]></title>
    <link href="http://3meng.github.io/2015/11/14/dev-issue/"/>
    <id>http://3meng.github.io/2015/11/14/dev-issue/</id>
    <published>2015-11-14T14:35:25.000Z</published>
    <updated>2015-12-08T12:25:22.000Z</updated>
    <content type="html"><![CDATA[<p>记录一些开发过程中遇到的问题，或者疑惑的地方，在记录的时候，还没有解决或者找到原因，也许会在以后的时间里去验证和解决。如果知道了原因所在，也会及时更新并记录下来。</p>
<p>就当是一个历史的记忆，也避免日后在重复同样的问题。</p>
<blockquote>
<p>最近更新时间：<code>2015年11月14日</code></p>
</blockquote>
<a id="more"></a>
<ul>
<li>2015年11月14日：UWP中Storyboard问题</li>
</ul>
<h2 id="UWP"><a href="#UWP" class="headerlink" title="UWP"></a>UWP</h2><p>在开发UWP应用过程中遇到的一些问题（疑惑）。</p>
<h3 id="Storyboard_u4E2D_u7684_u52A8_u753B_u7EBF_u4E0D_u8FD0_u884C_uFF08_u65E0_u6548_uFF09"><a href="#Storyboard_u4E2D_u7684_u52A8_u753B_u7EBF_u4E0D_u8FD0_u884C_uFF08_u65E0_u6548_uFF09" class="headerlink" title="Storyboard中的动画线不运行（无效）"></a>Storyboard中的动画线不运行（无效）</h3><p>开发UWP应用，肯定少不了做响应式设计，毕竟在这里微软就直接没把调整窗口大小的权利交给开发者，所以为了保证在任何（绝大多数）情况下应用都能有正确的呈现，应用一般都需要针对不同大小的窗口做出不同的优化和响应。</p>
<p>我在应用中使用了一个<code>RelativePanel</code>作为布局容器，然后使用<code>AdaptiveTrigger</code>来响应不同的分辨率，最开始是只使用了<code>VisualState.Setters</code>属性，做了一下简单的显示和隐藏。但是在测试过程中，总是感觉这样直接的隐藏内容有些突兀，视觉上的感受很不顺眼，因此决定加一点动画，原本以为很简单的一件事，毕竟<code>VisualState</code>中就提供了<code>Storyboard</code>属性，可以直接添加一些针对UI元素的动画效果，因此直接使用了<code>DoubleAnimation</code>来操作控件的<code>Width</code>属性，结果运行之后却发现没有效果，控件宽度根本没有发生变化。</p>
<p>于是查看了一下新的<code>DoubleAnimation</code>对象的属性列表，发现有个<code>EnableDependentAnimation</code>属性，用于控制被认为是<a href="https://msdn.microsoft.com/zh-cn/library/windows/apps/xaml/jj819807.aspx#dependent" target="_blank" rel="external">从属动画</a>的动画是否可以运行，而根据定义，我上面定义的动画应该属于<em>从属动画</em> 的，因此我显式的将这个属性设置为<code>True</code>，但是结果却很意外，该动画仍然没有起作用。</p>
<blockquote>
<p>微软为了优化应用性能也是用尽了方法，现在连动画系统都改变这么多，不再是以前那样所有动画都一视同仁，只要声明动画目标和属性路径就行了。</p>
</blockquote>
<p>最后无奈之下，只好换成<code>RenderTransform</code>来实现效果，也就是独立动画，但是有些效果却没有按照计划样式来实现，因为毕竟使用<code>RenderTransform</code>并不会触发布局时间，也就不会引起布局的更新，而有所改变的也只有一个受<code>RenderTransform</code>控制的元素罢了。</p>
<p>下面是应用运行环境：</p>
<ul>
<li><strong>系统</strong>：Windows 10 专业版，版本 1511（OS内部版本 10586.3），会员快速通道</li>
<li><strong>Runtime</strong>：.Net Framework 4.6</li>
<li><strong>Visual Studio</strong>：版本 14.0.23107.0 D14REL</li>
<li><strong>Microsoft .NET Framework</strong>：版本 4.6.01038</li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<p>记录一些开发过程中遇到的问题，或者疑惑的地方，在记录的时候，还没有解决或者找到原因，也许会在以后的时间里去验证和解决。如果知道了原因所在，也会及时更新并记录下来。</p>
<p>就当是一个历史的记忆，也避免日后在重复同样的问题。</p>
<blockquote>
<p>最近更新时间：<code>2015年11月14日</code></p>
</blockquote>]]>
    
    </summary>
    
      <category term="Storyboard" scheme="http://3meng.github.io/tags/Storyboard/"/>
    
      <category term="笔记" scheme="http://3meng.github.io/categories/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[开发笔记]]></title>
    <link href="http://3meng.github.io/2015/07/31/development-notes/"/>
    <id>http://3meng.github.io/2015/07/31/development-notes/</id>
    <published>2015-07-31T13:30:47.000Z</published>
    <updated>2015-11-16T15:49:00.000Z</updated>
    <content type="html"><![CDATA[<p>在开发过程中的一些笔记心得，包括一些技巧方法和记录。不定期整理更新。</p>
<blockquote>
<p>最近更新时间：<code>2015年11月16日</code></p>
</blockquote>
<a id="more"></a>
<ul>
<li>2015年7月31日，初始化。</li>
<li>2015年11月12日，<code>VisualStateManager</code>使用细节。</li>
<li>2015年11月16日，<code>UIElement.Transitions</code>使用注意。</li>
</ul>
<h2 id="u521D_u59CB_u5316"><a href="#u521D_u59CB_u5316" class="headerlink" title="初始化"></a>初始化</h2><p>文章原文件建立很早了，但是期间由于各种各样的问题（包括自身和外界的），一直到今天（2015年11月12日）才继续，不仅仅是继续这篇文章，也是继续博客。期间因为更换了电脑硬盘，重装了一次系统，所以很多程序都没有安装，这也是一直拖到今天的原因之一，其它的，不一一细表。</p>
<h2 id="VisualStateManager_u7528_u6CD5_u7EC6_u8282"><a href="#VisualStateManager_u7528_u6CD5_u7EC6_u8282" class="headerlink" title="VisualStateManager用法细节"></a>VisualStateManager用法细节</h2><blockquote>
<p>2015年11月12日</p>
</blockquote>
<p>今天开始尝试<code>Universal Windows Platform (UWP)</code>应用程序开发，首先当然是找到Windows 10中针对响应式程序设计所新增的内容，从网上搜索，发现一片都是提<code>RelativePanel</code>控件和<code>AdaptiveTrigger</code>的，于是就从这两个开始入门了。</p>
<p>但是在测试过程中，发现设定的<code>AdaptiveTrigger</code>并没有起作用，到MSDN中搜索发现了下面的一句话：</p>
<blockquote>
<p>When you use <code>StateTriggers</code>, <strong>ensure</strong> that the <code>VisualStateGroup</code> is declared under the first child of the root in order for the triggers to take effect automatically.</p>
</blockquote>
<p>看来问题出在这里了，使用了<code>StateTriggers</code>属性之后，必须确保<code>VisualStateGroup</code>是在根节点的第一个子节点下声明的，而在这里，根节点为<code>Page</code>元素，默认是有一个<code>Grid</code>类型的布局子元素，也就是我们需要在这个<code>Grid</code>元素下面声明我们的状态组对象，而这里我直接写到了根节点（<code>Page</code>）下了，所以会没有被触发。</p>
<p>当修改之后，可以很直观的在VS的XAML设计器中看到状态的变化，这一点很赞，不用再去编译运行来查看效果了。</p>
<p>而这里的提示，也可以作为一条“潜规则”了，回想一下，以前自定义控件样式/模版的时候，也都是把控件的视觉状态组声明到元素<code>ControlTemplate</code>的子节点下，虽然那时候并没有使用<code>StateTriggers</code>，（因为没有），但是这个习惯却可以保持下去，免得出现不必要的bug。</p>
<blockquote>
<p>顺便提一句，有关UWP的内容，最好尽量选择查看英文MSDN页面，因为目前好像中文版还没有更新，仍然是老旧的内容说明。比如，你可以对比一下上面的<code>Visual State</code>类的两种语言说明：<a href="https://msdn.microsoft.com/zh-cn/library/windows/apps/windows.ui.xaml.visualstate.aspx" title="Visual State类中文页面" target="_blank" rel="external">Visual State 类</a> &amp; <a href="https://msdn.microsoft.com/en-us/library/windows/apps/windows.ui.xaml.visualstate.aspx" title="Visual State class" target="_blank" rel="external">Visual State class</a>，可以很明显的发现中文页面内容仍然是以前的WinRT说明。</p>
</blockquote>
<h2 id="UIElement-Transitions"><a href="#UIElement-Transitions" class="headerlink" title="UIElement.Transitions"></a>UIElement.Transitions</h2><p><code>Transitions</code>是<code>UIElement</code>类型的一个属性，所以所有的UWP控件都有这个属性，它控制了控件在展示时候的一些变换。但是在使用XAML样式为这个属性赋值的时候，却有些细节需要注意。</p>
<p><code>Transitions</code>属性是一个集合类型，而通常在XAML中，对于集合类型，我们可以采用集合类型的隐式赋值方式，也就是省略集合类型的声明，而直接写集合中的元素。但是对于<code>Transitions</code>属性来说，我们却必须显式的声明一个<code>TransitionCollection</code>对象作为其子元素，如果直接利用隐式集合语法赋值的话，将会在运行时产生一个<code>System.AccessViolationException</code>异常：</p>
<blockquote>
<p><code>System.AccessViolationException</code>类型的未经处理的异常在 <strong>YourApp.exe</strong> 中发生</p>
<p>其他信息：Attempted to read or write protected memory. This is often an indication that other memory is corrupt.</p>
</blockquote>
<p>上面的异常将会在页面对象构造时候发送，从异常抛出位置可以看出是在<code>this.InitializeComponent()</code>方法中，但是这个异常并没有更多的详细信息，因此只能推测是XAML分析构造过程中出现了异常，而经过验证最近的改动，最终确定就是由于在给<code>Transitions</code>赋值时采用了隐式集合写法导致的：<br><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;UIElement&gt;  </span><br><span class="line">    &lt;UIElement.Transitions&gt;</span><br><span class="line">        oneOrMoreTransitions</span><br><span class="line">    &lt;/UIElement.Transitions&gt;</span><br><span class="line">&lt;/UIElement&gt;</span><br></pre></td></tr></table></figure></p>
<p>而将声明改成如下形式，程序就可以正常运行了：<br><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;UIElement&gt;</span><br><span class="line">    &lt;UIElement.Transitions&gt;</span><br><span class="line">        &lt;TransitionCollection&gt;</span><br><span class="line">            oneOrMoreTransitions</span><br><span class="line">        &lt;/TransitionCollection&gt;</span><br><span class="line">    &lt;/UIElement.Transitions&gt;</span><br><span class="line">&lt;/UIElement&gt;</span><br></pre></td></tr></table></figure></p>
<p>而其实仔细想来，对于<code>Transitions</code>属性来说，确实是必须采用下面的显式赋值方式，因为所谓的隐式集合语法，其实只是XAML分析器帮我们做了一些事情，分析器会自动调用集合属性的<code>Add</code>方法（大部分情况下都是）来添加我们在集合中声明的元素。而这里就需要注意，分析器是不会主动去为集合属性赋值的，而通常也是不需要的，因为一般集合属性是只读的，也就是说当我们使用这个集合属性的时候，属性所有者会确保这个集合属性已经初始化了。而我们再去查看<code>Transitions</code>的声明：<br><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> TransitionCollection Transitions &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br></pre></td></tr></table></figure></p>
<p>验证可以知道默认情况下这个属性值为<code>null</code>，因此如果我们采用隐式集合语法，将会引发<code>NullReferenceException</code>类型的异常，因此我们需要显示的声明一个<code>TransitionCollection</code>对象，将其赋值给<code>Transitions</code>属性。而为什么实际抛出的异常不是空引用异常呢？从抛出的异常描述来看，异常是一直等到向属性写入内容的时候产生的，也就类似与在C/C++中对一个空指针进行操作，这个时候的异常就是由操作系统产生的了，因为指针所指的内存区域是不可以被应用程序操作的；因此我们可以猜测微软对XAML分析器有一个非常底层的实现（为了效率），因此除了少数操作，大部分XAML异常将会更类似于C/C++中的异常提示。</p>
<p>最后，其实在MSDN上的<a href="https://msdn.microsoft.com/zh-cn/library/windows/apps/windows.ui.xaml.uielement.transitions.aspx" target="_blank" rel="external">UIElement.Transitions Property</a>页面也有对此的备注提示：</p>
<blockquote>
<p><strong>重要事项</strong> 使用<code>TransitionCollection</code>值的所有属性的 XAML 语法出现异常，所以你必须将一个显式<code>TransitionCollection</code>对象元素声明为值，然后为要使用的每个过渡动画提供对象元素作为<code>TransitionCollection</code>的子元素。对于大多数其他 XAML 集合属性，你可以省略集合对象元素，因为它可以是隐式的，但是使用<code>TransitionCollection</code>的属性不支持隐式集合用法。</p>
</blockquote>
]]></content>
    <summary type="html">
    <![CDATA[<p>在开发过程中的一些笔记心得，包括一些技巧方法和记录。不定期整理更新。</p>
<blockquote>
<p>最近更新时间：<code>2015年11月16日</code></p>
</blockquote>]]>
    
    </summary>
    
      <category term="Transitions" scheme="http://3meng.github.io/tags/Transitions/"/>
    
      <category term="VisualStateManager" scheme="http://3meng.github.io/tags/VisualStateManager/"/>
    
      <category term="笔记" scheme="http://3meng.github.io/categories/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[C# 6 新特性]]></title>
    <link href="http://3meng.github.io/2015/07/21/New-Language-Features-in-CSharp6/"/>
    <id>http://3meng.github.io/2015/07/21/New-Language-Features-in-CSharp6/</id>
    <published>2015-07-21T06:52:31.000Z</published>
    <updated>2015-07-21T14:58:36.000Z</updated>
    <content type="html"><![CDATA[<p>微软新一代开发工具<code>Visual Studio 2015</code>正式版已经于北京时间 2015年7月20日 23:30 发布了，而作为<code>.Net</code>开发中的主力开发语言<code>C#</code>，也已经走到了<code>C# 6</code>。</p>
<p>那么作为<code>C#</code>开发语言的最新版本，微软又给它添加或改进了哪些特性呢？</p>
<p><code>C# 6</code>的新特性是和微软的 .Net 开源编译器<a href="https://github.com/dotnet/roslyn" target="_blank" rel="external">Roslyn</a>紧密相连的，在其 GitHub 页面中，也给出了<code>C# 6</code>新特性：<a href="https://github.com/dotnet/roslyn/wiki/New-Language-Features-in-C%23-6" target="_blank" rel="external">New Language Features in C# 6</a>。下面内容一部分为简单的翻译，以及在查看时的一些理解和疑问，由于目前我还没发下载最新版 Win10 和 VS 2015，因此有些地方暂时还没发验证猜想。等待后续更新。</p>
<p>下面先列出<code>C# 6</code>中的新特性：</p>
<ul>
<li>自动属性初始值表达式<blockquote>
<p><code>public int X { get; set; } = x;</code></p>
</blockquote>
</li>
<li>只读自动属性<blockquote>
<p><code>public int Y { get; } = y;</code></p>
</blockquote>
</li>
<li><p>静态导入<code>using static</code></p>
<blockquote>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="keyword">using</span> <span class="keyword">static</span> System.Console;</span><br><span class="line">&gt; ...</span><br><span class="line">&gt; Write(<span class="number">4</span>);</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
</li>
<li><p>索引器对象初始化</p>
<blockquote>
<p><code>new JObject { [&quot;x&quot;] = 3 }</code></p>
</blockquote>
</li>
<li>在<code>catch</code>和<code>finally</code>块中使用<code>await</code><blockquote>
<p><code>try { ... } catch { await ... } finally { await ... }</code></p>
</blockquote>
</li>
<li>异常筛选器<blockquote>
<p><code>catch(Exception e) when (e.Count &gt; 5) { ... }</code></p>
</blockquote>
</li>
<li>函数/属性表达式<blockquote>
<p><code>public double Dist =&gt; Sqrt(X * X + Y * Y);</code></p>
</blockquote>
</li>
<li>Null条件运算符<blockquote>
<p><code>customer?.Orders?[5]</code></p>
</blockquote>
</li>
<li>字符串插值<blockquote>
<p><code>$&quot;{p.Name} is {p.Age} years old.&quot;</code></p>
</blockquote>
</li>
<li><code>nameof</code>运算符<blockquote>
<p><code>string s = nameof(Console.Write);</code></p>
</blockquote>
</li>
<li>其它改进<blockquote>
<ul>
<li>#pragma</li>
<li>集合初始化支持扩展方法<code>Add</code></li>
<li>重载方法解析改进</li>
</ul>
</blockquote>
</li>
</ul>
<a id="more"></a>
<h2 id="u81EA_u52A8_u5C5E_u6027_u589E_u5F3A"><a href="#u81EA_u52A8_u5C5E_u6027_u589E_u5F3A" class="headerlink" title="自动属性增强"></a>自动属性增强</h2><h3 id="u81EA_u52A8_u5C5E_u6027_u521D_u59CB_u503C_u8868_u8FBE_u5F0F"><a href="#u81EA_u52A8_u5C5E_u6027_u521D_u59CB_u503C_u8868_u8FBE_u5F0F" class="headerlink" title="自动属性初始值表达式"></a>自动属性初始值表达式</h3><p>现在可以为自动属性添加一个初始值表达式了，如下：<br><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Customer</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">string</span> First &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125; = <span class="string">"Jane"</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">string</span> Last &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125; = <span class="string">"Doe"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>我们知道所谓自动属性，其实是属性的一种快速写法，编译器为我们做了额外的工作，包括为自动属性生成对应的字段以及添加读写方法。这里的自动熟悉初始值，会被直接赋值给属性对应的字段，而不经过自动属性的<code>setter</code>索引器，就如同直接给字段赋初始值一样。因此，如果我们在应用中使用了某些<code>AOP</code>框架，并且为属性添加了<code>NotifyPropertyChanged</code>或类似特性，当属性被初始化的时候，我们并不能得到通知。</p>
<blockquote>
<p>和字段的初始化一样，自动属性初始化表达式中不能引用<code>this</code>，因为在类被初始化之前它们就已经被执行了。</p>
</blockquote>
<h3 id="u53EA_u8BFB_u81EA_u52A8_u5C5E_u6027"><a href="#u53EA_u8BFB_u81EA_u52A8_u5C5E_u6027" class="headerlink" title="只读自动属性"></a>只读自动属性</h3><p>现在我们可以声明一个只读自动熟悉了，同时使用上面的自动熟悉初始化表达式设置初始值。<br><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Customer</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">string</span> First &#123; <span class="keyword">get</span>; &#125; = <span class="string">"Jane"</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">string</span> Last &#123; <span class="keyword">get</span>; &#125; = <span class="string">"Doe"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>只读自动属性对应的字段被隐式的声明为<code>readonly</code>。因此，一个只读属性还可以在其声明类型的构造函数中赋值，实质上也还是直接对属性所对应的字段赋值。<br><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Customer</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">string</span> Name &#123; <span class="keyword">get</span>; &#125;;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Customer</span>(<span class="params"><span class="keyword">string</span> first, <span class="keyword">string</span> last</span>)</span><br><span class="line">    </span>&#123;</span><br><span class="line">        Name = first + <span class="string">" "</span> + last;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>这使得我们可以更简洁的表述类型，但是它同时也消除了语言中可变类型与不可变类型之间的区别：自动属性是一种简写，只有当我们愿意让我们的类可变并且属性适合使用默认值初始化的时候才使用。现在，使用只读属性，可变与不可变之间区别不再。</p>
</blockquote>
<h2 id="u6210_u5458_u8868_u8FBE_u5F0F"><a href="#u6210_u5458_u8868_u8FBE_u5F0F" class="headerlink" title="成员表达式"></a>成员表达式</h2><p>Lambda表达式可以被定义为一个表达式主体以及传统函数那样由一个块包含的函数体。现在这种特性也可以用来定义类型成员了。</p>
<h3 id="u65B9_u6CD5_u8868_u8FBE_u5F0F"><a href="#u65B9_u6CD5_u8868_u8FBE_u5F0F" class="headerlink" title="方法表达式"></a>方法表达式</h3><p>方法、用户自定义运算符以及转换操作现在可以通过使用“Lambda箭头”给定一个表达主体来定义了。<br><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Point <span class="title">Move</span>(<span class="params"><span class="keyword">int</span> dx, <span class="keyword">int</span> dy</span>) </span>=&gt; <span class="keyword">new</span> Point(x + dx, y + dy); </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Complex <span class="keyword">operator</span> +(Complex a, Complex b) =&gt; a.Add(b);</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">implicit</span> <span class="keyword">operator</span> <span class="title">string</span>(<span class="params">Person p</span>) </span>=&gt; p.First + <span class="string">" "</span> + p.Last;</span><br></pre></td></tr></table></figure></p>
<p>就如同方法语句块中只有一个返回表达式一样。</p>
<p>对于无返回值的方法、包括返回<code>Task</code>类型的方法、这种语法仍然适用，但是箭头后面必须是一个声明表达式：<br><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Print</span>(<span class="params"></span>) </span>=&gt; Console.WriteLine(First + <span class="string">" "</span> + Last);</span><br></pre></td></tr></table></figure></p>
<h3 id="u5C5E_u6027_u8868_u8FBE_u5F0F"><a href="#u5C5E_u6027_u8868_u8FBE_u5F0F" class="headerlink" title="属性表达式"></a>属性表达式</h3><p>属性和索引器可以有读方法（<code>get</code>）以及写方法（<code>set</code>）。上述的表达式写法可以被用到只读属性和索引器中：<br><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">string</span> Name =&gt; First + <span class="string">" "</span> + Last;</span><br><span class="line"><span class="keyword">public</span> Customer <span class="keyword">this</span>[<span class="keyword">long</span> id] =&gt; store.LookupCustomer(id);</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>注意这里并没有<code>get</code>关键字，使用这种语法时它是隐式声明的。</p>
</blockquote>
<h2 id="Using_static"><a href="#Using_static" class="headerlink" title="Using static"></a>Using static</h2><p>这个特性使我们可以声明静态方法所在命名空间，然后再代码中可以直接使用静态方法而不用添加其所在命名空间前缀。<br><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="keyword">static</span> System.Console;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">static</span> System.Math;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">static</span> System.DayOfWeek;</span><br><span class="line"><span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"></span>)</span><br><span class="line">    </span>&#123;</span><br><span class="line">        WriteLine(Sqrt(<span class="number">3</span>*<span class="number">3</span> + <span class="number">4</span>*<span class="number">4</span>)); </span><br><span class="line">        WriteLine(Friday - Monday); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>当我们需要使用特定域中的一组函数时很有用，<code>System.Math</code>只是一个常见的例子。同时，它还允许直接指定枚举类型个人命名，比如<code>System.DayOfWeek</code>。</p>
<h3 id="u6269_u5C55_u65B9_u6CD5"><a href="#u6269_u5C55_u65B9_u6CD5" class="headerlink" title="扩展方法"></a>扩展方法</h3><p>扩展方法是静态方法，但是被当作实例方法来使用。通过使用<code>using static</code>而不是引入命名空间，使得一个类型的扩展方法可被真正做为“扩展”方法。<br><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="keyword">static</span> System.Linq.Enumerable; <span class="comment">// The type, not the namespace</span></span><br><span class="line"><span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"></span>)</span><br><span class="line">    </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> range = Range(<span class="number">5</span>, <span class="number">17</span>);                <span class="comment">// Ok: not extension</span></span><br><span class="line">        <span class="keyword">var</span> odd = Where(range, i =&gt; i % <span class="number">2</span> == <span class="number">1</span>); <span class="comment">// Error, not in scope</span></span><br><span class="line">        <span class="keyword">var</span> even = range.Where(i =&gt; i % <span class="number">2</span> == <span class="number">0</span>); <span class="comment">// Ok</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="Null_u6761_u4EF6_u8FD0_u7B97_u7B26"><a href="#Null_u6761_u4EF6_u8FD0_u7B97_u7B26" class="headerlink" title="Null条件运算符"></a>Null条件运算符</h2><p>在我们的代码中通常要进行一堆的 null 检查，现在<code>C# 6</code>引入了新的运算符，只有当运算符作用者不为<code>null</code>时才能访问其成员和元素，否则表达式返回<code>null</code>。<br><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>? length = customers?.Length; <span class="comment">// null if customers is null</span></span><br><span class="line">Customer first = customers?[<span class="number">0</span>];  <span class="comment">// null if customers is null</span></span><br></pre></td></tr></table></figure></p>
<p>Null条件运算符可以和空合并运算符 <code>??</code> 联合使用：<br><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> length = customers?.Length ?? <span class="number">0</span>; <span class="comment">// 0 if customers is null</span></span><br></pre></td></tr></table></figure></p>
<p>Null条件运算符只有在检查到成员非空时才会执行后面紧跟的成员访问、元素访问和方法调用。<br><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>? first = customers?[<span class="number">0</span>].Orders.Count();</span><br></pre></td></tr></table></figure></p>
<p>上面这个例子本质上等价于：<br><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>? first = (customers != <span class="keyword">null</span>) ? customers[<span class="number">0</span>].Orders.Count() : <span class="keyword">null</span>;</span><br></pre></td></tr></table></figure></p>
<p>除了<code>customers</code>被计算一次之外，除非<code>customers</code>非空，否则跟在 <code>?</code> 后面的成员访问和方法调用将不会被执行。</p>
<p>当然，Null条件运算符可以被连续调用，每次调用都会进行<code>null</code>检查。<br><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>? first = customers?[<span class="number">0</span>].Orders?.Count();</span><br></pre></td></tr></table></figure></p>
<p>注意一个方法调用不可以直接跟在 <code>?</code> 运算符之后，因为这会导致太多的语法歧义。</p>
<blockquote>
<p>等待测试。这里在 <code>?</code> 运算符后面直接跟的方法是指当前类型中的方法还是 <code>?</code> 前面的变量所拥有的实例方法？看前面的示例，是可以直接调用变量的实力方法的（<code>...Orders?.Count();</code>），如果是说当前类型的方法，那么歧义是因为与三目运算符 <code>?:</code> 冲突吗？</p>
</blockquote>
<p>然而，我们可以调用委托中的<code>Invoke</code>方法：<br><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (predicate?.Invoke(e) ?? <span class="keyword">false</span>) &#123; … &#125;</span><br></pre></td></tr></table></figure></p>
<p>这种使用方法应该在事件触发的时候很常用：<br><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PropertyChanged?.Invoke(<span class="keyword">this</span>, args);</span><br></pre></td></tr></table></figure></p>
<p>这是一种简单并且<code>线程安全</code>的方式去在触发事件之前做 null 检查。说它是<code>线程安全</code>的，是因为这个方式只执行 <code>?</code> 左边表达式一次，并且将其保存在一个临时变量中。</p>
<blockquote>
<p>说明：这里保存在临时变量中的是那个<code>PropertyChanged</code>实例。</p>
<p>也就是说，上面的事件触发代码等价于：<br><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> handler = PropertyChanged;</span><br><span class="line"><span class="keyword">if</span> (handler != <span class="keyword">null</span>)</span><br><span class="line">&#123;</span><br><span class="line">    handler.Invoke(<span class="keyword">this</span>, args);</span><br><span class="line">&#125;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></p>
<p>而这里，需要说明在<code>.Net</code>中使用<code>C#</code>进行事件的订阅和取消时，其实返回的<code>Handler</code>是一个新的对象，所以对于上面的代码来说，当我们通过临时变量<code>handler</code>引用<code>PropertyChanged</code>实例之后，即使又有线程对这个事件进行了取消订阅操作导致事件变为<code>null</code>，也不会影响这个临时变量的值，因此不会导致接下来的调用出现异常。</p>
<p>因此，通过 <code>?</code> 方式触发事件是<code>线程安全</code>的（这个也应该是编译器特别优化的吧）。而在使用<code>C# 6</code>之前的语言编程时，如果要触发一个事件，我们也应该像上面那样通过一个临时变量引用事件实例，然后再判断触发，这样才能保证事件的线程安全。</p>
</blockquote>
<h2 id="u5B57_u7B26_u4E32_u63D2_u503C"><a href="#u5B57_u7B26_u4E32_u63D2_u503C" class="headerlink" title="字符串插值"></a>字符串插值</h2><p><code>string.Format</code>和它的同类被我们经常使用，但是它们的用法有一点笨拙且容易出错。特别是占位符<code>{0}</code>等，它们必须与参数分别提供：<br><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> s = String.Format(<span class="string">"&#123;0&#125; is &#123;1&#125; year&#123;&#123;s&#125;&#125; old"</span>, p.Name, p.Age);</span><br></pre></td></tr></table></figure></p>
<p>字符串插值允许我们通过“洞”来直接把表达式插入到正确的位置：<br><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> s = $<span class="string">"&#123;p.Name&#125; is &#123;p.Age&#125; year&#123;&#123;s&#125;&#125; old"</span>;</span><br></pre></td></tr></table></figure></p>
<p>和<code>string.Format</code>一样，我们可以定义一些可选的对齐及格式方式：<br><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> s = $<span class="string">"&#123;p.Name,20&#125; is &#123;p.Age:D3&#125; year&#123;&#123;s&#125;&#125; old"</span>;</span><br></pre></td></tr></table></figure></p>
<p>“洞”的内容可以是任意表达式，甚至是其它字符串：<br><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> s = $<span class="string">"&#123;p.Name&#125; is &#123;p.Age&#125; year&#123;(p.Age == 1 ? "</span><span class="string">" : "</span>s<span class="string">")&#125; old"</span>;</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>注意条件表达式被括号括起来了，所以 <code>: &quot;s&quot;</code> 并不会和格式说明符混淆。</p>
</blockquote>
<h2 id="nameof_u8868_u8FBE_u5F0F"><a href="#nameof_u8868_u8FBE_u5F0F" class="headerlink" title="nameof表达式"></a>nameof表达式</h2><p>有时候我们会需要提供一些这样的字符串，字符串内容是某些程序元素的名称。比如当我们抛出一个<code>ArgumentNullException</code>异常的时候，我们希望可以给出出错的参数名称；而当我们激活一个<code>PropertyChanged</code>事件的时候，我们需要给出变化的属性的名称；等等。</p>
<p>使用一个硬编码的字符串很简单，但是很容易出错。我们可能一不小心出现拼写错误，又或者当进行代码重构时这个字符串就会过期。<code>nameof</code>表达式本质上是一个字符串，由编译器检查你所给的参数并赋值，Visual Studio 知道它所引用的内容，所以导航和重构都能正确工作。<br><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(<span class="keyword">if</span> x == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> ArgumentNullException(nameof(x));</span><br></pre></td></tr></table></figure></p>
<p>你可以在<code>nameof</code>表达式传递更复杂的由点分割的参数，但这只是告诉编译器该看哪里：只有最后的标识符将被使用：<br><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">WriteLine(nameof(person.Address.ZipCode)); <span class="comment">// prints "ZipCode"</span></span><br></pre></td></tr></table></figure></p>
<h2 id="u7D22_u5F15_u5668_u5BF9_u8C61_u521D_u59CB_u5316"><a href="#u7D22_u5F15_u5668_u5BF9_u8C61_u521D_u59CB_u5316" class="headerlink" title="索引器对象初始化"></a>索引器对象初始化</h2><p>对象和集合初始化可用于声明性的初始化对象字段和属性、或者给一组集合元素初始化，但是字典对象或者带索引器的对象初始化时却不甚优雅。现在我们可以通过新的对象初始化语法来给索引器指定的键设置初值，如下所示：<br><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> numbers = <span class="keyword">new</span> Dictionary&lt;<span class="keyword">int</span>, <span class="keyword">string</span>&gt; </span><br><span class="line">&#123;</span><br><span class="line">    [<span class="number">7</span>] = <span class="string">"seven"</span>,</span><br><span class="line">    [<span class="number">9</span>] = <span class="string">"nine"</span>,</span><br><span class="line">    [<span class="number">13</span>] = <span class="string">"thirteen"</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h2 id="u5F02_u5E38_u8FC7_u6EE4_u5668"><a href="#u5F02_u5E38_u8FC7_u6EE4_u5668" class="headerlink" title="异常过滤器"></a>异常过滤器</h2><p><code>VB</code>中存在，<code>F#</code>中也存在，现在<code>C#</code>中也有了。它长的大概像这样：<br><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123; … &#125;</span><br><span class="line"><span class="keyword">catch</span> (MyException e) <span class="keyword">when</span> (myfilter(e))</span><br><span class="line">&#123;</span><br><span class="line">    …</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>如果括号表达式中的结果为<code>true</code>，那么将运行<code>catch</code>块，否则异常将被继续向上抛出。</p>
<p>异常过滤器比捕捉然后重新抛出异常的方式更好，因为异常过滤器不会破坏堆栈内容。如果一个异常最后会导致堆栈被清空，使用过滤器方式你可以看到异常的原始来源，而不是它最后被重新抛出的地方。</p>
<p>异常过滤器有一些被普遍认可的“滥用”，比如日志记录，而这会导致一些副作用。它们可以检查而不拦截异常，这样，这些过滤器通常会给出一个<code>false</code>返回值，这会产生一些副作用，比如异常块总是不被执行：<br><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">bool</span> <span class="title">Log</span>(<span class="params">Exception e</span>) </span>&#123; <span class="comment">/* log it */</span> ; <span class="keyword">return</span> <span class="keyword">false</span>; &#125;</span><br><span class="line">…</span><br><span class="line"><span class="keyword">try</span> &#123; … &#125; <span class="keyword">catch</span> (Exception e) <span class="keyword">when</span> (Log(e)) &#123;&#125;</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>不知道异常过滤器函数签名是不是被固定了，如果仅仅要求函数有一个bool返回值（以及一个<code>Exception</code>参数和其它可选参数），那么对于异常过滤器函数，我们可以通过传入更多的参数来决定返回值是<code>true</code>或者<code>false</code>，以此来控制异常处理块是否执行。</p>
</blockquote>
<h2 id="u5728catch_u548Cfinally_u5757_u4E2D_u4F7F_u7528await"><a href="#u5728catch_u548Cfinally_u5757_u4E2D_u4F7F_u7528await" class="headerlink" title="在catch和finally块中使用await"></a>在catch和finally块中使用await</h2><p>下面是微软原文的幽默：</p>
<blockquote>
<p><code>C# 5</code>中我们不允许在catch块和finally块中出现<code>await</code>关键字，因为我们设法让自己相信那是不可能实现的。但是现在我们弄懂了，显然这并不是不可能的。</p>
</blockquote>
<p>这实际上是一个很值得注意的限制，使得人们不得不用其它“丑陋的”解决方式。现在这个限制不在了：<br><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Resource res = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">try</span></span><br><span class="line">&#123;</span><br><span class="line">    res = <span class="keyword">await</span> Resource.OpenAsync(…);       <span class="comment">// You could do this.</span></span><br><span class="line">    …</span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">catch</span>(ResourceException e)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">await</span> Resource.LogAsync(res, e);         <span class="comment">// Now you can do this …</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">finally</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (res != <span class="keyword">null</span>) <span class="keyword">await</span> res.CloseAsync(); <span class="comment">// … and this.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>这个实现是相当复杂的，但是你不用去担心。这是这个语言中异步的重点。</p>
</blockquote>
<h2 id="u96C6_u5408_u521D_u59CB_u5316_u5668_u6269_u5C55_u65B9_u6CD5"><a href="#u96C6_u5408_u521D_u59CB_u5316_u5668_u6269_u5C55_u65B9_u6CD5" class="headerlink" title="集合初始化器扩展方法"></a>集合初始化器扩展方法</h2><blockquote>
<p>当我们在<code>C#</code>中首次实现集合初始化器的时候，<code>Add</code>方法不能作为扩展方法调用。<code>VB</code>从一开始就有了，但是看起来我们似乎忘了在<code>C#</code>中加入。现在这个问题解决了：集合初始化代码中可以很愉快的使用一个叫做<code>Add</code>的扩展方法。这不是一个大的特性，但是它偶尔很有用，而结果证明在新的编译器中实现它相当于删除一个阻止它的检查。</p>
</blockquote>
<h2 id="u6539_u8FDB_u7684_u91CD_u8F7D_u89E3_u6790"><a href="#u6539_u8FDB_u7684_u91CD_u8F7D_u89E3_u6790" class="headerlink" title="改进的重载解析"></a>改进的重载解析</h2><blockquote>
<p>在重载解析上有很多小的改进，这可能会使得很多事情会按照你所期望的方式工作。所有的改进都和“betterness”有关，所谓“betterness”，是编译器决定对于指定参数两个重载方法哪一个更合适的方法。</p>
<p>当在可空值类型重载方法之间选择时，你可能会注意到这点；另一点是在函数组（相对于Lambdas）中重载期望的委托。细节不值得在这里多说，只是想让你知道！</p>
</blockquote>
]]></content>
    <summary type="html">
    <![CDATA[<p>微软新一代开发工具<code>Visual Studio 2015</code>正式版已经于北京时间 2015年7月20日 23:30 发布了，而作为<code>.Net</code>开发中的主力开发语言<code>C#</code>，也已经走到了<code>C# 6</code>。</p>
<p>那么作为<code>C#</code>开发语言的最新版本，微软又给它添加或改进了哪些特性呢？</p>
<p><code>C# 6</code>的新特性是和微软的 .Net 开源编译器<a href="https://github.com/dotnet/roslyn">Roslyn</a>紧密相连的，在其 GitHub 页面中，也给出了<code>C# 6</code>新特性：<a href="https://github.com/dotnet/roslyn/wiki/New-Language-Features-in-C%23-6">New Language Features in C# 6</a>。下面内容一部分为简单的翻译，以及在查看时的一些理解和疑问，由于目前我还没发下载最新版 Win10 和 VS 2015，因此有些地方暂时还没发验证猜想。等待后续更新。</p>
<p>下面先列出<code>C# 6</code>中的新特性：</p>
<ul>
<li>自动属性初始值表达式<blockquote>
<p><code>public int X { get; set; } = x;</code></p>
</blockquote>
</li>
<li>只读自动属性<blockquote>
<p><code>public int Y { get; } = y;</code></p>
</blockquote>
</li>
<li><p>静态导入<code>using static</code></p>
<blockquote>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="keyword">using</span> <span class="keyword">static</span> System.Console;</span><br><span class="line">&gt; ...</span><br><span class="line">&gt; Write(<span class="number">4</span>);</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
</li>
<li><p>索引器对象初始化</p>
<blockquote>
<p><code>new JObject { [&quot;x&quot;] = 3 }</code></p>
</blockquote>
</li>
<li>在<code>catch</code>和<code>finally</code>块中使用<code>await</code><blockquote>
<p><code>try { ... } catch { await ... } finally { await ... }</code></p>
</blockquote>
</li>
<li>异常筛选器<blockquote>
<p><code>catch(Exception e) when (e.Count &gt; 5) { ... }</code></p>
</blockquote>
</li>
<li>函数/属性表达式<blockquote>
<p><code>public double Dist =&gt; Sqrt(X * X + Y * Y);</code></p>
</blockquote>
</li>
<li>Null条件运算符<blockquote>
<p><code>customer?.Orders?[5]</code></p>
</blockquote>
</li>
<li>字符串插值<blockquote>
<p><code>$&quot;{p.Name} is {p.Age} years old.&quot;</code></p>
</blockquote>
</li>
<li><code>nameof</code>运算符<blockquote>
<p><code>string s = nameof(Console.Write);</code></p>
</blockquote>
</li>
<li>其它改进<blockquote>
<ul>
<li>#pragma</li>
<li>集合初始化支持扩展方法<code>Add</code></li>
<li>重载方法解析改进</li>
</ul>
</blockquote>
</li>
</ul>]]>
    
    </summary>
    
      <category term="C#" scheme="http://3meng.github.io/tags/C/"/>
    
      <category term="随笔" scheme="http://3meng.github.io/categories/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[SQLite与“继承映射”]]></title>
    <link href="http://3meng.github.io/2015/07/16/SQLite-and-inheritance-mapping/"/>
    <id>http://3meng.github.io/2015/07/16/SQLite-and-inheritance-mapping/</id>
    <published>2015-07-16T15:02:19.000Z</published>
    <updated>2015-12-08T12:23:10.000Z</updated>
    <content type="html"><![CDATA[<h2 id="SQLite"><a href="#SQLite" class="headerlink" title="SQLite"></a>SQLite</h2><p>SQLite 的网站 (<a href="http://www.sqlite.org/" target="_blank" rel="external">sqlite.org</a>) 对SQL进行了如下描述：</p>
<blockquote>
<p>SQLite 是一个可实现独立、无服务器、零配置、事务性 SQL 数据库引擎的软件库。</p>
</blockquote>
<p>SQLite 完全驻留在客户端进程中，这使之成为一种<strong>嵌入式</strong>数据库。 在使用期间，SQLite 数据库的运行空间是一个存储在客户端文件系统的某一位置中的单个文件，并且安装空间通常也相当小。 </p>
<p>尽管如此，SQLite 数据库的功能却是极其丰富的，因为它支持大部分<em>SQL-92</em> 规范，只是去除了 RIGHT 和 FULL OUTER JOIN、ALTER TABLE、某一触发器支持、GRANT/REVOKE 以及写入 VIEW 等几项内容（更详细的说明请参见<a href="http://www.sqlite.org/" target="_blank" rel="external">SQLite 网站</a>）。令人印象深刻的是支持的功能数量，包括事务和各种数据类型。这使 SQLite 十分适合只需<strong>轻型 SQL</strong>的情形。 </p>
<p>有关更详细的 SQLite 体系结构和用法说明，还可以查看<a href="https://www.microsoft.com/china/msdn/x-platform/developing_17.html" target="_blank" rel="external">这里</a>。</p>
<a id="more"></a>
<h2 id="u7EE7_u627F_u6620_u5C04"><a href="#u7EE7_u627F_u6620_u5C04" class="headerlink" title="继承映射"></a>继承映射</h2><p>关系数据库中的表之间不存在继承关系，为了将面向对象中的继承关系映射到关系数据库中，可以使用以下三种继承映射策略：</p>
<ul>
<li><p>每个继承层次一张表</p>
<blockquote>
<p>描述一个继承关系只用一张表，也就是说子类所使用的表与父类相同。</p>
<p><strong>优点：</strong></p>
<ul>
<li>维护方便，在任何情况下都只需要处理一张表。</li>
<li>执行效率最高（无需外连接）。</li>
</ul>
<p><strong>缺点：</strong> </p>
<ul>
<li>需要在数据库中加入额外的区分子类的字段。</li>
<li>不允许对子类成员属性对应的字段定义<code>Not Null</code>约束。</li>
<li>灵活性差，表中冗余字段会随着子类的增加而越来越多。</li>
</ul>
</blockquote>
</li>
<li><p>每个具体类一张表</p>
<blockquote>
<p>每个具体类对应一张表，有多少具体类就需要建立多少个独立的表。每张表中包含了具体类的所有属性，包括从基类继承过来的属性。</p>
<p><strong>优点：</strong></p>
<ul>
<li>映射的灵活性大，可以对每个属性进行单独的配置（包括继承的属性）。</li>
<li>对于子类的查询只需要一张表。</li>
</ul>
<p><strong>缺点：</strong></p>
<ul>
<li>存在太多冗余字段。</li>
<li>如果需要对基类进行修改，则需要对基类及其所有子类都进行修改。</li>
</ul>
</blockquote>
</li>
<li><p>每个子类一张表</p>
<blockquote>
<p>每个子类使用一张表，但这些子类所对应的表都关联到基类所对应的表中。也就是子类对应的表中仅保存当前类中定义的属性，不包含父类的属性。</p>
<p><strong>优点：</strong></p>
<ul>
<li>不存在冗余。</li>
<li>可以对每个属性进行单独配置。</li>
<li>维护方便，对每个类的修改只需要修改其所对应的表。</li>
</ul>
<p><strong>缺点：</strong></p>
<ul>
<li>查询时需要进行连接，性能不如另外两个。</li>
</ul>
</blockquote>
</li>
</ul>
<p>有关<code>继承映射</code>的更多内容，可以自行搜索。</p>
<h2 id="SQLite_u5904_u7406"><a href="#SQLite_u5904_u7406" class="headerlink" title="SQLite处理"></a>SQLite处理</h2><p>对于<code>.Net</code>平台，有许多的SQLite帮助程序库，可以简化SQLite的操作。这里在<code>Windows Phone 8</code>平台上使用相应的帮助库来测试SQLite数据库。有关如何在<code>Windows Phone 8</code>中使用SQLite数据库，可以查看<code>sqlite-net-wp8</code>的<a href="https://github.com/peterhuene/sqlite-net-wp8" target="_blank" rel="external">说明</a>。</p>
<h3 id="u521B_u5EFA_u6570_u636E_u5E93_u8868"><a href="#u521B_u5EFA_u6570_u636E_u5E93_u8868" class="headerlink" title="创建数据库表"></a>创建数据库表</h3><p>要创建一个数据库表，我们需要定义相对应的实体类，并且使用对应的特性（<code>Attribute</code>）去修饰相应的类（<code>class</code>）和属性（<code>Property</code>）。如下是一个实体类定义：<br><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[Table(<span class="string">"base_data"</span>)]</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">BaseData</span></span><br><span class="line">&#123;</span><br><span class="line">    [PrimaryKey, AutoIncrement, Column(<span class="string">"id"</span>)]</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> ID &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line"></span><br><span class="line">    [Column(<span class="string">"name"</span>)]</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">string</span> Name &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line"></span><br><span class="line">    [Column(<span class="string">"key"</span>), NotNull]</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">string</span> Key &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="u7EE7_u627F_u6620_u5C04_uFF1F"><a href="#u7EE7_u627F_u6620_u5C04_uFF1F" class="headerlink" title="继承映射？"></a>继承映射？</h3><p>对于一个实体类，我们需要使用<code>TableAttribute</code>修饰，并传入表名称。而在查找的时候，同样需要传入要查找的表对应的实体类型，因此，我觉得SQLite-net在对继承映射处理时采用了一种更简单的实现：对于每个具体的实体类都对应一个表，在这张表中会包含有该类所有的（包括基类）具有<code>ColumnAttribute</code>特性的属性，但是SQLite-net并不提供在继承映射中最重要的一个特性：查询父类时同时返回所有符合条件的子类。</p>
<p>本来SQLite就是一个轻量级的数据库，因此SQLite-net在实现的时候，只是把我们定义的实体类作为一个类似参照的东西，所以对于<code>Table</code>的修饰也没有要求更多的与继承映射有关的字段。不过这样也好，毕竟一般当我们需要使用类似SQLite的数据库时，也不会有太多的要求，而SQLite-net这样的处理，一般并不会影响我们对数据的处理。</p>
<h3 id="u5206_u6790_-__u6E90_u4EE3_u7801"><a href="#u5206_u6790_-__u6E90_u4EE3_u7801" class="headerlink" title="分析 - 源代码"></a>分析 - 源代码</h3><p>为了验证SQLite-net对具有继承关系的实体类的处理方式，我们可以查看它的源代码。而与SQLite-net对类的处理方式直接相关联的就是那几个<code>Attribute</code>了，从<code>MSDN</code>中可以查到，对于一个<code>Attribute</code>特性，可以使用<code>AttributeUsageAttribute</code>类来指示其使用方法，该类的声明如下：<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">/// &lt;summary&gt;</span><br><span class="line">/// 指定另一特性类的用法。无法继承此类。</span><br><span class="line">/// &lt;/summary&gt;</span><br><span class="line">public sealed class AttributeUsageAttribute : System.Attribute</span><br><span class="line">&#123;</span><br><span class="line">    /// &lt;summary&gt;</span><br><span class="line">    /// 用指定的 &lt;see cref="System.AttributeTargets"/&gt;、</span><br><span class="line">    /// &lt;see cref="System.AttributeUsageAttribute.AllowMultiple"/&gt; 值和 </span><br><span class="line">    /// &lt;see cref="System.AttributeUsageAttribute.Inherited"/&gt; 值列表初始化</span><br><span class="line">    /// System.AttributeUsageAttribute 类的新实例。</span><br><span class="line">    /// &lt;/summary&gt;</span><br><span class="line">    /// &lt;param name="validOn"&gt; 使用按位 OR 运算符组合的一组值，用于指示哪些程序元素是有效的。&lt;/param&gt;</span><br><span class="line">    public AttributeUsageAttribute(System.AttributeTargets validOn);</span><br><span class="line"></span><br><span class="line">    /// &lt;summary&gt;</span><br><span class="line">    /// 获取一组值，这组值标识指示的特性可应用到的程序元素。</span><br><span class="line">    /// &lt;/summary&gt;</span><br><span class="line">    public System.AttributeTargets ValidOn &#123; get; private set; &#125;</span><br><span class="line"></span><br><span class="line">    /// &lt;summary&gt;</span><br><span class="line">    /// 获取或设置一个布尔值，该值指示能否为一个程序元素指定多个指示特性实例。</span><br><span class="line">    /// &lt;/summary&gt;</span><br><span class="line">    public bool AllowMultiple &#123; set; get; &#125;</span><br><span class="line"></span><br><span class="line">    /// &lt;summary&gt;</span><br><span class="line">    /// 获取或设置一个布尔值，该值指示指示的特性能否由派生类和重写成员继承。</span><br><span class="line">    /// &lt;/summary&gt;</span><br><span class="line">    public bool Inherited &#123; set; get; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>我们可以指定一个<code>Attribute</code>的使用范围（使用<code>AttributeTargets</code>枚举，例如类、属性、方法、参数等），还可以指定该特性能否在一个元素上重复使用（使用<code>AllowMultiple</code>属性），而最后一个<code>Inherited</code>属性则是我们关注的重点，该值指示这个特性能否被继承，也就是在基类的某个元素中定义的特性，在子类中是否有效，这个属性的默认值为<code>true</code>。</p>
<p>而在<code>SQLite.cs</code>文件中，我们可以找到<code>TableAttribute</code>、<code>ColumnAttribute</code>等的定义：<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[AttributeUsage(AttributeTargets.Class)]</span><br><span class="line">public class TableAttribute : System.Attribute &#123; ... &#125;</span><br><span class="line"></span><br><span class="line">[AttributeUsage(AttributeTargets.Property)]</span><br><span class="line">public class ColumnAttribute : System.Attribute &#123; ... &#125;</span><br></pre></td></tr></table></figure></p>
<p>从定义中可以看出，这些特性都可以被继承，因此对于一个子类来说，基类中的数据库表字段它也会拥有，这就简化了我们对实体类的定义，我们可以按照一般的对象抽象方式，为实体类创建相应的继承关系。例如我们可以把一些在所有的数据库表中都存在的字段移到一个公共基类中去定义，而且这样做，以后我们对数据库进行操作时，也可以利用面向对象的多态来进行处理。</p>
<h3 id="u5206_u6790_-__u8C03_u8BD5"><a href="#u5206_u6790_-__u8C03_u8BD5" class="headerlink" title="分析 - 调试"></a>分析 - 调试</h3><p>实验是检验真理的唯一标准。为了更明确的观察SQLite-net对继承的实体类的处理，我们可以构建相应的测试程序。</p>
<p>在这里，首先定义如下的测试数据库实体类：<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">public class Data</span><br><span class="line">&#123;</span><br><span class="line">    [PrimaryKey, AutoIncrement, Column("id")]</span><br><span class="line">    public int ID &#123; get; set; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">[Table("base_data")]</span><br><span class="line">public class BaseData : Data</span><br><span class="line">&#123;</span><br><span class="line">    [Column("name")]</span><br><span class="line">    public string Name &#123; get; set; &#125;</span><br><span class="line"></span><br><span class="line">    [Column("key_value")]</span><br><span class="line">    public string KeyValue &#123; get; set; &#125;</span><br><span class="line"></span><br><span class="line">    public override string ToString()</span><br><span class="line">    &#123;</span><br><span class="line">        return string.Format("ID: &#123;0&#125;; Name: &#123;1&#125;; KeyValue: &#123;2&#125;", ID, Name, KeyValue);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">[Table("child_data")]</span><br><span class="line">public class ChildData : BaseData</span><br><span class="line">&#123;</span><br><span class="line">    [Column("list")]</span><br><span class="line">    public string List &#123; get; set; &#125;</span><br><span class="line"></span><br><span class="line">    [Column("date")]</span><br><span class="line">    public DateTime? Date &#123; get; set; &#125;</span><br><span class="line"></span><br><span class="line">    [Column("bool_null")]</span><br><span class="line">    public bool? BoolNull &#123; get; set; &#125;</span><br><span class="line"></span><br><span class="line">    public override string ToString()</span><br><span class="line">    &#123;</span><br><span class="line">        return string.Format("&#123;0&#125;\nList: &#123;1&#125;; Date:&#123;2&#125;; Bool: &#123;3&#125;", </span><br><span class="line">            base.ToString(), List, Date, BoolNull);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>然后再应用中创建数据库并向两个表中填充一些数据。之后在进行查询操作，通过<code>select * from table</code>列出数据库表中的所有数据，从查询结果可以看出，对于基类<code>BaseData</code>所对应的数据库表的查询并不会返回其子类所对应的表中的数据。</p>
<h2 id="u7ED3_u8BBA"><a href="#u7ED3_u8BBA" class="headerlink" title="结论"></a>结论</h2><p>SQLite-net并没有完整的实现一种继承映射，但是依靠<code>.Net</code>中的<code>Attribute</code>，使得我们在为数据库创建实体类的时候，完全可以按照一般的分析分析方法，而对数据库的操作，在SQLite-net中也是反映到对类的操作上，因此我们也可以完全的利用面向对象中的各种特性，例如多态。</p>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="SQLite"><a href="#SQLite" class="headerlink" title="SQLite"></a>SQLite</h2><p>SQLite 的网站 (<a href="http://www.sqlite.org/">sqlite.org</a>) 对SQL进行了如下描述：</p>
<blockquote>
<p>SQLite 是一个可实现独立、无服务器、零配置、事务性 SQL 数据库引擎的软件库。</p>
</blockquote>
<p>SQLite 完全驻留在客户端进程中，这使之成为一种<strong>嵌入式</strong>数据库。 在使用期间，SQLite 数据库的运行空间是一个存储在客户端文件系统的某一位置中的单个文件，并且安装空间通常也相当小。 </p>
<p>尽管如此，SQLite 数据库的功能却是极其丰富的，因为它支持大部分<em>SQL-92</em> 规范，只是去除了 RIGHT 和 FULL OUTER JOIN、ALTER TABLE、某一触发器支持、GRANT/REVOKE 以及写入 VIEW 等几项内容（更详细的说明请参见<a href="http://www.sqlite.org/">SQLite 网站</a>）。令人印象深刻的是支持的功能数量，包括事务和各种数据类型。这使 SQLite 十分适合只需<strong>轻型 SQL</strong>的情形。 </p>
<p>有关更详细的 SQLite 体系结构和用法说明，还可以查看<a href="https://www.microsoft.com/china/msdn/x-platform/developing_17.html">这里</a>。</p>]]>
    
    </summary>
    
      <category term="SQLite" scheme="http://3meng.github.io/tags/SQLite/"/>
    
      <category term="继承映射" scheme="http://3meng.github.io/tags/%E7%BB%A7%E6%89%BF%E6%98%A0%E5%B0%84/"/>
    
      <category term="数据库" scheme="http://3meng.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[从CHK文件中恢复数据]]></title>
    <link href="http://3meng.github.io/2015/06/11/recovery-data-from-chk-file/"/>
    <id>http://3meng.github.io/2015/06/11/recovery-data-from-chk-file/</id>
    <published>2015-06-11T15:21:29.000Z</published>
    <updated>2015-12-08T12:21:24.000Z</updated>
    <content type="html"><![CDATA[<p>在使用电脑的过程中，总会遇到各种各样的故障，导致电脑非正常关机，或者由于其它的原因，最终使得磁盘某些文件（夹）存储出现错误。一般表现为文件夹无法访问，或者是在资源管理器中看不到对应文件或文件夹（而实际上这些文件还是可访问），这时候我们就需要想办法将这些数据恢复到正常状态或者从磁盘中删除了，因为虽然你无法通过资源管理器或者一般应用去访问这些数据，但是它们其实还是被存储在磁盘中某一个区域，仍然占据着磁盘空间。<br><a id="more"></a></p>
<h2 id="u8D77_u56E0"><a href="#u8D77_u56E0" class="headerlink" title="起因"></a>起因</h2><p>前一阵子电脑偶尔出现开机黑屏或者运行时死机的现象，没办法，都是直接长按电源键直接关机了（这里顺便提一下，如果你在碰倒电脑无反应需要强制关机的时候，建议等一等，看一看这个时候硬盘灯是不是亮着，如果亮着，请尽量等待它熄了之后在强关。当然，如果没有硬盘指示灯的就没办法了，可以试着听一下声音看硬盘是否正在被访问），而就在不久前一次开机，就突然发现一个绿色小软件打不开了，提示无法找到路径（桌面快捷方式打开的），于是进资源管理器一看，文件夹还在，但是双击就提示“文件或目录已损坏且无法读取，请运行chkdsk工具修复”，对该文件夹也无法进行任何操作，包括改名删除等。</p>
<p>于是上网搜了一下，大概就是说磁盘文件目录出错，按照提示用<code>chkdsk</code>命令修复就行了。那么首先就是用管理员权限运行命令提示符（<code>cmd</code>），然后可以输入<code>chkdsk /?</code>来查看这个命令的帮助以及参数：<br><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">Microsoft Windows [版本 <span class="number">6</span>.<span class="number">3</span>.<span class="number">9600</span>]</span><br><span class="line">(c) <span class="number">2013</span> Microsoft Corporation。保留所有权利。</span><br><span class="line"><span class="function"></span><br><span class="line">C:\<span class="title">Windows</span>\<span class="title">system32</span>&gt;<span class="title">chkdsk</span> /?</span><br><span class="line">检查磁盘并显示状态报告。</span><br><span class="line"></span><br><span class="line"><span class="title">CHKDSK</span> [<span class="title">volume</span>[[<span class="title">path</span>]<span class="title">filename</span>]]] [/<span class="title">F</span>] [/<span class="title">V</span>] [/<span class="title">R</span>] [/<span class="title">X</span>] [/<span class="title">I</span>] [/<span class="title">C</span>] [/<span class="title">L</span>[:<span class="title">size</span>]] [/<span class="title">B</span>] [/<span class="title">scan</span>] [/<span class="title">spotfix</span>]</span><br><span class="line"></span><br><span class="line">  <span class="title">volume</span>          指定驱动器号(后面跟一个冒号)、</span><br><span class="line">                  装入点或卷名。</span><br><span class="line">  <span class="title">filename</span>        仅 <span class="title">FAT</span>/<span class="title">FAT32</span>: 指定要检查</span><br><span class="line">                  碎片的文件。</span><br><span class="line">  /<span class="title">F</span>              修复磁盘上的错误。</span><br><span class="line">  /<span class="title">R</span>              查找坏扇区并恢复可读信息</span><br><span class="line">                  (未指定 /<span class="title">scan</span> 时，隐含 /<span class="title">F</span>)。</span><br><span class="line">  /<span class="title">X</span>              如果必要，则先强制卸除卷。</span><br><span class="line">                  该卷的所有打开的句柄都将无效</span><br><span class="line">                  (隐含 /<span class="title">F</span>)。</span><br><span class="line">  /<span class="title">scan</span>           仅 <span class="title">NTFS</span>: 在卷上运行联机扫描</span><br><span class="line">  /<span class="title">offlinescanandfix</span>  在卷上运行脱机扫描并进行修复。</span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line">/<span class="title">I</span> 或 /<span class="title">C</span> 开关通过跳过对卷的某些检查，</span><br><span class="line">来减少运行 <span class="title">Chkdsk</span> 所需的时间长度。</span></span><br></pre></td></tr></table></figure></p>
<p>因为我的受损的文件存储在D盘，所以直接输入<code>chkdsk D: /R</code>，这是如果被检查的盘上有文件正在被使用，就会提示是否强制卸载该卷（y/n），一般选择n，然后就会提示是否创建计划任务，在下次开机时运行检查，这时可以选择是，然后重启就会开始进行检查。</p>
<p>当重启进入系统后，可以发现损坏的目录已经消失了，然后我就去重新下载了那个软件，放到原来的路径下，就继续开始使用了。本以为一切就此结束，但是今天却在用另外一个软件（也是在D盘）的时候发现了问题。</p>
<h2 id="CHK_u6587_u4EF6"><a href="#CHK_u6587_u4EF6" class="headerlink" title="CHK文件"></a>CHK文件</h2><p>由于突然想来亲自验证一下C++中<code>static</code>成员变量的初始化顺序，以便确定前几天所想的适用于多线程环境中的单实例类是否能正确运行，于是从桌面快捷方式直接启动<em>CodeBlocks</em>，结果进入之后右下角提示在指定的位置找不到编译器。</p>
<p>于是在桌面右键程序图标查看快捷方式属性，结果突然提示快捷方式起始位置不存在，然后就发现快捷方式中<strong>目标</strong>属性指向了地址<code>D:\found.000\dir0000.chk\codeblocks.exe</code>，而<strong>起始位置</strong>属性则是指向了<code>D:\Program Files(x86)\Codeblocks</code>；于是进入资源管理器，D盘根目录下找不到<em>found.000</em>文件夹，而<em>Program Files(x86)</em>目录下也没有<em>CodeBlocks</em>文件夹…没办法，只有从任务管理器进入进程所在目录了，结果提示文件夹无法访问，在地址栏输入路径也是一样的结果。</p>
<p>但是明明通过快捷方式是可以打开程序的，这说明程序文件夹依然完好无损，而且在<em>CodeBlocks</em>编译器设置中通过点击自动设置编译器所在目录，编译器也可以正常启动运行了，此时在设置中可以看到设置的编译器位置为<code>D:\found.000\dir0000.chk\MinGW\bin</code>，也说明这个路径是存在的，只是我们需要一些特殊的方法进去了。</p>
<p>首先在网上搜索了一下CHK文件，结果显示这是Windows磁盘修复时创建的文件，描述为“恢复的文件碎片”，也就是当Windows进行磁盘修复时检测到出现错误的文件或文件夹，会在当前磁盘根目录下创建<em>found.000</em>、<em>found.001</em>等文件夹保存这些恢复的文件，所以通过将这个文件夹中的东西恢复，就可以找回丢失的数据了，当然，不一定全部且正确。</p>
<h2 id="u6062_u590D_u6587_u4EF6"><a href="#u6062_u590D_u6587_u4EF6" class="headerlink" title="恢复文件"></a>恢复文件</h2><p>那么接下来依然是<code>CMD</code>了，使用管理员权限启动，尝试通过<code>cd</code>命令进入<em>found.000</em>文件夹，居然成功了，那么看起来似乎可行。然后通过<code>dir</code>命令查看这个文件夹下面的所有文件和文件夹信息，结果没有看到<em>dir0000.chk</em>目录，于是查看<code>dir</code>命令帮助：<br><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">Microsoft Windows [版本 <span class="number">6</span>.<span class="number">3</span>.<span class="number">9600</span>]</span><br><span class="line">(c) <span class="number">2013</span> Microsoft Corporation。保留所有权利。</span><br><span class="line"><span class="function"></span><br><span class="line">C:\<span class="title">Windows</span>\<span class="title">system32</span>&gt;<span class="title">dir</span> /?</span><br><span class="line">显示目录中的文件和子目录列表。</span><br><span class="line"></span><br><span class="line"><span class="title">DIR</span> [<span class="title">drive</span>:][<span class="title">path</span>][<span class="title">filename</span>] [/<span class="title">A</span>[[:]<span class="title">attributes</span>]] [/<span class="title">B</span>] [/<span class="title">C</span>] [/<span class="title">D</span>] [/<span class="title">L</span>] [/<span class="title">N</span>]</span><br><span class="line">  [/<span class="title">O</span>[[:]<span class="title">sortorder</span>]] [/<span class="title">P</span>] [/<span class="title">Q</span>] [/<span class="title">R</span>] [/<span class="title">S</span>] [/<span class="title">T</span>[[:]<span class="title">timefield</span>]] [/<span class="title">W</span>] [/<span class="title">X</span>] [/4]</span><br><span class="line"></span><br><span class="line">  [<span class="title">drive</span>:][<span class="title">path</span>][<span class="title">filename</span>]</span><br><span class="line">              指定要列出的驱动器、目录和/或文件。</span><br><span class="line"></span><br><span class="line">  /<span class="title">A</span>          显示具有指定属性的文件。</span><br><span class="line">  属性         <span class="title">D</span>  目录                <span class="title">R</span>  只读文件</span><br><span class="line">               <span class="title">H</span>  隐藏文件            <span class="title">A</span>  准备存档的文件</span><br><span class="line">               <span class="title">S</span>  系统文件            <span class="title">I</span>  无内容索引文件</span><br><span class="line">               <span class="title">L</span>  解析点             -  表示“否”的前缀</span><br><span class="line">  /<span class="title">S</span>          显示指定目录和所有子目录中的文件。</span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line">可以在 <span class="title">DIRCMD</span> 环境变量中预先设定开关。通过添加前缀 - (破折号)</span><br><span class="line">来替代预先设定的开关。例如，/-<span class="title">W</span>。</span></span><br></pre></td></tr></table></figure></p>
<p>于是使用<code>dir . /A:H</code>，<em>dir0000.chk</em>目录就可以看到了，当然即使看不到我们也可以使用<code>cd dir0000.chk</code>命令直接进入，这里之所以显示全部文件，是为了看看到底有多少CHK文件。那么接下来就该想办法把文件夹从这里面原样复制出去了，毕竟我们通过资源管理器没办法访问到这里，由于这是一个目录，那么就不能通过<code>copy</code>命令了，这里我们使用<code>copy</code>命令的增强版<code>xcopy</code>命令：<br><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">Microsoft Windows [版本 <span class="number">6</span>.<span class="number">3</span>.<span class="number">9600</span>]</span><br><span class="line">(c) <span class="number">2013</span> Microsoft Corporation。保留所有权利。</span><br><span class="line"><span class="function"></span><br><span class="line">C:\<span class="title">Windows</span>\<span class="title">system32</span>&gt;<span class="title">xcopy</span> /?</span><br><span class="line">复制文件和目录树。</span><br><span class="line"></span><br><span class="line"><span class="title">XCOPY</span> <span class="title">source</span> [<span class="title">destination</span>] [/<span class="title">A</span> | /<span class="title">M</span>] [/<span class="title">D</span>[:<span class="title">date</span>]] [/<span class="title">P</span>] [/<span class="title">S</span> [/<span class="title">E</span>]] [/<span class="title">V</span>] [/<span class="title">W</span>]</span><br><span class="line">                           [/<span class="title">C</span>] [/<span class="title">I</span>] [/<span class="title">Q</span>] [/<span class="title">F</span>] [/<span class="title">L</span>] [/<span class="title">G</span>] [/<span class="title">H</span>] [/<span class="title">R</span>] [/<span class="title">T</span>] [/<span class="title">U</span>]</span><br><span class="line">                           [/<span class="title">K</span>] [/<span class="title">N</span>] [/<span class="title">O</span>] [/<span class="title">X</span>] [/<span class="title">Y</span>] [/-<span class="title">Y</span>] [/<span class="title">Z</span>] [/<span class="title">B</span>] [/<span class="title">J</span>]</span><br><span class="line">                           [/<span class="title">EXCLUDE:file1</span>[+<span class="title">file2</span>][+<span class="title">file3</span>]...]</span><br><span class="line"></span><br><span class="line">  <span class="title">source</span>       指定要复制的文件。</span><br><span class="line">  <span class="title">destination</span>  指定新文件的位置和/或名称。</span><br><span class="line">  /<span class="title">S</span>           复制目录和子目录，不包括空目录。</span><br><span class="line">  /<span class="title">E</span>           复制目录和子目录，包括空目录。</span><br><span class="line">               与 /<span class="title">S</span> /<span class="title">E</span> 相同。可以用来修改 /<span class="title">T</span>。</span><br><span class="line">  /<span class="title">C</span>           即使有错误，也继续复制。</span><br><span class="line">  /<span class="title">G</span>           允许将加密文件复制到</span><br><span class="line">               不支持加密的目标。</span><br><span class="line">  /<span class="title">H</span>           也复制隐藏文件和系统文件。</span><br><span class="line">  /<span class="title">K</span>           复制属性。一般的 <span class="title">Xcopy</span> 会重置只读属性。</span><br><span class="line">  /<span class="title">O</span>           复制文件所有权和 <span class="title">ACL</span> 信息。</span><br><span class="line">  /<span class="title">X</span>           复制文件审核设置(隐含 /<span class="title">O</span>)。</span><br><span class="line">  /<span class="title">J</span>           复制时不使用缓冲的 <span class="title">I</span>/<span class="title">O</span>。推荐复制大文件时使用。</span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line">开关 /<span class="title">Y</span> 可以预先在 <span class="title">COPYCMD</span> 环境变量中设置。</span><br><span class="line">这可能被命令行上的 /-<span class="title">Y</span> 覆盖。</span></span><br></pre></td></tr></table></figure></p>
<p>在这里，最好将目录中的所有文件和目录结构都复制出去，而且能保持文件属性是最好的，因此在<em>D:\found.000</em>目录下执行命令<code>xcopy dir0000.chk E:\temp /H /K</code>尝试复制所有文件及目录，其中<em>E:\temp</em>是选择的临时存放位置；复制完成后，经过测试，文件没有损坏，可以正常运行，于是删除<em>D:\found.000\dir0000.chk</em>文件夹，执行<code>rd</code>命令即可：<br><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Microsoft Windows [版本 <span class="number">6</span>.<span class="number">3</span>.<span class="number">9600</span>]</span><br><span class="line">(c) <span class="number">2013</span> Microsoft Corporation。保留所有权利。</span><br><span class="line"><span class="function"></span><br><span class="line">C:\<span class="title">Windows</span>\<span class="title">system32</span>&gt;<span class="title">rd</span> /?</span><br><span class="line">删除一个目录。</span><br><span class="line"></span><br><span class="line"><span class="title">RMDIR</span> [/<span class="title">S</span>] [/<span class="title">Q</span>] [<span class="title">drive</span>:]<span class="title">path</span></span><br><span class="line"><span class="title">RD</span> [/<span class="title">S</span>] [/<span class="title">Q</span>] [<span class="title">drive</span>:]<span class="title">path</span></span><br><span class="line"></span><br><span class="line">    /<span class="title">S</span>      除目录本身外，还将删除指定目录下的所有子目录和</span><br><span class="line">            文件。用于删除目录树。</span><br><span class="line"></span><br><span class="line">    /<span class="title">Q</span>      安静模式，带 /<span class="title">S</span> 删除目录树时不要求确认</span></span><br></pre></td></tr></table></figure></p>
<p>在目录<em>D:\found.000</em> 下输入<code>rd dir0000.chk /s</code>即可。</p>
<h2 id="u5176_u5B83"><a href="#u5176_u5B83" class="headerlink" title="其它"></a>其它</h2><p>当然，在<code>found.000</code>目录中不一定只有一个文件夹或文件（这里如果丢失的文件属于目录，那么会被命名为<code>dir0000.chk</code>、<code>dir0001.chk</code>…如果不是目录，那么会被命名为<code>file0000.chk</code>、<code>file0001.chk</code>…），具体情况视磁盘错误情况而定，而一般情况下我们可以按照上面的步骤配合使用<code>dir</code>、<code>cd</code>、<code>xcopy</code>等命令将文件夹恢复，然后根据文件夹内容来确定这个文件夹的本来名称；但是对于文件则比较麻烦，如果不是比较重要的文件，或者文件数目不多且大概可以确定文件类型，也可以按照上面的方法，只是最后使用<code>copy</code>命令复制文件即可，但是复制出来的文件是<em>.CHK</em>类型，所以需要手动修改回本来的扩展名，这里也可以借助网上的一些工具来判断文件类型并自动修改。</p>
<p>当文件都恢复之后，便可以删除<code>found.xxx</code>文件夹了。</p>
<p>最后，如果你想在资源管理器中浏览查看有无类似<code>found.000</code>文件夹，可以进入文件夹选项中取消“隐藏受保护的操作系统文件”选项前的对勾。</p>
<h2 id="u9644"><a href="#u9644" class="headerlink" title="附"></a>附</h2><p>上面所说的恢复方式仅仅针对CHK文件而言，也就是你丢失的文件被Windows磁盘修复工具找回来了；但是这些修复工具不是万能的，并不是每次由于磁盘错误造成的文件丢失都能完整的被找回来。至于如果是由于其它情况或者误删文件，那么建议寻找一些<strong>专业的恢复工具</strong>来找回数据（尽量不要用某些非专业数据恢复工具来和丢失的数据开玩笑），并且在数据恢复之前也尽可能的不往数据所在磁盘中写入数据。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>在使用电脑的过程中，总会遇到各种各样的故障，导致电脑非正常关机，或者由于其它的原因，最终使得磁盘某些文件（夹）存储出现错误。一般表现为文件夹无法访问，或者是在资源管理器中看不到对应文件或文件夹（而实际上这些文件还是可访问），这时候我们就需要想办法将这些数据恢复到正常状态或者从磁盘中删除了，因为虽然你无法通过资源管理器或者一般应用去访问这些数据，但是它们其实还是被存储在磁盘中某一个区域，仍然占据着磁盘空间。<br>]]>
    
    </summary>
    
      <category term="CHK文件" scheme="http://3meng.github.io/tags/CHK%E6%96%87%E4%BB%B6/"/>
    
      <category term="数据恢复" scheme="http://3meng.github.io/tags/%E6%95%B0%E6%8D%AE%E6%81%A2%E5%A4%8D/"/>
    
      <category term="随笔" scheme="http://3meng.github.io/categories/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Windows Sockets：多线程WEB服务器]]></title>
    <link href="http://3meng.github.io/2015/06/10/Windows-Sockets/"/>
    <id>http://3meng.github.io/2015/06/10/Windows-Sockets/</id>
    <published>2015-06-09T16:32:10.000Z</published>
    <updated>2015-12-08T12:22:42.000Z</updated>
    <content type="html"><![CDATA[<p>平时如果一个项目需要网络连接，一般都是直接用如<code>C#</code>、<code>Java</code>等高级语言直接调用相关的函数去实现功能，甚至从未关注过在底层这些函数是怎么运作的；而截至不久前，也只是用<code>C#</code>中的Socket相关类做过一点有关长连接的事情。</p>
<p>而最近，恰好由于网络课程实验要求，使用<code>Windows Sockets API</code> + <code>C/C++</code>来实现一个简单的多线程Web服务器，于是开始一边摸索，一边实现功能。在这个实验中，不仅仅是简单的<code>Windows Socket</code>函数调用，其实主要的工作还在于多线程（包括GUI线程）之间的通信，对于HTTP请求，也只是简单的实现了<code>GET</code>方法。</p>
<h2 id="u5B9E_u9A8C_u8981_u6C42"><a href="#u5B9E_u9A8C_u8981_u6C42" class="headerlink" title="实验要求"></a>实验要求</h2><ol>
<li>可配置IP地址、监听端口和主目录</li>
<li>能够在监听端口上进行监听</li>
<li>支持服务的启动</li>
<li>支持服务的关闭</li>
<li>能够响应客户端的请求，并定位相应的html文件</li>
<li>对每个请求能够创建单独的响应线程</li>
<li>能够发送可被客户端解析的响应报文</li>
<li>对于错误的请求能够定位错误的原因并给出相应的响应</li>
<li>支持多种类型文件的输出</li>
<li>具备图形GUI界面<a id="more"></a>
</li>
</ol>
<h2 id="u5F00_u59CB"><a href="#u5F00_u59CB" class="headerlink" title="开始"></a>开始</h2><p>在介绍主要流程之前，先说一些完成实验之后的体会，或者说学到的东西吧。首先是在调试时，启动服务器后需要绑定IP地址和端口，这里IP地址只能是<code>127.0.0.1</code>或者<code>0.0.0.0</code>，据说也可以是你的网卡IP地址，但是我没有测试成功；而端口号必须大于<strong>1024</strong>，否则虽然绑定地址时虽然不会发生错误，但是也无法监听客户端请求。</p>
<p>其次，为了及时响应GUI界面的操作，需要使用异步I/O模式，因此需要将Socket操作设置为非阻塞模式，这时在Socket上的各种操作就需要自己去干涉了；虽然这看起来更复杂，但是也可以更好的认识Socket。</p>
<p>第三，要注意线程之间的通信，特别是传递引用类型时，更需要注意局部变量的陷阱。因为我们是要在另一个线程中访问数据，所以需要保证在另一个线程结束之前，传递的数据是有效的，通常可以采用静态变量/全局变量、动态分配内存等方式来实现，但是在这里，由于需要确保线程函数是线程安全的，也就是可重入的，因此不宜采用静态变量方式，所以将需要传递的数据保存在堆中，只是最后需要记得手动释放这块内存。</p>
<p>最后说一句，无论什么时候，要记得及时释放资源，如果你的代码中有未释放的资源，特别是内核资源，请不要急着调试或运行程序，虽然一般调试器都会在程序运行结束之后释放其占用的资源，但是万一出现某些内核对象没有释放的情况，也许下一次再运行你的程序时会出现本不该出现的错误。当然，重启是一个办法。</p>
<h3 id="u5F00_u53D1_u73AF_u5883"><a href="#u5F00_u53D1_u73AF_u5883" class="headerlink" title="开发环境"></a>开发环境</h3><p>由于要求有图形化界面，所以使用 <a href="http://www.qt.io/" target="_blank" rel="external">Qt</a> 进行快速开发，其中核心类是完全用<strong><em>Windows API</em></strong>实现，通过预留的接口与Qt界面进行交互。</p>
<blockquote>
<p>由于安装的Qt版本是<em>MSVC2013</em> 版的，所以安装完成后Qt无法自动设置调试器，因此无法在Qt中进行调试（如果希望在Qt中调试，需要单独下载<a href="https://msdn.microsoft.com/zh-cn/windows/hardware/hh852365" target="_blank" rel="external">WinDbg工具</a>，并在Qt中进行配置），前期还好，通过在关键处打印的方式，即使不用调试器也能找到错误并修正，但是到后来，需要调试多线程以及指针等，仅仅凭借简单的打印方式效率太低了，所以又去Qt官网下载了<a href="http://download.qt.io/official_releases/vsaddin/" target="_blank" rel="external">Qt-VS-Addin</a>，这是一个适用于<em>Visual Studio</em> 的Qt插件，安装之后，就可以在VS中编写和调试Qt项目了，而相比Qt，我更喜欢用VS调试。</p>
</blockquote>
<h2 id="Socket_u6838_u5FC3_u7C7B_u5206_u6790"><a href="#Socket_u6838_u5FC3_u7C7B_u5206_u6790" class="headerlink" title="Socket核心类分析"></a>Socket核心类分析</h2><p>在编写Socket核心类之前，首先需要想好要预留那些接口与GUI进行交互，毕竟虽然实际上这个核心类和GUI类是在同一个项目工程中，但是为了让核心类的可移植性更高，或者说将UI和底层操作隔离开来，我们应该设计好Socket类的通信方式，这样，在完成Socket类时可以不用考虑UI操作，而在UI设计过程中也无需深入探究Socket实现方式。</p>
<blockquote>
<p>在这里，根据实验的要求，图形化界面应该提供启动、停止服务的操作，而且还要能设置一些基本参数，因此在<em>Socket</em> 类中，应该提供一个启动和停止监听的接口，而为了简单考虑，我们将在UI界面设定的一些基本配置参数通过启动接口传递到<em>Socket</em> 类中，而不是要求在初始化<em>Socket</em> 类时传入，这样在GUI类中就可以将<em>Socket</em> 类的初始化和启动操作放到不同的方法中，而且通过重新调用启动方法就可以实现监听新的端口，而不用去构造一个新的<em>Socket</em> 类。此外，为了让UI界面知道当前监听的状态（是否正在监听端口），还需要在<em>Socket</em> 类中提供一个只读属性方法。</p>
</blockquote>
<p>这里，Socket核心类被命名为<strong><em>SocketUnits</em></strong>。</p>
<h3 id="u516C_u5F00_u65B9_u6CD5"><a href="#u516C_u5F00_u65B9_u6CD5" class="headerlink" title="公开方法"></a>公开方法</h3><p>Socket核心类定义的公开方法如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Start</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span> &amp;ip, <span class="keyword">unsigned</span> <span class="keyword">short</span> port, <span class="keyword">const</span> wstring &amp;baseDir)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Stop</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">GetIsListening</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    DWORD extCode = <span class="number">0</span>;</span><br><span class="line">    GetExitCodeThread(_lastThread, &amp;extCode);</span><br><span class="line">    <span class="keyword">return</span> extCode == STILL_ACTIVE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>其中<code>GetIsListening</code>用于获取监听状态，此处作为内联函数存在。_lastThread保存了监听线程的句柄，如果还没有创建监听线程，则<code>_lastThread = INVALID_HANDLE_VALUE</code>。</p>
<h3 id="u56DE_u8C03_u63A5_u53E3"><a href="#u56DE_u8C03_u63A5_u53E3" class="headerlink" title="回调接口"></a>回调接口</h3><p>上面是外部与Socket类通信的主要接口，由外部方法调用，设置Socket的属性，但却无法获取Socket类的当前状态，因为采用了异步Socket实现，所以如果还是像上面一样单纯的提供接口，让调用者使用轮询的方式查询Socket状态，那么不仅让调用类的实现难度增加，同时也会无端的消耗CPU时间片。因此这里采用了一种类似Windows消息事件的回调机制，利用纯虚类定义回调接口，当Socket类满足某一状态时会自动调用回调接口中定义的对应方法。</p>
<blockquote>
<p>回调接口中需要哪些方法，这个我们也要根据实际情况来决定，在这里，我们暂时只需将一些基本状态传递给UI即可。首先是服务的启动和关闭信息，虽然提供了公开的启动和关闭方法，但是由于在该方法内部是需要创建新的线程来进行<em>Socket</em> 的监听工作，因此，当启动方法（<em>SocketUnits::Start</em> 函数）返回时，并不意味着监听<em>Socket</em> 创建成功，所以我们需要在监听线程中来告诉调用者服务是否启动；同理，关闭时也需要在监听线程中实现。其次，对于每一个来自客户端的连接<em>Socket</em>，我们也需要向外通知这个连接的状态，包括建立连接、关闭连接，此外为了方便查看连接信息，将与客户端的具体请求和响应消息也发送出去。最后，还需要一个出现错误时的回调接口，方便调用者在出错时及时作出反应。</p>
</blockquote>
<p>回调接口<strong><em>ISocketEvent</em></strong> 定义如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> ISocketEvent</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">OnListenSocketChanged</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *ip, <span class="keyword">unsigned</span> <span class="keyword">short</span> port, </span><br><span class="line">        <span class="keyword">const</span> wchar_t *dir)</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="comment">/* stopCode：结束状态码 */</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">OnServiceStopped</span><span class="params">(<span class="keyword">int</span> stopCode)</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">OnSocketConnected</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *ip)</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">OnSocketFinished</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *ip)</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="comment">/* isSend：指示是发送还是接收数据。 info：发送或接收的数据 */</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">OnNewLogs</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *ip, <span class="keyword">const</span> <span class="keyword">char</span> *info, <span class="keyword">bool</span> isSend)</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="comment">/* eor：错误代码。 msg：错误说明 */</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">OnError</span><span class="params">(<span class="keyword">int</span> eor, <span class="keyword">const</span> <span class="keyword">char</span> *msg)</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>这里的形参<code>ip</code>是字符串形式的点分十进制IP地址。<code>OnListenSocketChanged</code>函数的形参含义依次为IP地址、监听端口号、主目录。</p>
<p><strong><em>ISocketEvent</em></strong> 类中各方法解释：</p>
<blockquote>
<ul>
<li><em>OnListenSocketChanged</em>：当监听Socket配置发生变化时（包括启动）调用</li>
<li><em>OnServiceStopped</em>：当监听Socket关闭时调用</li>
<li><em>OnSocketConnected</em>：当有来自客户端的Socket请求时调用</li>
<li><em>OnSocketFinished</em>：当与客户端的Socket连接关闭时调用</li>
<li><em>OnNewLogs</em>：当与客户端进行数据传递（发送或者接收）时调用</li>
<li><em>OnError</em>：当Socket连接出现错误时调用</li>
</ul>
</blockquote>
<h3 id="u7EBF_u7A0B_u51FD_u6570_u5B9A_u4E49"><a href="#u7EBF_u7A0B_u51FD_u6570_u5B9A_u4E49" class="headerlink" title="线程函数定义"></a>线程函数定义</h3><p>前面的都是为实现Socket类与外部通信和发送数据所定义的方法，而实现一个多线程WEB服务器最核心的部分则是此处要说的，线程以及Socket的处理。我们需要将监听Socket和响应Socket都放在单独的线程中进行处理，因此需要定义两个线程函数，分别用于处理监听操作和响应操作。在C++中，如果一个线程函数是类的成员，那么它必须被定义为<code>static</code>的，这里涉及到一个<code>this</code>指针的问题。</p>
<p>因此，按照线程函数的格式定义如下两个函数：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> DWORD WINAPI <span class="title">ListenThread</span><span class="params">(LPVOID lpParameter)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">static</span> DWORD WINAPI <span class="title">WorkerThread</span><span class="params">(LPVOID lpParameter)</span></span>;</span><br></pre></td></tr></table></figure></p>
<p>形参<code>lpParameter</code>是一个<code>void *</code>型的指针，它的值在创建线程时通过线程创建方法传入。返回值会作为线程的退出值，可以由方法<code>bool GetExitCodeThread(HANDLE, LPDWORD)</code>获取。</p>
<p>此外，还定义了两个静态方法，以便在线程函数中调用，完成相应的功能：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">GetType</span><span class="params">(<span class="keyword">const</span> wstring &amp;fileName, <span class="built_in">string</span> &amp;type)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">bool</span> <span class="title">SignalSend</span><span class="params">(SOCKET s, <span class="keyword">const</span> <span class="keyword">char</span> *buf, size_t len, <span class="keyword">bool</span> *stop)</span></span>;</span><br></pre></td></tr></table></figure></p>
<p><code>GetType</code>函数用于获取指定文件（文件名由<code>fileName</code>指示）的类型，在这里，仅仅对一些WEB中常用的文件进行判断，返回值指示文件是二进制格式还是文本格式。<code>SignalSend</code>函数则是对Socket对象非阻塞模式下的<code>send</code>方法进行了一个封装。</p>
<h3 id="u7C7B_u578B_u5B9A_u4E49"><a href="#u7C7B_u578B_u5B9A_u4E49" class="headerlink" title="类型定义"></a>类型定义</h3><p>这里简要说明一下Socket类中用到的一些自定义数据格式。</p>
<p>首先定义了一个<code>HANDLE</code>列表的标识符：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="built_in">list</span>&lt;HANDLE&gt; ThreadList;</span><br></pre></td></tr></table></figure></p>
<p>之后在<strong><em>SocketUnits</em></strong> 类中定义了两个结构体类型，用于向线程函数传递参数：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 监听线程函数参数类型定义 */</span></span><br><span class="line"><span class="keyword">struct</span> ListenParameter</span><br><span class="line">&#123;</span><br><span class="line">    HANDLE lastThread;</span><br><span class="line">    ISocketEvent *event;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">short</span> port;</span><br><span class="line">    <span class="built_in">string</span> ip;</span><br><span class="line">    wstring baseDir;</span><br><span class="line">    <span class="keyword">bool</span> *stop;</span><br><span class="line">    <span class="keyword">bool</span> *notifyStop;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 响应线程函数参数类型定义 */</span></span><br><span class="line"><span class="keyword">struct</span> ThreadParameter</span><br><span class="line">&#123;</span><br><span class="line">    sockaddr_in remoteAddr;</span><br><span class="line">    SOCKET remoteSocket;</span><br><span class="line">    ISocketEvent *event;</span><br><span class="line">    wstring baseDir;</span><br><span class="line">    <span class="keyword">bool</span> *stop;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h2 id="Socket_u6838_u5FC3_u7C7B_u5B9E_u73B0"><a href="#Socket_u6838_u5FC3_u7C7B_u5B9E_u73B0" class="headerlink" title="Socket核心类实现"></a>Socket核心类实现</h2><p>完成Socket类的定义之后，可以开始实现每个方法的功能了。</p>
<h3 id="u521D_u59CB_u5316_u548C_u9000_u51FA"><a href="#u521D_u59CB_u5316_u548C_u9000_u51FA" class="headerlink" title="初始化和退出"></a>初始化和退出</h3><p>首先当然是Socket类的构造函数了，这里我们定义一个构造函数，带一个<strong>ISocketEvent * </strong>类型的形参，这里不对实际传入的值做任何检查，也就是要求调用者必须传入一个在Socket类生存期间保持有效的值，这个值被用来初始化Socket类，从而实现回调。</p>
<p>初始化主要代码如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">SocketUnits::SocketUnits(ISocketEvent *event)</span><br><span class="line">&#123;</span><br><span class="line">    WSADATA wsd;</span><br><span class="line">    _stop = <span class="literal">false</span>;</span><br><span class="line">    _lastThread = INVALID_HANDLE_VALUE;</span><br><span class="line">    _lsParam.event = event;</span><br><span class="line">    _lsParam.stop = &amp;_stop;</span><br><span class="line">    _lsParam.notifyStop = &amp;_notifyStop;</span><br><span class="line"></span><br><span class="line">    _nRC = WSAStartup(MAKEWORD(<span class="number">2</span>, <span class="number">2</span>), &amp;wsd);</span><br><span class="line">    <span class="keyword">if</span> (_nRC)</span><br><span class="line">    &#123;</span><br><span class="line">        event-&gt;OnError(-<span class="number">1</span>, <span class="string">"初始化WinSock时出错！"</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (wsd.wVersion != MAKEWORD(<span class="number">2</span>, <span class="number">2</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        _nRC = -<span class="number">1</span>;</span><br><span class="line">        WSACleanup();</span><br><span class="line">        event-&gt;OnError(-<span class="number">2</span>, <span class="string">"不受支持的WinSock版本。"</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>其中<code>_lsParam</code>是一个<code>SocketUnit::ListenParameter</code>类型的变量，此处对它进行初始化，当创建监听线程时，它被作为一个参数传入到线程中。</p>
<p>接下来就是调用<code>WSAStartup</code>函数完成Windows Socket的一系列初始化工作，这个函数是应用程序应该第一个调用的 Winsock API 函数。</p>
<p>而在Socket类被析构时，则应该完成一些清理工作。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">SocketUnits::~SocketUnits()</span><br><span class="line">&#123;</span><br><span class="line">    Stop();</span><br><span class="line">    <span class="keyword">if</span> (!_nRC)</span><br><span class="line">        WSACleanup();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><code>WSACleanup</code>就是用来清除WinSock的函数。</p>
<h3 id="u5F00_u59CB_u4E0E_u7ED3_u675F_u670D_u52A1"><a href="#u5F00_u59CB_u4E0E_u7ED3_u675F_u670D_u52A1" class="headerlink" title="开始与结束服务"></a>开始与结束服务</h3><p>虽然真正的监听工作是在另外一个线程中完成的，但是对于开始方法来说，我们也必须返回一个状态表示方法是否调用成功，而不能让调用者仅仅依赖<code>OnListenSocketChanged</code>方法回调。</p>
<p>在<code>Start</code>方法中，做了一些简单的判断，来确定其返回状态值。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bool</span> SocketUnits::Start(<span class="keyword">const</span> <span class="built_in">string</span> &amp;ip, <span class="keyword">unsigned</span> <span class="keyword">short</span> port, <span class="keyword">const</span> wstring &amp;baseDir)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (_stop || (_lsParam.ip.compare(ip) == <span class="number">0</span> &amp;&amp; _lsParam.port == port &amp;&amp;</span><br><span class="line">                  _lsParam.baseDir.compare(baseDir) == <span class="number">0</span>))</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    _notifyStop = <span class="literal">false</span>;</span><br><span class="line">    _stop = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    _lsParam.ip = ip;</span><br><span class="line">    _lsParam.baseDir = baseDir;</span><br><span class="line">    _lsParam.port = port;</span><br><span class="line">    _lsParam.lastThread = _lastThread;</span><br><span class="line">    <span class="keyword">if</span> (_lastThread != INVALID_HANDLE_VALUE)</span><br><span class="line">        CloseHandle(_lastThread);</span><br><span class="line"></span><br><span class="line">    _lastThread = CreateThread(<span class="literal">NULL</span>, <span class="number">0</span>, (LPTHREAD_START_ROUTINE)(SocketUnits::ListenThread),</span><br><span class="line">        (LPVOID)&amp;_lsParam, <span class="number">0</span>, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (_lastThread == INVALID_HANDLE_VALUE)</span><br><span class="line">    &#123;</span><br><span class="line">        _lsParam.event-&gt;OnError(<span class="number">1</span>, <span class="string">"启动监听失败！"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>注意此处当创建线程失败的时候，并没有返回<code>false</code>，是因为线程创建失败时，则原来运行的监听线程（如果有）也会停止，那么调用者此时会接收到<code>OnServiceStopped</code>回调，此时，调用者应该响应这个回调函数，而不是依赖<code>Start</code>方法的返回值。</p>
<p>由于采用非阻塞I/O，所以要结束整个服务，只需要做一个类似广播的操作即可。在这里，我们只需要将<code>_stop</code>置为<code>true</code>且<code>_notifyStop</code>也置为<code>true</code>即可，此时所有的线程（包括监听线程和响应线程）均会执行线程结束部分代码，并正常结束线程，回收线程所占用资源。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> SocketUnits::Stop()</span><br><span class="line">&#123;</span><br><span class="line">    _notifyStop = <span class="literal">true</span>;</span><br><span class="line">    _stop = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">if</span> (_lastThread == INVALID_HANDLE_VALUE)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    CloseHandle(_lastThread);</span><br><span class="line">    _lastThread = INVALID_HANDLE_VALUE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="u7EBF_u7A0B_u51FD_u6570_u5B9E_u73B0"><a href="#u7EBF_u7A0B_u51FD_u6570_u5B9E_u73B0" class="headerlink" title="线程函数实现"></a>线程函数实现</h3><p>这里就是整个Socket类的核心实现了，主要需要注意的是线程之间传递数据时一定要保持数据在线程生存期间的有效性，否则可能导致不可预见的逻辑错误。此外就是采用异步I/O时需要进行的处理和优化。</p>
<p>首先是监听线程函数。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">DWORD WINAPI SocketUnits::ListenThread(LPVOID lpParameter)</span><br><span class="line">&#123;</span><br><span class="line">    ListenParameter *lp = (ListenParameter*)lpParameter;</span><br><span class="line">    HANDLE handle = lp-&gt;lastThread;</span><br><span class="line">    ISocketEvent *event = lp-&gt;event;</span><br><span class="line">    <span class="keyword">bool</span> *stop = lp-&gt;stop;</span><br><span class="line">    <span class="keyword">if</span> (handle != INVALID_HANDLE_VALUE)</span><br><span class="line">        WaitForSingleObject(handle, INFINITE);</span><br><span class="line">    *stop = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在函数的开头，首先从传入参数中取出各个值，其中<code>handle</code>保存上一个监听线程的句柄，在这里线程会首先判断<code>handle</code>的有效性，如果有效，说明程序曾经创建过一个监听线程，那么此处会调用<code>WaitForSingleObject</code>方法来等待上一个监听线程结束，然后才会开始执行。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">DWORD WINAPI SocketUnits::ListenThread(LPVOID lpParameter)</span><br><span class="line">&#123;</span><br><span class="line">    ......</span><br><span class="line"></span><br><span class="line">    SOCKET server = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);</span><br><span class="line">    <span class="keyword">if</span> (server == INVALID_SOCKET)</span><br><span class="line">    &#123;</span><br><span class="line">        event-&gt;OnError(<span class="number">2</span>, <span class="string">"无法创建Socket连接！"</span>);</span><br><span class="line">        event-&gt;OnServiceStopped(WSAGetLastError());</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    sockaddr_in addr;</span><br><span class="line">    addr.sin_family = AF_INET;</span><br><span class="line">    addr.sin_addr.S_un.S_addr = inet_addr(lp-&gt;ip.c_str());</span><br><span class="line">    addr.sin_port = htons(lp-&gt;port);</span><br><span class="line">    <span class="keyword">if</span> (bind(server, (LPSOCKADDR)&amp;addr, <span class="keyword">sizeof</span>(addr)) == SOCKET_ERROR)</span><br><span class="line">    &#123;</span><br><span class="line">        event-&gt;OnError(<span class="number">3</span>, <span class="string">"无法绑定服务器地址！"</span>);</span><br><span class="line">        event-&gt;OnServiceStopped(WSAGetLastError());</span><br><span class="line">        <span class="keyword">return</span> <span class="number">3</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (listen(server, SOMAXCONN) == SOCKET_ERROR)</span><br><span class="line">    &#123;</span><br><span class="line">        event-&gt;OnError(<span class="number">4</span>, <span class="string">"无法设置Socket为等待连接状态！"</span>);</span><br><span class="line">        event-&gt;OnServiceStopped(WSAGetLastError());</span><br><span class="line">        <span class="keyword">return</span> <span class="number">4</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    u_long mode = <span class="number">1</span>;</span><br><span class="line">    ioctlsocket(server, FIONBIO, &amp;mode);</span><br><span class="line">    event-&gt;OnListenSocketChanged(lp-&gt;ip.c_str(), lp-&gt;port, lp-&gt;baseDir.c_str());</span><br><span class="line"></span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接下来就是创建Socket了，这个Socket就是用来监听指定端口的。这里通过调用<code>ioctlsocket</code>方法将此Socket设置为非阻塞模式。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">DWORD WINAPI SocketUnits::ListenThread(LPVOID lpParameter)</span><br><span class="line">&#123;</span><br><span class="line">    ......</span><br><span class="line"></span><br><span class="line">    ThreadList workerTrds;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        ThreadParameter *tp = <span class="keyword">new</span> ThreadParameter();</span><br><span class="line">        <span class="keyword">int</span> nAddrLen = <span class="keyword">sizeof</span>(sockaddr_in);</span><br><span class="line">        <span class="keyword">while</span> ((<span class="keyword">int</span>)(tp-&gt;remoteSocket = accept(server, (LPSOCKADDR)&amp;(tp-&gt;remoteAddr),</span><br><span class="line">            &amp;nAddrLen)) &lt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (*stop)</span><br><span class="line">                <span class="keyword">goto</span> finish;</span><br><span class="line">            Sleep(<span class="number">400</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        tp-&gt;baseDir = lp-&gt;baseDir;</span><br><span class="line">        tp-&gt;event = lp-&gt;event;</span><br><span class="line">        tp-&gt;stop = lp-&gt;stop;</span><br><span class="line">        HANDLE thandle = CreateThread(<span class="literal">NULL</span>, <span class="number">0</span>,</span><br><span class="line">            (LPTHREAD_START_ROUTINE)(SocketUnits::WorkerThread),</span><br><span class="line">            tp, <span class="number">0</span>, <span class="literal">NULL</span>);</span><br><span class="line">        <span class="keyword">if</span> (thandle == INVALID_HANDLE_VALUE)</span><br><span class="line">        &#123;</span><br><span class="line">            closesocket(tp-&gt;remoteSocket);</span><br><span class="line">            <span class="keyword">delete</span> tp;</span><br><span class="line">            event-&gt;OnError(<span class="number">5</span>, <span class="string">"无法创建与客户端通信的线程！"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            workerTrds.push_back(thandle);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里开始正式监听，如果有来自客户端的请求，则会创建一个新的线程，将<code>tp</code>作为参数传递进去，<code>tp</code>中保存了这个请求的所有信息。由于此处<code>tp</code>是一个局部变量，因此我们需要在堆中分配它的内存，以免当本次循环结束时其内容所在内存区域被回收。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">DWORD WINAPI SocketUnits::ListenThread(LPVOID lpParameter)</span><br><span class="line">&#123;</span><br><span class="line">    ......</span><br><span class="line"></span><br><span class="line">finish:</span><br><span class="line">    closesocket(server);</span><br><span class="line">    ThreadList::iterator itor = workerTrds.begin();</span><br><span class="line">    <span class="keyword">for</span> (; itor != workerTrds.end(); ++itor)</span><br><span class="line">    &#123;</span><br><span class="line">        WaitForSingleObject((HANDLE)*itor, INFINITE);</span><br><span class="line">        CloseHandle((HANDLE)*itor);</span><br><span class="line">    &#125;</span><br><span class="line">    Sleep(<span class="number">800</span>);</span><br><span class="line">    <span class="keyword">if</span> (*(lp-&gt;notifyStop))</span><br><span class="line">    &#123;</span><br><span class="line">        *stop = <span class="literal">false</span>;</span><br><span class="line">        event-&gt;OnServiceStopped(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里就是结束代码了，当这个线程结束时，便执行这一部分代码，关闭Socket、释放资源并通知调用者。</p>
<p>然后便是响应函数了。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">DWORD WINAPI SocketUnits::WorkerThread(LPVOID lpParameter)</span><br><span class="line">&#123;</span><br><span class="line">    ThreadParameter *tp = (ThreadParameter*)lpParameter;</span><br><span class="line">    SOCKET remoteSocket = tp-&gt;remoteSocket;</span><br><span class="line">    sockaddr_in remoteAddr = tp-&gt;remoteAddr;</span><br><span class="line">    ISocketEvent *event = tp-&gt;event;</span><br><span class="line">    <span class="keyword">bool</span> *stop = tp-&gt;stop;</span><br><span class="line">    <span class="keyword">char</span> addr[<span class="number">16</span>];</span><br><span class="line">    <span class="built_in">strncpy</span>(addr, inet_ntoa(remoteAddr.sin_addr), <span class="number">15</span>);</span><br><span class="line">    addr[<span class="number">15</span>] = <span class="number">0</span>;</span><br><span class="line">    event-&gt;OnSocketConnected(addr);</span><br><span class="line"></span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>首先同样是取出参数中的值。<code>remoteSocket</code>保存了与客户端连接的Socket对象，<code>remoteAddr</code>保存了客户端IP地址。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">DWORD WINAPI SocketUnits::WorkerThread(LPVOID lpParameter)</span><br><span class="line">&#123;</span><br><span class="line">    ......</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span> buffer[<span class="number">1024</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    <span class="keyword">int</span> byteRecv = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">stringstream</span> ss;</span><br><span class="line">    wstring filepath;</span><br><span class="line">    <span class="built_in">string</span> filetype;</span><br><span class="line">    <span class="built_in">string</span> header = <span class="string">"HTTP/1.1 200 OK\r\nContent-Type: "</span>;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>)    <span class="comment">// 接收数据</span></span><br><span class="line">    &#123;</span><br><span class="line">        byteRecv = recv(remoteSocket, buffer, <span class="number">1023</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> (byteRecv == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">goto</span> finish;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (byteRecv &lt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (*stop)</span><br><span class="line">                <span class="keyword">goto</span> finish;</span><br><span class="line"></span><br><span class="line">            Sleep(<span class="number">10</span>);</span><br><span class="line">            <span class="keyword">int</span> err = WSAGetLastError();</span><br><span class="line">            <span class="comment">//if (errno == EINTR || errno == EAGAIN || errno == EWOULDBLOCK)</span></span><br><span class="line">            <span class="keyword">if</span> (err == WSAEWOULDBLOCK)</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                event-&gt;OnError(WSAGetLastError(), <span class="string">"无法从套接字接收数据。"</span>);</span><br><span class="line">                <span class="keyword">goto</span> finish;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    buffer[byteRecv] = <span class="number">0</span>;</span><br><span class="line">    event-&gt;OnNewLogs(addr, buffer, <span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接下来开始从客户端接收数据。注意异步调用需要进行的判断，这里仅处理了一些简单错误，实现基本的接收数据功能。同时，在循环之前定义了一些变量，这是因为在循环中含有<code>goto</code>语句，而C++不允许在<code>goto</code>语句后面进行非基本类型变量的初始化操作，因此将这些变量（<code>string</code>类型）的初始化移到循环体之前。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">DWORD WINAPI SocketUnits::WorkerThread(LPVOID lpParameter)</span><br><span class="line">&#123;</span><br><span class="line">    ......</span><br><span class="line"></span><br><span class="line">    ss &lt;&lt; buffer;</span><br><span class="line">    char tbuff[128];</span><br><span class="line">    while (ss.getline(tbuff, sizeof(tbuff)))</span><br><span class="line">    &#123;</span><br><span class="line">        char *p = strstr(tbuff, "GET");</span><br><span class="line">        if (p)</span><br><span class="line">        &#123;</span><br><span class="line">            strrchr(p, ' ')[0] = 0;</span><br><span class="line">            string fp = strchr(p, '/');</span><br><span class="line">            int len = fp.size();</span><br><span class="line">            if (len &gt; 0 &amp;&amp; fp.c_str()[len - 1] == '/')</span><br><span class="line">                fp += "index.html";</span><br><span class="line">            wstring ws(fp.size(), ' ');</span><br><span class="line">            copy(fp.begin(), fp.end(), ws.begin());</span><br><span class="line">            filepath = tp-&gt;baseDir + ws;</span><br><span class="line">            string ft;</span><br><span class="line">            int tp = GetType(ws, ft);</span><br><span class="line">            if (tp == 0)</span><br><span class="line">                filepath += L"/index.html";</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    if (filepath.size() == 0)</span><br><span class="line">    &#123;</span><br><span class="line">        const char *notSupport = "HTTP/1.1 501 Not Implemented\r\n\r\n";</span><br><span class="line">        SignalSend(remoteSocket, notSupport, strlen(notSupport), stop);</span><br><span class="line">        event-&gt;OnNewLogs(addr, notSupport, true);</span><br><span class="line">        goto finish;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在收到客户端发送的请求数据之后，就开始解析。此处仅仅检查<code>GET</code>方法，对于其他的请求方法，服务器会直接返回<code>501 Not Implemented</code>响应报文，表示不支持的方法。对于<code>GET</code>方法，这里会检查其请求的URL，并将其映射到本地文件路径，保存在<code>filepath</code>中。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">DWORD WINAPI SocketUnits::WorkerThread(LPVOID lpParameter)</span><br><span class="line">&#123;</span><br><span class="line">    ......</span><br><span class="line"></span><br><span class="line">    int type = GetType(filepath, filetype);</span><br><span class="line">    header.append(filetype);</span><br><span class="line">    header.append("\r\nConnection: close\r\n\r\n");</span><br><span class="line">    if (type &gt; 0 &amp;&amp; type &lt; 6)</span><br><span class="line">    &#123;</span><br><span class="line">        ifstream in(filepath.c_str());</span><br><span class="line">        if (!in)</span><br><span class="line">            goto fileNotExist;</span><br><span class="line"></span><br><span class="line">        if (!SignalSend(remoteSocket, header.c_str(), header.size(), stop))</span><br><span class="line">            goto finish;</span><br><span class="line">        event-&gt;OnNewLogs(addr, header.c_str(), true);</span><br><span class="line">        string data;</span><br><span class="line">        while (getline(in, data))</span><br><span class="line">        &#123;</span><br><span class="line">            if (data.size() == 0) continue;</span><br><span class="line">            if (!SignalSend(remoteSocket, data.c_str(), data.size(), stop))</span><br><span class="line">                goto finish;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    else</span><br><span class="line">    &#123;</span><br><span class="line">        ifstream in(filepath.c_str(), ios::binary);</span><br><span class="line">        if (!in)</span><br><span class="line">            goto fileNotExist;</span><br><span class="line"></span><br><span class="line">        if (!SignalSend(remoteSocket, header.c_str(), header.size(), stop))</span><br><span class="line">            goto finish;</span><br><span class="line">        event-&gt;OnNewLogs(addr, header.c_str(), true);</span><br><span class="line">        while (!in.eof())</span><br><span class="line">        &#123;</span><br><span class="line">            char str[1024];</span><br><span class="line">            in.read(str, 1024);</span><br><span class="line">            if (!SignalSend(remoteSocket, str, sizeof(char) * in.gcount(), stop))</span><br><span class="line">                goto finish;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    goto finish;</span><br><span class="line"></span><br><span class="line">fileNotExist:</span><br><span class="line">    const char *resp = "HTTP/1.1 404 Not Found\r\n\r\n";</span><br><span class="line">    SignalSend(remoteSocket, resp, strlen(resp), stop);</span><br><span class="line">    event-&gt;OnNewLogs(addr, resp, true);</span><br><span class="line"></span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接下来就是响应客户端请求，发送指定的文件给客户端了。这里通过<code>GetType</code>方法简单的判断请求文件的类型，然后进行读取并发送给客户端，这里需要注意文本文件和二进制文件的读取方法是不同的，我们需要根据文件的格式来确定读取方法。发送操作通过<code>SignalSend</code>来完成，此方法会返回一个布尔值，表示操作是否成功完成。如果请求的文件不存在，则会发送响应报文<code>404 Not Found</code>给客户端，表示请求资源不存在。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">DWORD WINAPI SocketUnits::WorkerThread(LPVOID lpParameter)</span><br><span class="line">&#123;</span><br><span class="line">    ......</span><br><span class="line"></span><br><span class="line">finish:</span><br><span class="line">    closesocket(remoteSocket);</span><br><span class="line">    event-&gt;OnSocketFinished(addr);</span><br><span class="line">    <span class="keyword">delete</span> tp;</span><br><span class="line">    Sleep(<span class="number">800</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结束代码，关闭Socket连接，并通知调用者。此处需要注意，要释放<code>tp</code>所占内存，因为这个<code>tp</code>是我们在<code>ListenThread</code>方法中通过<code>new</code>创建的，所以要在不再使用的时候通过<code>delete</code>释放它。</p>
<p>最后，写一下在编写这两个线程函数时学到的东西。</p>
<blockquote>
<p>在对Socket进行非阻塞方法调用时，不仅要对某些调用错误进行处理，同时还需要注意调用频率，因为一般我们都是在一个死循环中执行这些方法的，所以如果不进行一些处理，肯定会严重浪费CPU时间片，甚至占用全部CPU时间。我在第一次进行调试的时候，便是因为没有进行线程调度处理，结果程序运行几秒钟之后，整个电脑便彻底无响应了，连鼠标都无法移动，CPU时间被这个死循环耗尽了，最后被迫强制关机，所以之后几次调试我都是开着任务管理器然后再进行调试的，这个也算是Windows系统程序调度机制的优点和缺点了，虽然这里跑的是一个线程，但是这个线程是可以在任意一个CPU核心上被调度。说到这里，其实我也很好奇当时明明这个程序都无法继续运行了，为什么Windows还不提示强行关闭？还有，Windows居然不给一些核心程序（例如任务管理器、CMD等）预留一些时间片……</p>
</blockquote>
<p><strong> 因此，我们需要主动请求Windows对我们的线程进行调度。一般情况下是通过使用网上所说的<code>select</code>模式，而这里，我则是简单的通过调用<code>Sleep</code>函数来让Windows将线程休眠指定时间，从而让出CPU。 </strong></p>
<h3 id="u4E24_u4E2A_u5E2E_u52A9_u65B9_u6CD5"><a href="#u4E24_u4E2A_u5E2E_u52A9_u65B9_u6CD5" class="headerlink" title="两个帮助方法"></a>两个帮助方法</h3><p>最后还有两个在线程函数中被调用的帮助方法：<code>GetType</code>方法和<code>SignalSend</code>方法。</p>
<p>先介绍<em>GetType</em>方法，此方法主要就是判断指定文件的类型和格式，通过文件扩展名进行判断，比如在常用WEB文件中，<code>.html</code>、<code>.css</code>、<code>.js</code>等文件就是文本格式文件，而像<code>.jpg</code>、<code>.png</code>、<code>.gif</code>等文件则是二进制文件。此方法同时还返回一个<code>Content-Type</code>字符串，虽然这个属性值也可以从HTTP请求头中获取。</p>
<p><em>GetType</em>方法主要代码如下：<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">int SocketUnits::GetType(const wstring &amp;fileName, string &amp;type)</span><br><span class="line">&#123;</span><br><span class="line">    size_t pos = fileName.rfind('.');</span><br><span class="line">    if (pos &lt; 0 || pos &gt;= fileName.size() - 1)</span><br><span class="line">    &#123;</span><br><span class="line">        type = "file/file";</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line">    wstring extName = fileName.substr(pos + 1);</span><br><span class="line">    if (extName.compare(L"html") == 0)</span><br><span class="line">    &#123;</span><br><span class="line">        type = "text/html";</span><br><span class="line">        return 1;</span><br><span class="line">    &#125;</span><br><span class="line">    if (extName.compare(L"css") == 0)</span><br><span class="line">    &#123;</span><br><span class="line">        type = "text/css";</span><br><span class="line">        return 2;</span><br><span class="line">    &#125;</span><br><span class="line">    if (extName.compare(L"js") == 0)</span><br><span class="line">    &#123;</span><br><span class="line">        type = "application/javascript";</span><br><span class="line">        return 3;</span><br><span class="line">    &#125;</span><br><span class="line">    if (extName.compare(L"json") == 0)</span><br><span class="line">    &#123;</span><br><span class="line">        type = "application/json";</span><br><span class="line">        return 4;</span><br><span class="line">    &#125;</span><br><span class="line">    if (extName.compare(L"txt") == 0)</span><br><span class="line">    &#123;</span><br><span class="line">        type = "plain/text";</span><br><span class="line">        return 5;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    string str(extName.size(), ' ');</span><br><span class="line">    copy(extName.begin(), extName.end(), str.begin());</span><br><span class="line">    if (extName.compare(L"jpg") == 0 || extName.compare(L"gif") == 0 ||</span><br><span class="line">        extName.compare(L"png") == 0 || extName.compare(L"jpeg") == 0)</span><br><span class="line">    &#123;</span><br><span class="line">        type.assign("image/");</span><br><span class="line">        type.append(str);</span><br><span class="line">        return 6;</span><br><span class="line">    &#125;</span><br><span class="line">    if (extName.compare(L"mp3") == 0 || extName.compare(L"mp4") == 0)</span><br><span class="line">    &#123;</span><br><span class="line">        type.assign("audio/");</span><br><span class="line">        type.append(str);</span><br><span class="line">        return 7;</span><br><span class="line">    &#125;</span><br><span class="line">    type.assign("file/");</span><br><span class="line">    type.append(str);</span><br><span class="line">    return -1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>至于<em>SignalSend</em>方法，则是对非阻塞<code>send</code>方法的封装，实现发送指定长度字符串的功能。当发送期间出现错误、或者接收到结束线程的信号时，此方法会返回<code>false</code>值，否则返回<code>true</code>。</p>
<p><em>SignalSend</em>方法主要代码如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bool</span> SocketUnits::SignalSend(SOCKET s, <span class="keyword">const</span> <span class="keyword">char</span> *buf, <span class="keyword">size_t</span> len, <span class="keyword">bool</span> *stop)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">size_t</span> total = len;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> slen = send(s, buf, (<span class="keyword">int</span>)total, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> (slen &lt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (*stop)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">            Sleep(<span class="number">10</span>);</span><br><span class="line">            <span class="keyword">int</span> err = WSAGetLastError();</span><br><span class="line">            <span class="comment">//if (errno == EINTR || errno == EAGAIN || errno == EWOULDBLOCK)</span></span><br><span class="line">            <span class="keyword">if</span> (err == WSAEWOULDBLOCK)</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (slen == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (slen == total)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        buf += slen;</span><br><span class="line">        total -= len;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>至此，Socket核心类就已经完成了，可以实现基本的WEB服务功能。</p>
<h2 id="UI_u754C_u9762"><a href="#UI_u754C_u9762" class="headerlink" title="UI界面"></a>UI界面</h2><p>在完成Socket类之后，就可以开始设计UI界面了，这里使用Qt创建界面，具体内容就和Socket无关了，所以此处也不做详细分析了。</p>
<p>唯一要注意的就是，Qt的UI类是不允许重入的，因此我们只能在主线程、或者说UI线程中去访问，因此要注意回调接口类的实现，保证接口中的方法是在主线程中被调用的。</p>
<h2 id="u7ED3_u675F_u8BED"><a href="#u7ED3_u675F_u8BED" class="headerlink" title="结束语"></a>结束语</h2><p>经过几天的间断工作，终于完成了这个多线程WEB服务器的实现，虽然功能不甚完整，但是好歹是基本的工作还是能完成，一些简单的网页也可以通过浏览器进行打开（从浏览器中输入监听地址）。</p>
<p>这期间一边学习Windows Sockets，一边又复习了操作系统中的线程相关知识，到结束时，也算是获益匪浅了。</p>
<h2 id="u53C2_u8003"><a href="#u53C2_u8003" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="http://www.oschina.net/code/snippet_816473_35413" title="使用windows socket写的多线程web http服务器" target="_blank" rel="external">http://www.oschina.net/code/snippet_816473_35413</a></li>
<li><a href="http://www.cnblogs.com/yelaiju/archive/2010/09/29/1838065.html" title="HTTP 请求返回代码含义 " target="_blank" rel="external">http://www.cnblogs.com/yelaiju/archive/2010/09/29/1838065.html</a></li>
<li><a href="http://blog.csdn.net/shupan001/article/details/7045430" title="http请求头 " target="_blank" rel="external">http://blog.csdn.net/shupan001/article/details/7045430</a></li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<p>平时如果一个项目需要网络连接，一般都是直接用如<code>C#</code>、<code>Java</code>等高级语言直接调用相关的函数去实现功能，甚至从未关注过在底层这些函数是怎么运作的；而截至不久前，也只是用<code>C#</code>中的Socket相关类做过一点有关长连接的事情。</p>
<p>而最近，恰好由于网络课程实验要求，使用<code>Windows Sockets API</code> + <code>C/C++</code>来实现一个简单的多线程Web服务器，于是开始一边摸索，一边实现功能。在这个实验中，不仅仅是简单的<code>Windows Socket</code>函数调用，其实主要的工作还在于多线程（包括GUI线程）之间的通信，对于HTTP请求，也只是简单的实现了<code>GET</code>方法。</p>
<h2 id="u5B9E_u9A8C_u8981_u6C42"><a href="#u5B9E_u9A8C_u8981_u6C42" class="headerlink" title="实验要求"></a>实验要求</h2><ol>
<li>可配置IP地址、监听端口和主目录</li>
<li>能够在监听端口上进行监听</li>
<li>支持服务的启动</li>
<li>支持服务的关闭</li>
<li>能够响应客户端的请求，并定位相应的html文件</li>
<li>对每个请求能够创建单独的响应线程</li>
<li>能够发送可被客户端解析的响应报文</li>
<li>对于错误的请求能够定位错误的原因并给出相应的响应</li>
<li>支持多种类型文件的输出</li>
<li>具备图形GUI界面]]>
    
    </summary>
    
      <category term="Windows Sockets" scheme="http://3meng.github.io/tags/Windows-Sockets/"/>
    
      <category term="Socket" scheme="http://3meng.github.io/categories/Socket/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Hello World]]></title>
    <link href="http://3meng.github.io/2015/03/21/hello-world/"/>
    <id>http://3meng.github.io/2015/03/21/hello-world/</id>
    <published>2015-03-20T16:52:19.000Z</published>
    <updated>2015-12-08T12:24:34.000Z</updated>
    <content type="html"><![CDATA[<p>第一篇博文，不知道该写个什么名字最好，干脆就保持默认的标题<code>Hello World</code>吧，这也算是学计算机软件的一个启蒙标志吧。<br><a id="more"></a></p>
<h2 id="u7B80_u8981_u8BF4_u660E"><a href="#u7B80_u8981_u8BF4_u660E" class="headerlink" title="简要说明"></a>简要说明</h2><h3 id="u8D77_u56E0"><a href="#u8D77_u56E0" class="headerlink" title="起因"></a>起因</h3><p>其实很早就有了创建自己的博客的想法，只是一来没有找到托管的地方（那些提供博客服务的站点一般都没有太多的自定义权限，所以直接不考虑了），二来也是这个想法只是在偶然间会闪现出来，然后一拖延就没了= =，所以一直等到最近才下定决心。</p>
<p>其实平时是经常与博文打交道的，一般都是搜索一些软件开发的问题，而通常获取答案的位置都是在别人的博文之中，这也是搭建自己的博客的一个起因吧：记录那些平时开发过程中的问题和解决方案，以及一些想法等，还有偶尔的随笔也可以。</p>
<p>而这次下定决心也是因为如此，拿一个<code>Windows Runtime</code>开发中的细节问题去Google上搜索了半天，都是千篇一律的答案，而且是我最不想使用的解决方案，最后无奈之下只好又找上了<code>MSDN</code>文档，在窗口页面终于找到了看起来应该合适的属性，虽然看起来“权限”比较高，所以就先测试了一下（有些真的需要自己测试，<code>Windows Runtime</code>方面的还好，以前的<code>Windows Phone Silverlight</code>开发，一般像我找到的属性类型都是<code>[安全关键]</code>的，看起来属性介绍很正常，但是真正运行起来之后，就会丢出异常，因为无权访问……）。这次测试当然是成功了，而这也从一方面说明微软在Windows 8.1时代确实就已经构建了初步的通用平台了，虽然API的描述很多都是用电脑操作介绍的，但是在手机上也能跑起来，所以，希望对Windows 8.1进一步完善的Windows 10能带给我们更大的惊喜吧。题外话了，经过这次之后，我终于决定要开始搭建一个自己的博客了，这次在不能拖延了，一方面记录自己遇到的问题，以后也可做个参考比较，另一方面也可以给遇到相同问题的人一些提示，何乐而不为？</p>
<h3 id="u8FC7_u7A0B"><a href="#u8FC7_u7A0B" class="headerlink" title="过程"></a>过程</h3><p>一开始想到的是使用<code>WordPress</code>，因为曾今见到一个同学用它搭建过博客站点，页面风格很符合我的要求，但是需要找支持的主机，看了一下SAE，注册认证过程太耽误时间了，刚好这一段时间我是真的没时间去为一个博客托管站点弄那么多东西了，所以只有放弃了。之后又了解到<code>GitHub</code>上可以托管站点，从网上搜索了一些资料，最后决定使用<code>hexo</code>配合<code>GitHub</code>来创建一个个人静态博客。</p>
<p>有关<code>hexo</code>的介绍就不多说了，网上很多资料，找一个完整一点的很快就可以搭建起个人博客了。下面附一段<code>hexo</code>安装后默认文章里面的简介：</p>
<blockquote>
<p>Welcome to <a href="http://hexo.io/" target="_blank" rel="external">Hexo</a>! This is your very first post. Check <a href="http://hexo.io/docs/" target="_blank" rel="external">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="http://hexo.io/docs/troubleshooting.html" target="_blank" rel="external">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="external">GitHub</a>.</p>
</blockquote>
<h2 id="u5F00_u59CB_u4F7F_u7528"><a href="#u5F00_u59CB_u4F7F_u7528" class="headerlink" title="开始使用"></a>开始使用</h2><h3 id="Markdown"><a href="#Markdown" class="headerlink" title="Markdown"></a>Markdown</h3><p><code>hexo</code>使用命令行创建文章，但其实也就是一个<code>.md</code>文件，而在这之前，其实我从来没使用过<code>Markdown</code>语法来写东西，所以在大概了解完<code>hexo</code>基本知识之后，又开始学习<code>Markdown</code>文件的常用规则，从网络上找到了一篇比较详细的说明，具体可以自己进去看看：<a href="http://wowubuntu.com/markdown/" target="_blank" rel="external">Markdown语法</a>。而编辑<code>Markdown</code>文件我一般是用<code>Notepad++</code>，没有使用网上传说的神器<code>Sublime</code>，因为习惯了。</p>
<h3 id="u5176_u5B83"><a href="#u5176_u5B83" class="headerlink" title="其它"></a>其它</h3><p>最近也没有更多的时间来学习关于<code>hexo</code>的更多东西了，所以有很多内容都只能等过一阵子闲下来了才能开始继续。主要在于博客的完善与自定义上。</p>
<h2 id="u5B8C_u5584"><a href="#u5B8C_u5584" class="headerlink" title="完善"></a>完善</h2><h3 id="u4EE3_u7801_u9AD8_u4EAE"><a href="#u4EE3_u7801_u9AD8_u4EAE" class="headerlink" title="代码高亮"></a>代码高亮</h3><p>代码高亮是肯定要弄的，虽然<code>hexo</code>自带了有高亮功能，但是支持的太有限了，特别对.Net这一块，几乎没有支持，所以需要自己去寻找新的方案。<br>下面同样一段代码，作为C#标记时全然见不到高亮效果，甚至连行号都出错了……</p>
<p>[C#]<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public class Class&#10;&#123;&#10;&#9;private int _index;&#10;&#9;public Class(int index) &#10;&#9;&#123;&#10;&#9;&#9;this._index = index;&#10;&#9;&#125;&#10;&#125;</span><br></pre></td></tr></table></figure></p>
<p>[Java]<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Class</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> _index;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Class</span><span class="params">(<span class="keyword">int</span> index)</span> </span><br><span class="line">	</span>&#123;</span><br><span class="line">		<span class="keyword">this</span>._index = index;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="u5E03_u5C40_u3001_u4E3B_u9898"><a href="#u5E03_u5C40_u3001_u4E3B_u9898" class="headerlink" title="布局、主题"></a>布局、主题</h3><p><code>hexo</code>有很多主题可选，我当前使用的是一个名叫<code>Jacman</code>的主题，大概框架很符合我的要求，不过具体细节有些还是需要调整，具体到<code>_config.yml</code>文件还有很多东西没有测试呢。</p>
<h3 id="u5176_u5B83-1"><a href="#u5176_u5B83-1" class="headerlink" title="其它"></a>其它</h3><p>其实还有很多东西需要完善，仅仅看网上一个介绍<code>hexo</code>的文章，后面都是介绍统计功能和评论框的，而这两个我也考虑有时间加进来，其中统计其实<code>Jacman</code>默认是提供了代码的，只需要在<code>_config.yml</code>文件中配置相应的统计跟踪ID即可，百度统计还需要单独注册账号，所以目前我是用的<code>Google Analytics</code>，只能但愿一般时候不要被墙。。。（话说我昨天一天都无法进入Google Analytics，挂代理都打不开了）。评论框和其它的优化等有时间在弄了。</p>
<h2 id="u5199_u5728_u6700_u540E"><a href="#u5199_u5728_u6700_u540E" class="headerlink" title="写在最后"></a>写在最后</h2><p>断断续续的用了几个夜晚，终于大概配置完了，中间走了一些弯路，比如主题一块，一开始我是慢慢从默认的那个主题<code>landscape</code>上摸索修改的，后来发现是在太慢了，只能简单的修改一些内容，要想配置好估计得将整个主题全部文件关联都弄清楚，于是尝试了一下<code>GitHub</code>上的<code>hexo</code>主题，发现也很不错的，而有了前面的经验，修改这个主题也要快多了。</p>
<p>最后要说的就是Google Chrome浏览器有点坑了，居然删除了RSS订阅模块，导致我每次从Chrome中预览时，点击那个RSS都会直接打开xml文件，而不是提示订阅RSS源，就因为这个停了几个夜晚，知道今天突然从IE上打开一次，才发现RSS功能正常= =。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>第一篇博文，不知道该写个什么名字最好，干脆就保持默认的标题<code>Hello World</code>吧，这也算是学计算机软件的一个启蒙标志吧。<br>]]>
    
    </summary>
    
      <category term="Hexo" scheme="http://3meng.github.io/tags/Hexo/"/>
    
      <category term="随笔" scheme="http://3meng.github.io/categories/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
</feed>

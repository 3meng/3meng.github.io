<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[一千二百年的清风明月]]></title>
  <subtitle><![CDATA[历劫由来谁一笑，仙踪尽飞羽衣飘。]]></subtitle>
  <link href="/atom.xml" rel="self"/>
  <link href="http://3meng.github.io/"/>
  <updated>2016-02-28T11:16:47.000Z</updated>
  <id>http://3meng.github.io/</id>
  
  <author>
    <name><![CDATA[一粒尘埃]]></name>
    <email><![CDATA[hp839259646@hotmail.com]]></email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title><![CDATA[【译】实现一个DLNA兼容的UPnP AV媒体服务器]]></title>
    <link href="http://3meng.github.io/2016/02/28/Implementing-a-DLNA-compliant-UPnP-AV-MediaServer/"/>
    <id>http://3meng.github.io/2016/02/28/Implementing-a-DLNA-compliant-UPnP-AV-MediaServer/</id>
    <published>2016-02-27T17:25:38.000Z</published>
    <updated>2016-02-28T11:16:47.000Z</updated>
    <content type="html"><![CDATA[<p>首先说明，这是毕设中要求翻译的一篇论文，原文相关信息如下：</p>
<ul>
<li>题目：<strong>Implementing a DLNA-compliant UPnP AV MediaServer with DVB and RTSP/RTP support</strong>.（实现一个DLNA兼容且支持DVB和RTSP/RTP的UPnP AV媒体服务器）</li>
<li>作者：<strong>Martin Emrich</strong></li>
<li>上传日期：2009年4月28日</li>
<li>导师：Manuel Gorius，硕士</li>
<li>初审者：Thorsten Herfet，博士，教授 </li>
<li>二审者：Philipp Slusallek，博士，教授</li>
</ul>
<p>本文只为翻译所用，<strong>一切版权和许可均归原作者所有</strong>。</p>
<blockquote>
<p><strong>同意声明</strong><br>我同意将论文的两个版本添加到计算机学院的图书馆，使其向公众开放。</p>
<p><strong>感谢</strong><br>本论文由英特尔股份有限公司的“数字家庭研究实验室”给予支持。 </p>
</blockquote>
<p><strong>摘要</strong><br>在家庭多媒体网络中，目前分布式存储的内容（照片、音乐、视频文件）是与直播电视和电台分离的，即使最近已经开始由IP网络传输。本文描述了一个支持发布内容到家庭网络且可以接收数字视频广播的原型媒体服务器的设计和实现。它遵守<code>DLNA</code>设备互操作指南，以兼容许多现有设备，并通过实时传输协议（<code>RTP</code>）以及<code>HTTP</code>提供到<strong>UPnP AV</strong>客户端的直播。 </p>
<a id="more"></a>
<p><strong>部分缩写</strong><br><strong>AHEC</strong> 高级混合纠错<br><strong>BGD</strong> 双向网关设备<br><strong>CTT</strong> 一致性测试工具<br><strong>DHCP</strong> 动态主机配置协议<br><strong>DLNA</strong> 数字生活网络联盟<br><strong>DMP</strong> 数字媒体播放器<br><strong>DMS</strong> 数字媒体服务器<br><strong>DNG</strong> 交付网络网关<br><strong>DUT</strong> 测试设备<br><strong>DVB</strong> 数字视频广播<br><strong>DVBSTP</strong> DVB SD&amp;S传输协议<br><strong>EPG</strong> 电子节目指南<br><strong>FEC</strong> 前向纠错<br><strong>GENA</strong> 通用事件通知结构<br><strong>HNED</strong> 家庭网络终端设备<br><strong>IGMP</strong> Internet组管理协议<br><strong>IPI</strong> 互联网协议基础结构（在DVB上下文）<br><strong>IPTV</strong> 因特网协议电视<br><strong>NPT</strong> 本地播放时间<br><strong>RTCP</strong> 实时控制协议<br><strong>RTP</strong> 实时传输协议<br><strong>RTSP</strong> 实时流传输协议<br><strong>SDP</strong> 会话描述协议<br><strong>SSDP</strong> 简单服务发现协议<br><strong>UCDAM</strong> 统一的客户端数据可用性模型<br><strong>UGD</strong> 单向网关设备<br><strong>UPnP</strong> 通用即插即用<br><strong>UUID</strong> 通用唯一标识符</p>
<h2 id="u5F15_u8A00"><a href="#u5F15_u8A00" class="headerlink" title="引言"></a>引言</h2><h3 id="u52A8_u673A"><a href="#u52A8_u673A" class="headerlink" title="动机"></a>动机</h3><p>过去的几年中，数字广播在快速的取代传统的模拟广播。基于<code>DVB</code>的数字电视目前（只有少数例外）已经在德国成为标准。尽管如此，在一个符合标准的方式下通过IP网络传输实况广播内容到现在为止仅在少数拐角情况可用。</p>
<blockquote>
<p>到2008年为止，只有三个德国英特网服务提供商提供免费可用的公共电台IPTV流到他们的客户住所，所有的都只适用于他们自己的专用IPTV订阅。</p>
</blockquote>
<p>同时，家庭多媒体网络正变的更加现实。新的标准，比如<strong>UPnP AV</strong>和<strong>DLNA</strong>，允许家用多媒体设备发现彼此而无需终端用户的任何配置。这样一来，很多人已经在使用家庭网络，使他们的照片，视频和音乐集合始终在家庭媒体客户端设备可用。类似DLNA CERTIFIED™徽标计划的新举措将保证不同厂商的设备在协议和内容格式条款之间的<strong>兼容性</strong>。</p>
<h3 id="u76EE_u6807"><a href="#u76EE_u6807" class="headerlink" title="目标"></a>目标</h3><p>目前，这两个世界几乎独立存在。典型的家庭网络用户有一个网络媒体播放器设备，旁边放着一个DVB接收盒（即使DLNA承认这些“小岛”）。我们的目标是通过提供一个媒体服务器来联合这两个应用程序，媒体服务器<strong>使用现有的标准构建</strong>，并可通过DVB调谐器硬件以及音乐，视频和照片等内容存储提供现场直播。当然，对于每一种类型的内容，适当的传输协议（<code>HTTP</code>，<code>RTSP/RTP</code>单播或多播）将被选择。服务器将是<strong>符合DLNA设备指南</strong>，因此与市场上的许多设备兼容。未来的工作可以包括相应的媒体客户端的设计，包括硬件，操作系统配置和软件。</p>
<p>一个使用<code>RTP</code>协议直播电视和电台的DLNA兼容的媒体服务器的原型将在本文进行开发。由于目前没有UPnP或DLNA兼容的接收设备可用于接收RTP传输信号，一个合适的媒体渲染器由Jochen Crun同时开发。为了证明DLNA兼容性，最后的媒体服务器使用<strong>DLNA一致性测试工具</strong>（<code>CTT</code>）测试，当然它应该通过所有相关测试。</p>
<h2 id="u5DF2_u5B58_u5728_u7684_u6846_u67B6_u548C_u6807_u51C6"><a href="#u5DF2_u5B58_u5728_u7684_u6846_u67B6_u548C_u6807_u51C6" class="headerlink" title="已存在的框架和标准"></a>已存在的框架和标准</h2><p>有几个标准组织以及个别公司正在开发各种框架，使广播和/或媒体可以共享到家庭网络。</p>
<h3 id="DVB-IP"><a href="#DVB-IP" class="headerlink" title="DVB-IP"></a>DVB-IP</h3><p><code>DVB-IPI</code>（DVB因特网协议基础，最近也被称为<code>DVBIPTV</code>）描述了一种框架，以使DVB进入家庭网络。交付网络网关（<strong>DNG</strong>）连接一个或多个分发网络（DVB-S/-C/-T等基于调谐器以及基于IP的服务）到基于IP的家庭网络。家庭网络的不同段通过家庭网络节点（<strong>HNN</strong>）连接，例如一个无线接入点连接基于电缆的802.3网络和无线的802.11网络。关于家庭网络的另一端是家庭网络终端设备（<strong>HNED</strong>），其接收数据流。</p>
<blockquote>
<p>尽管没有任何关于重命名的可靠资料被发现，但是现在很多文献已经在同时使用这两种缩写。</p>
</blockquote>
<p>一个家庭网络终端设备通过<em>服务发现和选择协议</em>（<code>SD&amp;S</code>）发现可用的服务。这种情况可以发生在推模式，服务提供者通过<code>DVBSTP</code>组播发送SD&amp;S数据，也可以发生在拉模式，其中终端设备通过HTTP抓取当前SD&amp;S的数据。若干自举方法被定义，例如通过DNS查找，DHCP配置，IANA注册组播信道或用户提供的HTTP URL。</p>
<p>在发现服务后，终端设备可以通过SD&amp;S获取XML文档的<code>DVB-SI</code>（服务信息）。</p>
<p>媒体流的唯一容器为<strong>MPEG传输流</strong>（TS），无论是通过<code>RTP</code>还是<code>UDP</code>（<strong>ITU H.610</strong>）传输。会话通过<code>IGMP</code>（组播）或<code>RTSP</code>（同样有限，没有特技播放操作）管理。</p>
<p>目前，仅有少数的最终用户设备明确兼容<code>DVB-IPTV</code>，尽管有可能一些专有的IPTV产品至少在德国市场上提供了部分<code>DVB-IPI</code>兼容。要确认这些，更多的逆向工程工作可能是必需的。</p>
<p><code>DVB-IPI</code>的主要缺点是其对于MPEG流之外的媒体类型缺少支持，使得它不适合用于家庭网络中分布式的本地内容存储（照片，音乐）。一些机制，例如<code>多协议封装</code>（MPE，它允许在MPEG数据流中嵌入任意数据发送），理论上可以用于扩展功能，但它们不是DVB-IPI规范的一部分。其更关注提供在现有DVB传输中提供的相同的特性（通过加入视频点播）。</p>
<p>不过，一个通用设备除了其他框架外还可以实现DVB-IP以获得与现有的DVB-IP服务的兼容性。</p>
<h3 id="DVB-HN"><a href="#DVB-HN" class="headerlink" title="DVB-HN"></a>DVB-HN</h3><p>DVB项目似乎已经了解了DVB-IPI的局限性，它们现在将DVB-IPI和DLNA的特性组合成一个称为<code>DVB-HN</code>（<strong>DVB家庭网络</strong>）的新框架。本质上，DVB-HN根据DLNA准则，使在广播内容中需要的所有可选部分为必须的。他们还引进新的设备类：</p>
<ul>
<li><strong>HNED</strong>（家庭网络终端设备）：这些重用现有的DLNA设备类（DMS，DMP，DMC），分别扩展为<code>DVB-DMS</code>，<code>DVB-DMP</code>和<code>DVB-DMC</code>。</li>
<li><strong>网关设备</strong>（GD）将家庭网络连接到广播源。一个<strong>DVB-UGD</strong>（单向网关设备）包含一个调谐器和一个DMS，并使得接收到的DVB信道在家庭网络上可用。 一个<strong>DVB-BGD</strong>（双向网关设备）通过宽带连接将家庭网络于服务提供者连接，后者可能包括一个DVB-IPI兼容的交付网络网关以支持现有的DVB-IPI终端设备（这可以是简单的通过直接桥接网络到服务提供商）。</li>
<li><strong>远程设备</strong>（DVB-RMC）可以控制在家庭网络内的设备，而并不必须在家庭网络（通过VPN连接）中。例如可以用来录制电视节目而不必在家里。</li>
</ul>
<p>DVB-HN还引入了新的设备功能（一组<strong>不局限于特定设备类的功能</strong>）。最值得注意的是：</p>
<ul>
<li><strong>dvb-sdns</strong>声明对DVB-IPI规定的SD&amp;S协议的支持，使设备与DVB-IPI交付网络网关或终端设备兼容。</li>
<li><strong>dvb-cpcm</strong>实现兼容DRM的DVB内容保护和复制管理。</li>
</ul>
<p>所有在此提出的框架中，DVB-HN最接近这个项目的目标。但同样，该框架是相当新的，仍处于草案状态，在万维网中找不到任何实现了它的设备。如果在DLNA和DVB-HN规范之间没有出现冲突，支持两种标准将是一个真正的的通用设备最好的行动过程。</p>
<h3 id="u4E13_u7528_u89E3_u51B3_u65B9_u6848"><a href="#u4E13_u7528_u89E3_u51B3_u65B9_u6848" class="headerlink" title="专用解决方案"></a>专用解决方案</h3><p>由于所有提到的标准都是比较新的，许多厂商都在同时开发了自己的专有的家庭网络系统。比如像<strong>AppleTV</strong>、微软的<strong>Windows媒体中心</strong>等，可能在他们的生态系统中工作得很好，他们不可避免地锁定用户到一个单一的供应商控制的世界。而很有可能，AppleTV的设备将决不显示DVB-IPTV，同样可能基于微软媒体室的T-Home娱乐空间接收器将永远不会从iTunes中播放一首歌曲。脱离这种情况的唯一的办法就是随之而来的开放标准的推广和使用。</p>
<h3 id="VDR"><a href="#VDR" class="headerlink" title="VDR"></a>VDR</h3><p>一个著名的框架，尽管也是一个专有的解决方案，就是<strong>视频硬盘录像机</strong>（VDR）。它是<code>GNU</code>公共许可证下的一个自由软件项目，从一开始的设计目的就是把一个过时的PC系统变成个人视频录像机。它需要一个所谓的全功能的DVB接收机卡（其包括MPEG硬件解码器和在显示器上显示的功能）。除此之外，它具有很低的配置要求：300MHz的CPU，256MB的RAM，当然还要有一个足够大的硬盘以存储电视节目。它被广泛使用的主要原因大概是因为它可以很方便<strong>通过插件来进行扩展</strong>。</p>
<p>不久，DVB调谐卡厂商推出了缺乏硬件解码器的更便宜的卡（“预算卡”）。在这之后不久，几个模拟软件解码的插件出现了。另一个被普遍使用的插件<code>streamdev</code>，它允许一个VDR实例充当服务器（提供网络上的DVB硬件）或客户机（访问网络上的<code>VDR-streamdev</code>服务器）。<code>Streamdev</code>同时提供所谓的<code>VTP</code>专有协议和标准的HTTP流媒体服务器。通过这些插件，在家庭网络中流直播是可能的，但对一般的终端用户来说配置它们太困难。</p>
<p>尽管如此，一个运行VDR且带<code>streamdev</code>的服务器也是本文实现的流媒体服务器的可能的来源之一。</p>
<h3 id="UPnP"><a href="#UPnP" class="headerlink" title="UPnP"></a>UPnP</h3><p><em>通用即插即用</em>架构打算让来自不同厂商的网络设备通过定义IP地址获取、设备发现和描述，远程调用和事件通知来进行互操作。因此，UPnP兼容设备可以找到网络中的其他UPnP设备，调用由他们提供的方法以及得到事件的通知，这一切都无需用户来配置设备。</p>
<blockquote>
<p>在UPnP术语中，一个设备并不一定是一个硬件装置，它也有可能是一个运行在台式机上的软件。</p>
</blockquote>
<p>UPnP AV定义UPnP设备类型的集合，以使网络设备通过家庭网络共享媒体内容。媒体服务器存储和提供内容项目，而媒体播放器可以接收并显示它们。控制点发现网络上的设备，并初始化媒体传输（播放）。UPnP AV允许多种传输方式，包括<strong>HTTP</strong>，<strong>RTSP/RTP</strong>，<strong>点至点连接</strong>（如<code>IEEE1394</code>）和<strong>专有的连接</strong>。</p>
<p>由于UPnP是这个项目选择的框架，现在让我们来看看它的设计和使用的协议：</p>
<h4 id="u8BBE_u5907_u548C_u670D_u52A1"><a href="#u8BBE_u5907_u548C_u670D_u52A1" class="headerlink" title="设备和服务"></a>设备和服务</h4><p>在UPnP的术语中，一台设备可以是提供服务的UPnP<em>设备</em>，也可以是调用其它<em>设备</em>服务的<em>控制点</em>。因此，在本文中，每当一个逻辑实体“设备”是代表UPnP设备结构时，都将会使用斜体书写。</p>
<p>每个UPnP<em>设备</em>都提供一个或多个服务，并且甚至有可能包含其它<em>设备</em>。在此层次结构中的最上面的<em>设备</em>被称为<em>根设备</em>，而其它的是<em>嵌入式设备</em>。这样一来，一台设备可以同时提供不同的、甚至是不相关的功能。每台<em>根设备</em>都有一个<strong>全局唯一标识符</strong>（UUID），它唯一的标示了一台设备，并且即使设备重启也不会改变。</p>
<p>每个<em>服务</em>都提供若干个可以远程调用的<em>服务动作</em>。</p>
<h4 id="u83B7_u53D6IP_u5730_u5740"><a href="#u83B7_u53D6IP_u5730_u5740" class="headerlink" title="获取IP地址"></a>获取IP地址</h4><p>虽然这部分由底层的操作系统而不是<code>rtpserver</code>处理，但它仍应在这里描述。</p>
<p>首先，UPnP网络目前仅限于IPv4；既不是IPv6也不是其他非IP协议，这是说明书上的一部分。 UPnP规定，在连接到网络后，每个设备都必须首先尝试通过<code>DHCP</code>获取IP地址。只有当获取失败的时候，它才需要自己分配一个本地链接的IPv4地址（也称为“零配置”）。</p>
<p>整个UPnP网络通信都使用IP地址，即不要求或允许使用DNS域名，也没有像多播DNS这样的免配置解决方案。</p>
<p>需要注意的是，如果设备具有多个网络接口（例如，802.3和802.11），每个接口都被独立地处理。</p>
<h4 id="u8BBE_u5907_u53D1_u73B0"><a href="#u8BBE_u5907_u53D1_u73B0" class="headerlink" title="设备发现"></a>设备发现</h4><p>UPnP设备通过<strong>简单服务发现协议</strong>（<code>SSDP</code>）找到彼此。SSDP定义了其它设备可以监听的公告以及适用于特定设备的主动搜索。</p>
<p>一个UPnP设备的SSDP活动消息示例：</p>
<pre><code class="http">NOTIFY * HTTP/1.1
HOST: 239.255.255.250:1900
CACHE-CONTROL: max-age=1800
LOCATION: http://10.20.0.76:10080/volatile/description.xml
NT: urn:schemas-upnp-org:device:MediaServer:1
NTS: ssdp:alive
SERVER: Linux/2.6.27-7-generic, UPnP/1.0, Portable SDK for UPnP devices/1.6.6
X-User-Agent: redsonic
USN: uuid:a6a69884-7a6d-413b-75cba6a8b07d::urn:schemas-upnp-org:device:MediaServer:1
</code></pre>
<p><strong>公告</strong> 每当一个<em>设备</em>或<em>服务</em>进入或离开网络，它将通过组播发送一个数据报到<code>239.255.255.250:1900</code>。上面是一个示例。一个设备进入网络时发送一个子类型通知（<code>NTS</code>），其头部是<code>ssdp:alive</code>；当离开时发送<code>ssdp:byebye</code>。通知消息包括：</p>
<ul>
<li>过期时间（在<code>CACHE-CONTROL</code>头部）：为防止由于离开网络的设备没有发送<em>byebye</em>消息（例如，因为它们被突然断电或网络链接被断开）而导致失效条目残留在设备的内部状态中，每个SSDP消息都有超时属性，超过这个时间之后实体将被认为过期，除非它被另一个活动的消息更新。超时时间通常设置为<strong>1800秒</strong>（<strong>30分钟</strong>）。</li>
<li>设备描述URL（在<code>LOCATION</code>头部）：在这里，感兴趣的网络实体可以找到有关<em>设备</em>或<em>服务</em>更多信息的XML文档。参见2.5.4节。</li>
<li>通知类型（<code>NT</code>）和一个唯一的服务名称（<code>USN</code>）指定了发送通知的设备或服务的类型。具体内容取决于通知类型。</li>
</ul>
<p>一个UPnP根设备公告由三种<em>根设备</em>通知组成，两种用于嵌入式<em>设备</em>，一种用于服务。 这些消息的确切标记可以在<strong>参考文献[7]</strong>中找到。</p>
<p><strong>搜索</strong> UPnP<em>控制点</em>也能够主动地在网络上搜索特定的<em>设备</em>或服务类型。他们发送一个搜索请求，类似于下面所示内容：</p>
<pre><code class="http">M-SEARCH * HTTP/1.1
HOST: 239.255.255.250:1900
MAN: &quot;ssdp:discover&quot;
MX: 60
ST: unpn:rootdevice
</code></pre>
<p>搜索包含一个用秒作单位（在<code>MX</code>头部）的<strong>最大等待时间</strong>，它<strong>随机</strong>的指定一个响应延迟时间上限。通过这种方式，多个设备对搜索的响应消息就不太可能会同时涌入搜索方了。此外，搜索还包含一个搜索目标（<code>ST</code>头部），指定要搜索的内容（在简单情况下，它是<code>ssdp:all</code>，搜索任何实体）。通常情况下，搜索请求会被发送多次，以确保即使在有损网络环境中的设备也能收到。</p>
<p>每一个认为它自己或它的服务与搜索请求相匹配的<em>设备</em>，现在可以返回一个单播搜索响应到发出搜索请求的IP地址。</p>
<h4 id="u63CF_u8FF0"><a href="#u63CF_u8FF0" class="headerlink" title="描述"></a>描述</h4><p><em>设备</em>和<em>服务</em>的描述都是以XML文档通过HTTP发布。文档中包含一个<em>控制点</em>所需要与<em>设备</em>或<em>服务</em>进行交互的所有信息。</p>
<p>一个设备描述可以包含设备类型，用于向用户显示的友好名称，一个唯一标识该设备一个实例的UUID以及一些不限类型的字段，比如生产商，一个到制造商网站的URL，模型名称，型号，序列号和UPC等。它还包含<em>设备</em>提供的服务的列表，以及包含的<strong>嵌入式设备</strong>列表。如下所示是一个UPnP AV媒体服务器设备描述的例子：</p>
<pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot; standalone=&quot;no&quot; ?&gt;
&lt;root xmlns=&quot;urn:schemas-upnp-org:device-1-0&quot;
      xmlns:dlna=&quot;urn:schemas-dlna-org:device-1-0&quot;&gt; 
  &lt;speVersion&gt; 
    &lt;minor&gt;0&lt;/minor&gt;  
    &lt;major&gt;1&lt;/major&gt; 
  &lt;/speVersion&gt;  
  &lt;URLBase&gt;http://192.168.80.2:49152&lt;/URLBase&gt;  
  &lt;device&gt; 
    &lt;deviceType&gt;urn:shemas-upnp-org:devie:MediaServer:1&lt;/deviceType&gt;  
    &lt;friendlyName&gt;DVB streaming media server&lt;/friendlyName&gt;  
    &lt;manufacturer&gt;Martin Emrih&lt;/manufacturer&gt;  
    &lt;manufacturerURL&gt;http://www.emmes-world.de&lt;/manufacturerURL&gt;  
    &lt;modelDescription&gt;Martins RTP-Server&lt;/modelDescription&gt;  
    &lt;modelName&gt;rtpserver&lt;/modelName&gt;  
    &lt;modelNumber&gt;rtpserver 0.0.2svn&lt;/modelNumber&gt;  
    &lt;modelURL&gt;http://www.emmes-world.de&lt;/modelURL&gt;  
    &lt;serialNumber&gt;00123456789&lt;/serialNumber&gt;  
    &lt;presentationURL&gt;http://192.168.80.2:10080&lt;/presentationURL&gt;  
    &lt;UDN&gt;uuid:a40777e1-385a-4b47-8f60-295f71aa02b&lt;/UDN&gt;  
    &lt;dlna:X_DLNADOC&gt;DMS-1.00&lt;/dlna:X_DLNADOC&gt;  
    &lt;serviceList&gt; 
      &lt;service&gt; 
        &lt;serviceType&gt;urn:schemas-upnp-org:service:ConnectionManager:1&lt;/serviceType&gt;  
        &lt;serviceId&gt;urn:upnp-org:serviceId:ConnectionManager&lt;/serviceId&gt;  
        &lt;SCPDURL&gt;http://192.168.80.2:10080/volatile/cmsservie.xml&lt;/SCPDURL&gt;  
        &lt;controlURL&gt;/volatile/cmscontrol&lt;/controlURL&gt;  
        &lt;eventSubURL&gt;/volatile/cmsevent&lt;/eventSubURL&gt; 
      &lt;/service&gt;  
      &lt;service&gt; 
        &lt;serviceType&gt;urn:schemas-upnp-org:service:ContentDiretory:1&lt;/serviceType&gt;  
        &lt;serviceId&gt;urn:upnp-org:serviceId:ContentDiretory&lt;/serviceId&gt;  
        &lt;SCPDURL&gt;http://192.168.80.2:10080/volatile/cdsservice.xml&lt;/SCPDURL&gt;  
        &lt;controlURL&gt;/volatile/cdscontrol&lt;/controlURL&gt;  
        &lt;eventSubURL&gt;/volatile/cdsevent&lt;/eventSubURL&gt; 
      &lt;/service&gt; 
    &lt;/serviceList&gt; 
  &lt;/device&gt; 
&lt;/root&gt;
</code></pre>
<p>服务描述包含可用的操作（即可以远程调用的方法）和服务状态的变量列表。下面是从一个服务描述（UPnP AV媒体服务器的内容目录服务）中摘录的例子，有些动作/服务变量被删除：</p>
<pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot; standalone=&quot;no&quot; ?&gt;
&lt;scpd xmlns=&quot;urn:schemas-upnp-org:service-1-0&quot;&gt;  
  &lt;speVersion&gt; 
    &lt;major&gt;1&lt;/major&gt;
    &lt;minor&gt;0&lt;/minor&gt; 
  &lt;/speVersion&gt;  
  &lt;actionList&gt; 
    &lt;action&gt; 
      &lt;name&gt;GetSortCapabilities&lt;/name&gt;  
      &lt;argumentList&gt; 
        &lt;argument&gt; 
          &lt;name&gt;SortCaps&lt;/name&gt;
          &lt;direction&gt;out&lt;/direction&gt;
          &lt;relatedStateVariable&gt;SortCapabilities&lt;/relatedStateVariable&gt; 
        &lt;/argument&gt; 
      &lt;/argumentList&gt; 
    &lt;/action&gt;  
    &lt;action&gt; 
      &lt;name&gt;GetSystemUpdateID&lt;/name&gt;  
      &lt;argumentList&gt; 
        &lt;argument&gt; 
          &lt;name&gt;Id&lt;/name&gt;
          &lt;direction&gt;out&lt;/diretion&gt;
          &lt;relatedStateVariable&gt;SystemUpdateID&lt;/relatedStateVariable&gt; 
        &lt;/argument&gt; 
      &lt;/argumentList&gt; 
    &lt;/action&gt; 
  &lt;/actionList&gt;  
  &lt;serviceStateTable&gt; 
    &lt;stateVariable sendEvents=&quot;no&quot;&gt; 
      &lt;name&gt;SearhCapabilities&lt;/name&gt;
      &lt;dataType&gt;string&lt;/dataType&gt; 
    &lt;/stateVariable&gt;  
    &lt;stateVariable sendEvents=&quot;no&quot;&gt; 
      &lt;name&gt;SortCapabilities&lt;/name&gt;
      &lt;dataType&gt;string&lt;/dataType&gt; 
    &lt;/stateVariable&gt;  
    &lt;stateVariable sendEvents=&quot;yes&quot;&gt; 
      &lt;name&gt;SystemUpdateID&lt;/name&gt;
      &lt;dataType&gt;ui4&lt;/dataType&gt;
      &lt;defaultValue&gt;0&lt;/defaultValue&gt; 
    &lt;/stateVariable&gt; 
  &lt;/serviceStateTable&gt; 
&lt;/scpd&gt;
</code></pre>
<h4 id="u63A7_u5236"><a href="#u63A7_u5236" class="headerlink" title="控制"></a>控制</h4><p>当<em>控制点</em>已经发现<em>设备</em>并且读取其描述之后，它就可以调用由该<em>设备</em>提供的操作了。动作调用使用SOAP远程过程调用完成。调用方使用<code>HTTP POST</code>方式发送<code>SOAP</code>请求到服务的<strong>controlURL</strong>。如果该请求是有效的，<em>设备</em>执行相应的动作，并返回响应。如果执行时间需要超过30秒，该服务要求即刻返回，并在执行完成时发送一个事件。</p>
<p>UPnP标准曾经纳入一个机制来直接查询状态变量，但现在该方式已经<strong>过时</strong>。</p>
<p>一个<em>服务</em>提供的操作通常使用形如<strong>&lt;服务&gt;:&lt;操作&gt;</strong>或<strong>&lt;服务缩写&gt;:&lt;操作&gt;</strong>的方式引用，如<code>CMS:GetProtocolInfo</code>表示连接管理(<code>ConnectionManager</code>)的<code>GetProtocolInfo</code>操作。</p>
<h4 id="u4E8B_u4EF6"><a href="#u4E8B_u4EF6" class="headerlink" title="事件"></a>事件</h4><p>作为不断轮询查看<em>服务</em>状态的代替方式，一个<em>控制点</em>可以订阅由<em>服务</em>发出的事件。UPnP使用<em>*通用事件通知结构</em>（<code>GENA</code>）来发出通知。 该协议基于HTTP，但为不同的消息类型引入了新方法。</p>
<p>对事件感兴趣的客户端可以发送订阅请求到<em>服务</em>的<code>eventSubURL</code>。订阅包括一个回调URL和订阅时间。注意，没有办法将订阅限制到<em>服务状态变量</em>的特定子集。该<em>服务</em>使用一个唯一标识的订阅ID进行相应，并发送第一个、包括所有事件状态变量的<em>初始化</em>事件。之后（直到订阅到期或客户取消订阅），每当一个变量发生变化时，该<em>服务</em>发送相应事件通知给每一个订阅用户。</p>
<h3 id="UPnP_AV"><a href="#UPnP_AV" class="headerlink" title="UPnP AV"></a>UPnP AV</h3><p>UPnP AV基础设施说明了一组UPnP设备的配置文件和它们之间的相互作用，以帮助在设备之间传输媒体内容（音频，视频，图像，…）。这些设备配置文件是：</p>
<ul>
<li>一个典型媒体流来源的<strong>媒体服务器</strong>。例如，一个网络存储设备通过UPnP AV发布其包含的媒体文件。英特尔提供了一套有帮助的设计指导原则。</li>
<li>一个接收媒体以进行播放的<strong>媒体渲染器</strong>。这可以是一个联网的电视机、音频播放器或机顶盒。</li>
<li>一个<strong>控制点</strong>，它能够发现其它UPnP AV设备，可从服务器匹配与现有渲染器相符的媒体资源以及控制媒体的传送。它可以被认为是一个网络远程控制。</li>
</ul>
<p>设备配置文件可以组合在一起，例如媒体渲染器和控制点可能在一台网络电视中，用户可以在屏幕上选择可用的内容并播放。</p>
<h4 id="u5A92_u4F53_u670D_u52A1_u5668"><a href="#u5A92_u4F53_u670D_u52A1_u5668" class="headerlink" title="媒体服务器"></a>媒体服务器</h4><p>媒体服务器提供两到三个<em>服务</em>：一个内容目录用于访问可用内容项的列表，一个连接管理服务用于启动或停止媒体传输，以及一个AV传输服务用于控制单独媒体传输。由于大部分流行的传输方法（<strong>HTTP</strong>或<strong>RTSP/RTP</strong>）都自带传输管理，一些连接管理操作和完整AV传输服务都是可选的。</p>
<h4 id="u5A92_u4F53_u6E32_u67D3_u5668"><a href="#u5A92_u4F53_u6E32_u67D3_u5668" class="headerlink" title="媒体渲染器"></a>媒体渲染器</h4><p>媒体渲染器也提供了两个到三个<em>服务</em>：一个渲染控制服务用于影响其自身呈现（例如音量控制，亮度，对比度），一个连接管理服务以及一个可选的AV传输服务。</p>
<h4 id="u63A7_u5236_u70B9"><a href="#u63A7_u5236_u70B9" class="headerlink" title="控制点"></a>控制点</h4><p>控制点将前两者结合起来，它查找可用的媒体服务器和渲染器并检索内容目录以显示给用户。控制点匹配源和接收器支持的协议与媒体格式，并<strong>仅</strong>显示可以顺利播放的组合。最后，它初始化并控制媒体传输。</p>
<h4 id="u5185_u5BB9_u76EE_u5F55"><a href="#u5185_u5BB9_u76EE_u5F55" class="headerlink" title="内容目录"></a>内容目录</h4><p>内容目录包含媒体服务器上所有可用媒体项目的引用，将它们排列在一个树结构中。控制点可以使用<code>CDS:Browse</code>动作来浏览内容目录，或使用<code>CDS:Search</code>动作搜索。可选地，内容目录甚至可以被控制点修改，例如：上传新的媒体到设备。</p>
<p>每个对象都<strong>至少必须</strong>具有一个唯一的ID，它的父对象的ID（根对象的ID必须为0，且其parentID为-1），一个标题和一个限制标志（如果标志设置为真，则对控制点来说，该对象是只读的）。派生类可能添加其他字段和属性。</p>
<p>对象类型都是从同一个基类类型（<code>object</code>）中继承。这里有大部分基本类型和一些派生类的例子：</p>
<ul>
<li><code>object.container</code>对应一个文件系统目录。它可以有子对象。必填字段为<strong>ID</strong>、<strong>名称</strong>。</li>
<li><code>object.item</code>是<strong>最基本</strong>的媒体项类型。所有其他媒体类型从这个继承。</li>
<li><code>object.item.audioItem</code>是一个通用的音频项目。添加了属性比如<em>流派</em>和<em>出版商</em>。</li>
<li><code>object.item.audioItem.musicTrack</code>指的是一个单一的音乐项目，如一张专辑中的一首歌。添加了属性如<em>艺术家</em>和<em>专辑</em>。</li>
</ul>
<p>一个<em>控制点</em>通过<code>CDS:Browse</code>方法访问内容目录，可以用这些参数影响结果：</p>
<ul>
<li><code>ObjectID</code>：开始位置</li>
<li><code>BrowseFlag</code>：<code>BrowseMetadata</code>和<code>BrowseDirectChildren</code>中的一个。前者仅返回关于所请求的对象的信息，而后者返回指定<code>ObjectID</code>的直接子对象。</li>
<li><code>Filter</code>：如果设置为<code>*</code>，所有必需的属性都会返回。可替代地，可以指定要返回的属性的列表。</li>
<li><code>StartingIndex</code>：对于<code>BrowseDirectChildren</code>来说，这是一个结果偏移量，例如分页获取对象信息。</li>
<li><code>RequestCount</code>：限制返回对象的数量。和<code>StartingIndex</code>一起使用，具有小屏幕的设备可以只获取能在当前屏幕上显示的对象的子集。</li>
<li><code>SortCriteria</code>：指定结果应如何进行排序。例如：<code>+upnp:album,+upnp:originalTrackNumber</code>。</li>
</ul>
<p>媒体服务器然后使用一个<code>DIDL-Lite</code>的XML文档返回所请求的内容对象。<code>DIDL-Lite</code>本身是在<strong>MPEG-21(ISO/IEC 21000)</strong>中定义的<em>数字项目声明语言</em>的一个子集，它把上面描述的对象结构转换成XML对象。</p>
<p>下面是一个示例DIDL-Lite XML文档：</p>
<pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;
&lt;DIDL-Lite xmlns=&quot;urn:schemas-upnp-org:metadata-1-0/DIDL-Lite/&quot;
           xmlns:d=&quot;http://purl.org/dc/elements/1.1/&quot;
           xmlns:dlna=&quot;urn:schemas-dlna-org:metadata-1-0&quot;
           xmlns:upnp=&quot;urn:schemas-upnp-org:metadata-1-0/upnp/&quot;&gt;  
  &lt;item id=&quot;3&quot; parentID=&quot;2&quot; restricted=&quot;1&quot;&gt; 
    &lt;d:title&gt;Das Erste&lt;/d:title&gt;  
    &lt;upnp:channelNr&gt;1&lt;/upnp:channelNr&gt;  
    &lt;upnp:channelName&gt;Das Erste&lt;/upnp:channelName&gt;  
    &lt;upnp:class&gt;object.item.videoItem.videoBroadcast&lt;/upnp:class&gt;  
    &lt;res bitrate=&quot;1875000&quot; protocolInfo=&quot;http-get:*:video/mpeg:DLNA.ORG_PN=MPEG_PS_PAL;DLNA.ORG_FLAGS=8D100000000000000000000000000000&quot;&gt;
      http://134.96.63.118:10080/192.168.80.1/tv/S19.2E-1-1101-28106.mpg?apid=102&amp;amp;audio=MP2&amp;amp;container=MPEGPS&amp;amp;ppid=101&amp;amp;video=MPEG2&amp;amp;vpid=101
    &lt;/res&gt;
    &lt;res protocolInfo=&quot;rtsp-rtp-udp:*:video/mpeg:DLNA.ORG_PN=MPEG_TS_SD_EU_ISO;DLNA.ORG_FLAGS=8D100000000000000000000000000000&quot;&gt;
      rtsp://134.96.63.118:10554/192.168.80.1/tv/S19.2E-1-1101-28106.mpg?apid=102&amp;amp;audio=MP2&amp;amp;container=MPEGTS&amp;amp;ppid=101&amp;amp;video=MPEG2&amp;amp;vpid=101
    &lt;/res&gt; 
  &lt;/item&gt;  
  &lt;item id=&quot;4&quot; parentID=&quot;2&quot; restricted=&quot;1&quot;&gt; 
    &lt;d:title&gt;ZDF&lt;/d:title&gt;  
    &lt;upnp:channelNr&gt;2&lt;/upnp:channelNr&gt;  
    &lt;upnp:channelName&gt;ZDF&lt;/upnp:channelName&gt;  
    &lt;upnp:class&gt;objet.item.videoItem.videoBroadcast&lt;/upnp:class&gt;  
    &lt;res bitrate=&quot;1875000&quot; protocolInfo=&quot;http-get:*:video/mpeg:DLNA.ORG_PN=MPEG_PS_PAL;DLNA.ORG_FLAGS=8D100000000000000000000000000000&quot;&gt;
      http://134.96.63.118:10080/192.168.80.1/tv/S19.2E-1-1079-28006.mpg?apid=120&amp;amp;audio=MP2&amp;amp;container=MPEGPS&amp;amp;ppid=110&amp;amp;video=MPEG2&amp;amp;vpid=110
    &lt;/res&gt;
    &lt;res protocolInfo=&quot;rtsp-rtp-udp:*:video/mpeg:DLNA.ORG_PN=MPEG_TS_SD_EU_ISO;DLNA.ORG_FLAGS=8D100000000000000000000000000000&quot;&gt;
      rtsp://134.96.63.118:10554/192.168.80.1/tv/S19.2E-1-1079-28006.mpg?apid=120&amp;amp;audio=MP2&amp;amp;container=MPEGTS&amp;amp;ppid=110&amp;amp;video=MPEG2&amp;amp;vpid=110
    &lt;/res&gt;
  &lt;/item&gt; 
&lt;/DIDL-Lite&gt;
</code></pre>
<h4 id="u5185_u5BB9_u8D44_u6E90"><a href="#u5185_u5BB9_u8D44_u6E90" class="headerlink" title="内容资源"></a>内容资源</h4><p>每个内容项的对象都包含一个或多个指向实际内容的<em>资源</em>。对于相同内容项的多个资源可以指向不同的可用传输，或者同一内容的不同表示（例如，一个附加的较小版本的照片，或者同一视频使用不同编解码器编码）。每个资源至少包含一个可以访问资源的URL，以及一个<code>protocolInfo</code>字符串，它是由四个字段组成：</p>
<ul>
<li><strong>协议</strong>：使用的传输协议：本项目中使用的两个协议是用于HTTP的<code>http-get</code>和用于RTP的<code>rtsp-rtp-udp</code>，还有可能用于设备内部连接的<code>internal</code>，用于IEEE1394链路的<code>iec61883</code>或供应商为其特定的运输已注册的ICANN域名。</li>
<li><strong>网络</strong>：HTTP或RTP中不需要，因此设置为<code>*</code>。</li>
<li><strong>内容格式</strong>：通常情况是内容的MIME类型，如<code>video/mpeg</code>或者<code>image/jpeg</code>。</li>
<li><strong>附加信息</strong>：可能包含有关该资源的详细信息。如果不需要，它被设置为<code>*</code>。</li>
</ul>
<h3 id="DLNA"><a href="#DLNA" class="headerlink" title="DLNA"></a>DLNA</h3><p>数字生活网络联盟（<code>DLNA</code>）是全球领先的消费娱乐厂商联盟。它的目标是让用户可以联网家庭娱乐设备并提供无缝的合作工作，只要设备带有DLNA CERTIFIED™标志，即使这些设备是来自不同的厂商。</p>
<p>DLNA实际上是UPnP AV组的继承人，基本上DLNA架构就是UPnP AV加上许多额外的规范和说明，所有设计都用于避免不同设备之间的兼容性问题。有一些较为明显的增加内容：</p>
<ul>
<li>更多的设备配置文件：DLNA不仅区分<strong>媒体服务器</strong>，<strong>媒体渲染器</strong>和<strong>控制点</strong>，还区分不同的设备类别，比如家庭网络设备（HND）或移动手持设备（MHD），以及不同的媒体类别（例如数字媒体播放器（DMP）或移动数字媒体服务器（M-DMS））。还有一种打印体系结构（建立在UPnP打印定义的上层）。通过这，单个设备的功能可以更彻底地指定。</li>
<li>DLNA媒体控制器（DMC）不仅基于传输协议与格式匹配内容和渲染，还基于标准化的DLNA媒体情景模式，后者指定了容器、编解码器甚至图像尺寸。这样就避免了很多兼容性问题，例如尝试在手机上播放1080p的视频内容。</li>
<li>强制传输、容器和编解码器：一个设备要被认证，必须至少支持HTTP传输和一组最小的媒体格式集合（包括MPEG 2视频，MP3音频，JPEG和LPCM）。DLNA甚至指定了媒体互操作单元（<code>MIU</code>），其本质上是一个转码器设备，用于使内容与其他设备兼容。</li>
<li>详细媒体传输规格：DLNA设备准则还规定了如何访问和传输的不能随机访问的内容，例如直播或者硬盘录像机上一个增长的记录。</li>
</ul>
<p>一个DLNA CERTIFIED™的设备，必须符合数百项要求，需要使用由DLNA向其成员提供的一种<strong>一致性测试工具</strong>（<code>CTT</code>）测试。DLNA的主页列出了超过1000种认证的设备，包括电视机，笔记本电脑（通常是指经过认证的DLNA软件），当然还有索尼的PlayStation 3视频游戏机。</p>
<p>尽管DLNA规定了需要在家庭网络直播（RTSP/RTP传输或调谐器管理）的所有内容，截至2008年年底，没有任何实现这些指导方针的设备投放市场。这可能是由于在认证过程这些功能是可选的，因而没有被CTT测试（它测试的大多只是强制性要求），另一个原因可能是RTP传输增加了开发难度。</p>
<p>除了约束或澄清现有的UPnP AV架构，DLNA准则主要在现有的协议和格式中添加了新的头部和字段。其座右铭是“<strong>分析并解释，或分析而忽视</strong>”，这意味着任何在交流中遇到的无法理解（例如：一个厂商特定的XML元素出现在DIDL-Lite文档中）或看起来畸形的信息，另一方应始终宽容地对待，并当做该元素从没有出现过。通过这种方式，可以扩充更多信息而不会干扰传统客户端。</p>
<h4 id="u6570_u636E_u53EF_u7528_u6027_u6A21_u578B"><a href="#u6570_u636E_u53EF_u7528_u6027_u6A21_u578B" class="headerlink" title="数据可用性模型"></a>数据可用性模型</h4><p>DLNA知道存储和直播内容之间不同的可用性属性，因而定义了统一的<strong>客户端数据可用性模型</strong>（<code>UCDAM</code>）来描述流边界和有效范围：</p>
<p><img src="/images/dlna/img-ucdam.png" alt="UCDAM"></p>
<ul>
<li>[`d_x`,`d_y`]是整个内容对象，有可能部分无法访问（例如用于直播的内容）。</li>
<li>[`s_0`,`s_N`]是内容源实际上能够传输的数据范围。对于存储在磁盘上的内容，通常情况下，[`d_x`,`d_y`] = [`s_0`,`s_N`]。对于现场直播的内容（无缓冲或磁盘记录），两者相等，并不断向前移动。基于这，DLNA分别绘制了固定`s_0`、`s_0`增长和固定`s_N`、`s_N`增长之间的区别。</li>
<li>[`r_0`,`r_N`]是可用于随机访问的范围。`r_0`等于`s_0`，对于可搜索内容`r_N`通常等于`s_N`。对于非随机访问的内容（某些容器只允许从头开始播放，例如索引损坏的AVI文件，或从特定的时间间隔，例如MPEG组的图片），`r_N`等于`s_0`。</li>
<li>[`d_0`,`d_N`]是内容接收者可访问的范围。如果它在本地缓冲该接收到的数据，则这个范围可能超过[`s_0`,`s_N`]。</li>
</ul>
<p>在此描述模型的基础上，DLNA准则规定了三种不同的数据可用性模型下的内容。在所有情况下，假定[`s_0`,`s_N`] = [`r_0`,`r_N`]。需要注意的是DLNA同时通过字节偏移和本地播放时间（<code>NPT</code>）描述寻址。</p>
<p><strong>完全随机访问数据可用性模型</strong><br>该模型适用于固定`s_0`，固定`s_N`的内容，其中完整的二进制内容始终是可查找的，如存储在磁盘上的内容（包括一个正在记录的增长的内容）。这里，客户端可以从服务器请求任意内容范围，只要该容器格式和使用的编解码器允许。</p>
<p><strong>受限的随机访问数据可用性模型（模式0）</strong><br>该模型适用于`s_0`增长的内容，诸如实时广播。这种情况下，寻址被限制到二进制内容的子范围，甚至有可能是单个时间点。</p>
<p><strong>受限的随机访问数据可用性模型（模式1）</strong><br>这是固定`s_0`的内容使用的模型。在DLNA准则给出的例子是当前正由媒体服务器编码的内容项。这种情况下，从开始时刻到编码器当前的工作点之间的内容是及时可用的，而仍然是待编码的部分则是不可用的。</p>
<h4 id="protocolInfo_u5B57_u6BB5"><a href="#protocolInfo_u5B57_u6BB5" class="headerlink" title="protocolInfo字段"></a>protocolInfo字段</h4><p>DLNA将内容目录资源的<code>protocolInfo</code>（参见2.6.5节）中的第四个字段作为一个逗号分隔的键-值对列表，用于提供有关资源的更详细的信息。可用的键有：</p>
<ul>
<li><code>DLNA.ORG_PN</code>字段指定内容的DLNA媒体资料。</li>
<li>转换指示符<code>DLNA.ORG_CI</code>指定内容是否已被重新编码。如果内容提供了多种资源，客户端可以用它来在通常具有最高质量的原始格式中寻找内容，只要客户端兼容相关格式。</li>
<li><code>DLNA.ORG_PS</code>列出了可用的额外的播放速度（超出正常的1X播放速度）来表示如快进或慢动作回放的支持。</li>
<li><code>DLNA.ORG_OP</code>指定寻址的能力。例如，资源支持通过字节便宜或本地播放时间偏移来寻址。</li>
<li><code>DLNA.ORG_MAXSP</code>表示对RTSP速度头的支持，以及其最大的值。</li>
<li><code>DLNA.ORG_FLAGS</code>是一个具有32个字符的十六进制字符串，其中含有几十个布尔标志。最重要的标志是<ul>
<li><code>sp</code>标志：如果为真，内容是发件人节奏的（服务器作为时钟源），因此，接收方不能承担控制传输速度的任务。</li>
<li>`s_0`增长和`s_N`增长：如果为真，内容的`s_0`（或`s_N`分别）边界随时间增加。</li>
<li><code>tm-s</code>, <code>tm-b</code>和<code>tm-i</code>：选择DLNA传输模式，<code>Streaming</code>（音频/视频内容实时前台传输）、<code>Background</code>（低优先级批量传输）和<code>Interactive</code>（尽力而为前台传输图像）中的一个。</li>
<li><code>http-stalling</code>指示该服务器是否允许客户端通过简单断开HTTP连接来暂停传输。</li>
</ul>
</li>
</ul>
<p>利用这些信息，接收器能够确定每个内容项具有的功能：可以按块获取内容或需要一个连续的传输？可以使用字节范围、甚至时间码进行随机访问？如果这些功能都可用，接收使用标准HTTP或RTSP头部指示其请求，否则如果需要的话，使用特殊的DLNA头部。</p>
<h4 id="HTTP_u5934"><a href="#HTTP_u5934" class="headerlink" title="HTTP头"></a>HTTP头</h4><p>一些新的HTTP头由DLNA引入，用于指定传输参数：</p>
<ul>
<li><p><code>contentFeatures.dlna.org</code>：无论何时，只要客户端发送GET或HEAD请求并且包含一个<code>getContentFeatures.dlna.org: 1</code>头部，服务器就会发送此参数。它包含了内容资源的第四个字段（DLNA的<code>protocolInfo</code>字段）。</p>
</li>
<li><p><code>availableSeekRange.dlna.org</code>：客户端通过发送GET或HEAD请求并包含<code>getAvailableSeekRange.dlna.org: 1</code>，可以请求一个给定内容项的当前可用寻址范围。服务器返回一个具有<code>availableSeekRange.dlna.org</code>报头的响应，该值指示数据可用性模式（见上文）以及以字节和/或NPT表示的可用寻址范围。例如值为<code>0 bytes=0-0</code>（受限的随机访问数据可用性模型，模式0，可能没有任何寻址范围），或<code>1 npt=00:00:00-00:08:31 bytes=0-204356823</code>（受限的随机访问数据可用性模式，模式1，在NPT和字节下都可以寻址）。</p>
</li>
<li><p><code>transferMode.dlna.org</code>：使用<code>transferMode.dlna.org</code>头部，客户端指定传输是流式，交互式或后台传输。然后服务器使用相同的头部在给定的传输模式进行响应，并为传输模式应用必要的QoS机制。为了向后兼容性（与以前版本的DLNA和非DLNA设备），省略了此头部则意味着使用流传输。</p>
</li>
<li><p><code>Range</code>和<code>timeSeekRange.dlna.org</code>：除了使用正常HTTP头<code>Range</code>获取字节寻址之外，DLNA还定义了<code>timeSeekRange.dlna.org</code>头，它用于实现使用NPT寻址。</p>
</li>
<li><p><code>PlaySpeed.dlna.org</code>：客户端发送这个头部来指定预期的播放速度。如果服务器发送相同的头部确认请求，之后它将发送播放时间被缩放过的内容（例如，通过加倍帧和减缓音频实现慢动作回放）。</p>
</li>
<li><p><code>realTimeInfo.dlna.org</code>：对于实时传输字符的内容（如直播），客户端和服务器可以在键值对中通信附加信息。当前唯一使用的键是<code>DLNA.ORG_TLAG</code>。如果它是一个有限数（正实数），它指定在当前时间（例如：当从调谐器硬件接收内容片段时）和它必须被发送到客户端的时间之间的用秒表示的时间差。如果超过此时间（因为客户端在此时间不接受它），服务器被允许删除数据以保持传输的实时特性。如果它是无限的，该标记被设置为<code>*</code>。</p>
</li>
</ul>
<h4 id="RTSP_u5934"><a href="#RTSP_u5934" class="headerlink" title="RTSP头"></a>RTSP头</h4><p>支持(<code>dlna.annouce</code>, …)功能列表可以通过客户端或服务器发出。它包含一个逗号分割的发送端点的功能列表，例如，<code>dlna annouce</code>表示服务器可以发送RTSP ANNOUNCE消息。</p>
<ul>
<li><p><code>Buffer-Info.dlna.org</code>：当服务器支持RTCP缓冲器充满报告时，这将在客户端的RTSP SETUP请求中发送，指示客户端缓冲字符。它包括去抖动缓冲器字节大小、编码数据缓冲器字节大小、接收缓冲器传送机构（去抖动缓冲区是立即将数据推送到编码数据缓冲器，还是基于数据包的时间标记）、以毫秒计算的接收机缓冲区大小。</p>
</li>
<li><p><code>WCT.dlna.org</code>：如果客户端设置为1，服务器必须添加挂钟时间样本到数据流。</p>
</li>
<li><p><code>Max-Prate.dlna.org</code>是由客户端发送以指示其最大传入分组速率。</p>
</li>
<li><p><code>Event-Type.dlna.org</code>在一个来自服务器的RTSP <strong>ANNOUNCE</strong>消息中指示事件。例如，如果到达流的结束时，服务器将其设置为2000。</p>
</li>
<li><p><code>Available-Range.dlna.org</code>由服务器在RTSP <strong>DESCRIBE</strong>响应中指示可用搜索范围（UCDAM `r_0`和`r_N`），类似于HTTP头<code>availableSeekRange</code>。</p>
</li>
<li><p><code>Predec-Buffer-Size.dlna.org</code>, <code>Initial-Buffering.dlna.org</code>由RTP流接收者指定需要的缓冲区大小。</p>
</li>
</ul>
<h3 id="u4F20_u8F93_u534F_u8BAE"><a href="#u4F20_u8F93_u534F_u8BAE" class="headerlink" title="传输协议"></a>传输协议</h3><h4 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h4><p>HTTP协议，大概占了大部分的互联网流量（除了可能的对等文件共享网络），想必不需要太多的介绍。它的简单和可扩展的头部结构，发送内容类型的独立性和其可靠性使其成为了家庭媒体网络最喜欢的传输协议。请求和响应任何传送的内容（<code>body</code>）之前都使用纯文本头部。请求的第一行指定了<em>请求方法</em>、资源和协议标识符（例如<code>HTTP/1.1</code>）。</p>
<p>请求示例：</p>
<pre><code class="http">GET /hello.txt HTTP/1.1
Host: www.example.org
</code></pre>
<p>和相应的响应：</p>
<pre><code class="http">HTTP/1.1 200 OK
Content-Length: 12
Connection: close
Content-Type: text/plain

Hello World!
</code></pre>
<p>基于TCP协议，该协议被设计用于尽力而为、可靠的顺序数据传输，HTTP它不会做任何实时的保证。对于经典的万维网，这当然不是必需的，但是对于流媒体应用，需要一定量的工作使HTTP同步。只要接收者保持足够大的缓冲器，对于存储内容的传输，如果由发送器和接收器之间的信道提供的净带宽高于内容被播放的数据速率，它就是适用的。</p>
<p>一旦超过了可用带宽，TCP的流量控制将变为不利条件。</p>
<p>在这种情况下，客户端将以较慢的速度接收数据（尽管仍然完整且按顺序），并且在不中断的情况下不再播放。为了减少这种问题，大部分播放器在开始播放前缓冲大量的数据，以弥补数据速率的下降。</p>
<p>HTTP的最大优点是，所发送的内容不需要知道信道特性，因为<strong>HTTP保证没有任何丢失</strong>。所以HTTP仍然是后台传输和非实时敏感数据传输的首选传输协议。</p>
<h4 id="RTSP/RTP"><a href="#RTSP/RTP" class="headerlink" title="RTSP/RTP"></a>RTSP/RTP</h4><p>相比之下，<strong>实时传输协议</strong>（<code>RTP</code>）和它的同伴协议<code>RTSP</code>和<code>RTCP</code>从底层向上都是为实时流媒体应用设计的。</p>
<p>RTP是承载实际数据的协议，它是基于<code>UDP</code>的。UDP本身既不负责数据的排序，也不负责定时。RTP为每个数据包增加了<strong>序列号</strong>，用于保持数据包有序以及检测丢失情况。另外，每个包都包含一个时间戳作为第一有效字节，用于同步目的，以及有效载荷类型，用于确定数据的类型（例如：MPEG视频或PCM音频）。当然，应用程序必须通过纠错方案或鲁棒解码器将协议的有损性质考虑在内。因为它是基于UDP的，所以它也可以用在<strong>多播</strong>环境中，当多个客户机希望同时接收相同的内容时使用。</p>
<p><code>RTSP</code>（<strong>实时流传输协议</strong>）用于会话管理，例如，确定内容的属性，并控制传输（设置，播放，暂停，停止，…）。它的语法被设计的与HTTP颇为相似，但不同之处在于它是有状态的，在同一个会话，连续的操作不需要在相同的TCP连接上发生。因此，它包括一个<strong>会话ID</strong>和一个<strong>序列号</strong>。</p>
<p>一个典型的RTSP会话通常从客户端的<code>OPTIONS</code>请求开始，服务器使用它支持方法的列表进行响应。接下来，客户端会发出针对特定内容项的<code>DESCRIBE</code>请求，服务器用带有描述的响应让客户了解期望的流的类型。然后，客户端发送一个<code>SETUP</code>请求，只有此时，服务器才会为此次会话分配资源，并发送<em>会话ID</em>给客户端，客户端现在必须在本次会话的每个后续请求中加入会话ID。现在，客户端可发出<code>PLAY</code>或<code>PAUSE</code>请求来控制传输。最后，当客户想要结束会话，它发送一个<code>TEARDOWN</code>请求。</p>
<p>而一个流会话正在播放（或记录）时，发送者和接收者可任选在<code>RTCP</code>（<strong>实时传输控制协议</strong>）交换连接信息。它主要用于发送或接收报告，例如通知另一方有关丢失的数据包，或给发送者一个缓冲区填充满的报告。</p>
<p>RTP一个问题仍然存在，那就是一端丢失检测（DPD）。因为在一个正在运行的会话过程中没有持久连接，服务器不能被动的检测到客户端刚离开网络，并只会继续发送RTP流。一个可能性是使用RTCP定期接收报告，如果在一定的时间内没有报告被接收到就结束会话。很多用户现在使用的另一种“变通”是保持RTSP连接打开，并每隔几秒钟发出一个带会话ID的无操作请求（例如<code>OPTIONS</code>）。</p>
<blockquote>
<p>例如 VLC或者MPlyaer</p>
</blockquote>
<p><strong>会话描述协议（SDP）</strong><br>会话描述协议按格式呈现一个确定会话的属性。它是一个纯文本格式，包括一个<em>有序的</em>键值对列表。</p>
<pre><code>v=0
o=- 1224610665 1224610665 IN IP4 192.168.80.2
s=Das Erste
c=IN IP4 224.0.1.2
t=0 0
m=video 0 RTP/AVP 33
a=control:rtsp://192.168.80.2:10554/video.mpg
</code></pre><p>本示例演示了一个多播视频传输。会话ID是1224610665，发起地址IP为IPv4网络中的192.168.80.2。流的会话名称是“Das Erste”，它是在没有预定义的UDP端口（0）的多播信道224.0.1.2上传输。它包含一个MPEG传送流（RTP有效载荷类型为33），并通过RTSP在<code>rtsp://192.168.80.2:10554/video.mpg</code>被控制。</p>
<p>DLNA定义了使用现有SDP头部的规则，以及一些新的SDP头，包括<code>a=contentFeatures.dlna.org</code>（又包含在内容项资源的第四个字段）和<code>a=scmsFlag.dlna.org</code>（指定版权和复制状态）。</p>
<p><strong>纠错</strong><br>由于RTP的有损性质，内容应该更健壮以抵抗传送误差，尤其使用是不可靠的（无线局域网）或共享的（家庭网络）的网络。这里有两种方法，前期增加冗余（前向纠错，FEC）或让接收者可以重新请求丢失的包（自动重新请求，ARQ）。</p>
<p><strong>FEC</strong> 通过在每个包中加入一定量的错误校正数据，当一个包丢失时，接收者仍然能够通过使用周围包的校正数据来重建它。显而易见的缺点是，传输总是需要更多的带宽，即使没有错误需要校正。但如果发生数据损坏，在客户端是能够迅速重建数据。这是有多余的带宽可用时的理想的有损通道。</p>
<p><strong>ARQ</strong> 给客户端在一个短的时间内从服务器请求丢失的包的拷贝的可能性。它的主要缺点是，重新传输时，接收者需要花费至少两倍流传输时间在加上服务器延迟时间来缓存重发的流。如果通过有损共享介质（如无线LAN）进行多播时，当许多客户端请求重传不同块的时候，它也不能很好地扩展。</p>
<p><strong>混合纠错模式</strong> 结合上面这两种方法，让FEC参数理想的适应当前信道特性。这个目标是为了使用FEC尽可能的避免许多重传，同时还具有重新请求不可校正的数据包的可能性。在这个项目中使用的<em>自适应混合纠错</em>（AHEC）属于这一类。</p>
<p>在任何情况下，流媒体格式应该适合在有损信道传输，即如果一些数据已损坏（当然是可见或可听的损失），流仍然应该是可解码的。MPEG-2视频编解码器是一个很好的例子，如果发生数据损坏，小块乱码可能会出现在屏幕上，但仍保持播放。</p>
<p>所有这些方案仅当信道带宽大于或等于内容所需的带宽时工作。如果不是这种情况，唯一的选择是降低内容的要求，例如，通过再量化MPEG视频（降低详细信息）或完全重新编码流（可能以较低的视频分辨率或更低的音频采样率）。</p>
<p>一个相当新的方法是可伸缩的（视频）编码方案，这需要物理层额外的支持。这种情况下，内容的较低质量版本以更健壮的方式发送（例如，在无线LAN中以较低的比特率），而所需的额外的用于重新建立更高质量版本的信息，与基本信息一起使用更高的比特率传输。每当客户端未能接收到高质量的组件时，它仍然可以显示低质量的版本。</p>
<h2 id="u7ED3_u6784"><a href="#u7ED3_u6784" class="headerlink" title="结构"></a>结构</h2><p>本项目的一个原理是利用现有的标准，最大化与市场上现有的和即将推出的设备的互操作性。DLNA媒体服务器架构提供一切必要的东西，包括设备发现，内容枚举和媒体传输。DLNA/UPnP AV体系结构使用现有的互联网标准，例如HTTP，SOAP和XML构建的。</p>
<p style="text-align:center"><br>  <img src="/images/dlna/img-rtpserver.png"><br>  </p><p style="text-align:center"><code>rtpserver</code>使用的协议和标准概述。</p><br><p></p>

<p>由此产生的媒体服务器样机，目前仅仅被命名为<code>rtpserver</code>，是与UPnP AV和DLNA兼容的，运行在<code>GNU/Linux</code>操作系统上。它通过作为DLNA内容项的调谐器后端接收广播频道，并将它们提供给UPnP AV或DLNA客户端。视频流可通过HTTP或者RTSP/RTP传送。如果有必要，流将被转化成所需要的格式（再复用或转码）。</p>
<p style="text-align:center"><br>  <img src="/images/dlna/img-server-arch.png"><br>  </p><p style="text-align:center"><code>rtpserver</code>架构概述</p><br><p></p>

<h3 id="u6D41_u5904_u7406"><a href="#u6D41_u5904_u7406" class="headerlink" title="流处理"></a>流处理</h3><p>由于<code>rtpserver</code>在未来可能会支持更多的流类型而不仅仅DVB MPEG传输流，其流处理采用模块化设计，借鉴了著名的Unix哲学：“<strong>做一件事，把它做好</strong>”。流在由源，多个转换器（同时作为源和接收器）和接收器组成的管道中被处理。管道元素可以从源中动态增加或删除（允许例如多客户端共享一个单独的DVB-S调谐器只要他们在相同的转发渠道观察信道）。</p>
<p>每个源都在使用有效载荷类型和根据所述有效载荷类型的额外识别信息标记的离散块中向下发送数据。接收器在任何方式下都不延迟他们的源，因此大多数转换器可以在一个额外的线程中异步处理数据。</p>
<p>每个源产生一个特定类型的输出，在离散块中发送下来，以适应任何细分负载要求。它通过负载类型、容器类型和可选的多用途ID标示。<em>容器类型</em>描述了数据所使用的容器格式（如AVI，MKV，MPEG-PS），<em>有效载荷类型</em>描述来源在每个块中发送了什么（例如，一个MPEG传输流数据包，一个MPEG PS数据包，或者原始的、未对齐数据）。</p>
<h4 id="u6E90"><a href="#u6E90" class="headerlink" title="源"></a>源</h4><p>每个源类型包括一个内容项目类，它代表了这个源可以提供的内容项，一个<em>SourceProvider</em>，用于为一个给定内容项目创建源对象的类，以及源类本身，用于提供数据。</p>
<p><strong>VDRSource</strong><br>如上所述，<code>rtpserver</code>可通过一个正在运行的带<code>streamdev</code>服务器的VDR访问DVB硬件。甚至即使VDR和<code>rtpserver</code>运行在两个不同的、联网的计算机上也是可行的，但不建议这样做。</p>
<p>这种方法有几个优点：</p>
<ul>
<li>可用的DVB硬件可以在VDR本身和可能的多个<code>rtpserver</code>实例之间共享。</li>
<li>直接调整DVB硬件和管理多个卡片的繁琐的任务就留给了VDR。</li>
<li>VDR提供一个信道的列表，因此从<code>rtpserver</code>的信道扫描是没有必要的。</li>
</ul>
<p>一个小缺点是初始化和开始流媒体会话之间的延迟略有增加。</p>
<p>在启动时，<code>VDRSourceProvider</code>将会从VDR获取频道列表。VDR提供了一个名为<code>SVDRP</code>的简单的、基于文本的网络协议。在连接到SVDRP端口并发送<code>LSTC</code>（LiST频道）命令后，VDR就会发送可用信道列表：</p>
<pre><code>&gt; LSTC
&lt; 220 sauron SVDRP VideoDiskRecorder 1.6.0-1; Fri Apr 24 19:30:39 2009
&lt; 250-1 Das Erste;ARD:11837:hC34:S19.2E:27500:101:102=deu,103=2ch;106=dd:104:0:28106:1:1101:0
&lt; 250-2 ZDF;ZDFvision:11954:hC34:S19.2E:27500:110:120=deu,121=2ch;125=dd:130:0:28006:1:1079:0
&lt; 250-3 ProSieben;ProSiebenSat.1:12544:hC56:S19.2E:22000:511:512=deu;515=deu:33:0:17501:1:1107:0
&lt; 221 sauron closing connetion
</code></pre><p>这个列表包含频道号和名称、调谐参数（频率，码元速率，FEC比率，…）以及流的PID。每个频道线路都被翻译成用于内容目录的内容项。</p>
<p>当一个通道被用于流传输时，<code>VDRSource</code>通过HTTP连接到配置的VDR实例，并开始将从VDR收到的数据推送到所有连接的接收器。如果多个客户端请求相同的内容，通常该内容的现有<code>VDRSource</code>对象会被重复使用，因此，对于相同内容的多个流会话仅使用一个到VDR的连接。一个<code>VDRSource</code>能够提供MPEG传输流、打包的基本流、或者针对音频源的基本流负载。</p>
<p>对于电视数据流来说，将选择MPEG流传输。VDR通常会提供完整的SI流，包括PAT/PMI、视频、音频、图文电视和PCR PID。</p>
<p><strong>DVBStreamSource</strong><br>这个源使用命令行工具<code>dvbstream</code>从DVB设备读取。再次说明，多个并发客户端对同一个频道的多个传输请求中，DVBStreamSource对象将被重复利用，而不是相同的频率下的不同的频道。</p>
<p>频道列表从和VDR使用的格式相同的文件中解析，它类似于上面的例子。</p>
<p><strong>FileSource</strong><br>该对象读取本地文件，并将其不变的发送到管道中。它存在的主要目的是将DLNA测试媒体流发送给<strong>兼容性测试工具</strong>（参见4.5.1节），但也可以用来播放音乐文件。</p>
<blockquote>
<p>因为内容目录常驻内存并且每次服务器启动时都会重新生成，因此这种方式也不适用于提供一个非常大的音乐列表。</p>
</blockquote>
<h4 id="u8F6C_u6362_u5668"><a href="#u8F6C_u6362_u5668" class="headerlink" title="转换器"></a>转换器</h4><p>因为并非每个接收器或客户端都可以支持源内容的格式，<code>rtpserver</code>提供了许多转换器用于按照一定的方式修改该数据流。每一个转换器通常只做一种特定的工作，因而它们可以被按一定顺序放置到更复杂的任务中。</p>
<p><strong>MPEGTSPacketizer</strong><br>它MPEG传送流分组报文头上锁定自身，并向下发送单个MPEG TS报文。它不会对输入数据的排列或完整性做任何假设。如果同步丢失，所有数据都被丢弃，直到同步恢复。</p>
<p><strong>MPEGTStoPESExtractor</strong><br>将传入的传输流数据包重组为单个打包的基本流。</p>
<p><strong>MPEGPEStoESExtractor</strong><br>从一个打包的基本流中提取一个特定的基本流。</p>
<p><strong>MPEGAudioDecoder</strong><br>将MP2/3音频基本流解码为立体声LPCM音频流。这主要是用于不直接支持MPEG2音频的客户端。</p>
<blockquote>
<p>这个转换器是为Terrater Noxon2Audio流媒体广播客户端所写的，该客户端只支持MP3音频，但不支持MP2。</p>
</blockquote>
<p><strong>MPEGTStoPSReplex</strong><br>复用MPEG传送流到MPEG程序流。它基本上是一个C++包装的<code>replex</code>工具，从传输流中提取一组给定的PID。</p>
<p><code>replex</code>没有被设计于在一个实时流上工作，它需要一个大容量的缓冲（约6MB）来工作。它也不能在任何频道上工作。</p>
<blockquote>
<p>一个例子是它不能在德国Pro7频道上工作。</p>
</blockquote>
<p>不幸的是，这个转换器是使索尼的PS3进行电视直播的唯一途径，因为PS3不支持MPEG传输流。请注意，即使有这样的再复用器，PS3同步仍有问题，导致偶尔的丢帧和音频/视频不同步。有趣的是，当首先保存到磁盘，然后使用<code>FileSource</code>服务时，直播时候出现上述效果的相同流将表现完美。这说明上述问题是由PS3的缓冲器空运行造成的，到目前为止没有发现解决方案。</p>
<p><strong>LiveBuffer</strong><br>许多HTTP流客户端在开始渲染之前，都会填充自己的本地缓冲区，直到缓冲区上溢。之后他们就暂停HTTP连接，读取数据一直到缓冲区下界，然后开始获取下一个数据块。由于这种非一致的行为，一个<code>LiveBuffer</code>元件被插入到所有涉及实时内容的HTTP会话管道中。它从传出接收器中分离输入流以消除短暂的HTTP连接暂停的情况。它也可以延迟传输，直到缓冲填充水平达到一个配置的值，以保持一定的缓冲储备，如果客户端需要快速读取数据，就把它作为输入源。</p>
<h4 id="u63A5_u6536_u5668"><a href="#u63A5_u6536_u5668" class="headerlink" title="接收器"></a>接收器</h4><p>对于每一种传输协议，都有一个单独的接收器可用。要了解会话管理的细节请查看第3.2节。</p>
<p><strong>RTPSink</strong><br>通过RTP或UDP发送传入数据到客户端或者多播频道。DVB-IPI建议，一个MPEG传输流，应使RTP时间戳适应于流的PCR，并将7个TS包放在一起成为一个RTP包。下图显示了一个例子。</p>
<p style="text-align:center"><br>  <img src="/images/dlna/img-stream-flow.png"><br>  </p><p style="text-align:center">MPEG传输流从源到接收器之间的的流动</p><br><p></p>

<p>尚未包含对DLNA定义的<code>vnd.dlna.mpeg-tts</code>有效载荷类型（它在每个188字节的TS包前面增加了一个32位的时间戳）的支持。</p>
<blockquote>
<p>没有渲染终端支持这种格式，相关文档只在短期可用。</p>
</blockquote>
<p><strong>HTTPStreamingSession</strong><br>HTTP会话对象的一部分是接收器部件。当客户端为内容项发送一个有效的HTTP请求时，它将自己附加到管道的端部，并将数据发送到客户端。</p>
<h3 id="u4F1A_u8BDD_u7BA1_u7406"><a href="#u4F1A_u8BDD_u7BA1_u7406" class="headerlink" title="会话管理"></a>会话管理</h3><p>对于由客户端发起的每个流过程，都有一个会话对象保留所有与流相关的状态。虽然这对HTTP相当容易，但当信号和实际数据绑在一起，RTSP和/或组播流就更加复杂。</p>
<h4 id="HTTP_u4F1A_u8BDD"><a href="#HTTP_u4F1A_u8BDD" class="headerlink" title="HTTP会话"></a>HTTP会话</h4><p>对于HTTP，会话开始于传入的<strong>HTTP GET</strong>请求，当连接由任一侧终止时结束。在解析传入的GET请求后，<code>HTTPServer</code>实例询问每个注册的<code>HttpHandler</code>来处理请求。如果这是一个有效的指向流媒体对象的URL，会话注册表将创建一个新的<code>HTTPStreamingSession</code>对象并在它上面处理连接。该<code>HTTPStreamingSession</code>解析报头、创建源对象和转换管道，并开始流传输。因次<code>HTTPStreamingSession</code>不仅是会话对象，还是管道接收器。</p>
<h4 id="RTSP/RTP_u4F1A_u8BDD"><a href="#RTSP/RTP_u4F1A_u8BDD" class="headerlink" title="RTSP/RTP会话"></a>RTSP/RTP会话</h4><p>对于RTSP会话，一个<code>RTSPStreamingSession</code>对象在客户端的<code>SETUP</code>请求时创建。根据传输协商，一个<code>RTPUnicastSession</code>对象或<code>RTPMulticastSession</code>对象被创建，并产生一个会话ID。这个ID被发送回客户端，并从现在开始引用该会话。客户端现在可以关闭RTSP连接，并在新连接上就本次会话（播放，暂停，拆除，…）发送后续请求。只有当客户端为该会话发送<code>TEARDOWN</code>请求，该会话资源才会被释放，且会话ID不再有效。</p>
<p>这里，会话对象（<code>RTSPStreamingSession</code>）从接收器对象（<code>RTPUnicastSession/RTPMulticastSession</code>）中分隔。这对于多播会话是必要的，在多播中，多个客户端可能同时请求非常相同的频道。<code>StreamingSessionRegistry</code>跟踪每个组播会话订阅用户的数量，只有当最后一个客户端断开连接时才销毁它。</p>
<h2 id="u5B9E_u73B0"><a href="#u5B9E_u73B0" class="headerlink" title="实现"></a>实现</h2><p>本项目的核心是实现一个可以在不变的DLNA客户端上直播的媒体服务器工作原型，以及一个带RTP支持的媒体渲染器原型。在<code>rtpserver</code>开发之初，需要一个UPnP库。有几个免费的UPnP框架可供选择：</p>
<ul>
<li><p><code>libupnp</code>：基于原始的英特尔<code>Linux SDK</code>的C库。</p>
<blockquote>
<p><a href="http://pupnp.sourceforge.net" target="_blank" rel="external">http://pupnp.sourceforge.net</a></p>
</blockquote>
</li>
<li><p><code>libgupnp</code>：面向对象的C库，基于<code>GObject</code>、<code>glib</code>。</p>
<blockquote>
<p><a href="http://www.gupnp.org" target="_blank" rel="external">http://www.gupnp.org</a></p>
</blockquote>
</li>
<li><p><code>coherence</code>：用Python编写的UPnP框架。</p>
<blockquote>
<p><a href="http://www.coherence.beebits.net" target="_blank" rel="external">http://www.coherence.beebits.net</a></p>
</blockquote>
</li>
<li><p><code>libdlna</code>：C库，提供了DLNA媒体配置文件的支持。依赖于<code>libupnp</code>。</p>
<blockquote>
<p><a href="http://libdlna.geekbox.org" target="_blank" rel="external">http://libdlna.geekbox.org</a></p>
</blockquote>
</li>
</ul>
<p>一开始使用<code>libupnp</code>，但很快可以发现一个原生C++库将有许多优点。<code>libupnp</code>自身对<strong>POSIX线程</strong>的使用经常与<code>rtpserver</code>冲突，所以UPnP框架中越来越多的部分用C++重写了。这就不可避免地导致了一个新的名为<code>libupnp++</code>的原生C++ UPnP库产生。</p>
<h3 id="libupnp++"><a href="#libupnp++" class="headerlink" title="libupnp++"></a>libupnp++</h3><p>在为<code>rtpserver</code>重写的UPnP组件变得越来越大之后，他们被分装到一个独立的库中，名叫<code>libupnp++</code>。不久后，<code>libupnp++</code>包括了媒体服务器需要的所有必要功能，对<code>libupnp</code>的依赖被删除。</p>
<p><code>libupnp++</code>包含一个HTTP Web服务器，为生成XML描述文档提供服务。它还处理传入的SOAP调用。开发人员可以实现<code>HttpHandler</code>接口来支持自己的网址（如流媒体或自己的文件），或者使用<code>UPNPServerVirtualDirs</code>对象来支持内存中的静态项目。</p>
<p>内置的<strong>GENA</strong>服务器（和<code>UPNPService</code>基类一起）处理事件的订阅和通知。该SSDP服务器自动通告新的和消失的<em>设备</em>与<em>服务</em>。</p>
<p>所有的服务都在后台线程启动，因此主应用程序既没有运行一个特殊的主循环也不做任何定期调用。</p>
<p>它也包括所有媒体服务器必须的<em>服务</em>（内容目录和的连接管理），以及内容容器与项目的基类。计划支持<em>控制点</em>和<em>嵌入式设备</em>，但目前尚不可用。</p>
<h4 id="u8981_u6C42"><a href="#u8981_u6C42" class="headerlink" title="要求"></a>要求</h4><p><code>libupnp++</code>依赖于：</p>
<ul>
<li>用于多线程的GNU通用C++。</li>
<li>Apache Xerces-C 2.8，用于解析/生成XML。</li>
<li><code>uuid</code>用于生成UUID。</li>
<li><code>libdlna</code>（可选）对媒体文件进行分类。</li>
<li><code>libmhash</code>使用MD5哈希表从任意的路径生成短网址。</li>
</ul>
<h3 id="rtpserver"><a href="#rtpserver" class="headerlink" title="rtpserver"></a>rtpserver</h3><p><code>rtpserver</code>是UPnP媒体服务器。虽然第一个目标是通过RTP在电视上看直播，它使用模块化方式构建，以在未来添加更多功能。</p>
<h4 id="u8981_u6C42-1"><a href="#u8981_u6C42-1" class="headerlink" title="要求"></a>要求</h4><p><strong>硬件</strong><br>一个<code>rtpserver</code>安装需要约10MB硬盘空间，需要256MB RAM和500MHz处理器处理未转换的DVB流数据。如果客户端需要实时再复用MPEG程序流，推荐使用1GHz的CPU。</p>
<p><strong>操作系统</strong><br>目前仅支持Linux。如果VDR实例（见下文）在网络上可用，移植<code>rtpserver</code>到BSD、MacOS X或Windows是可能的，但目前还没有计划这样做（反正目前机顶盒嵌入式系统大多数都运行Linux）。最优的Linux发行版是Ubuntu8.10，但如果下面的软件要求满足，其他系统也应该可以工作。</p>
<p><strong>软件</strong><br><code>rtpserver</code>需要以下库：</p>
<ul>
<li><code>libupnp++</code>（参见4.1节）</li>
<li><code>libccrtp-ahec</code>（提供高级混合纠错）或<code>libccrtp</code>，用于RTP支持</li>
<li>GNU通用C++（<code>libcommoncpp2</code>）</li>
<li><code>libconfig++</code>，用于配置文件</li>
<li><code>libmad</code>（可选）用于解码MP2音频为LPCM</li>
<li><code>libdlna</code>（可选）用于识别存储媒体文件的DLNA媒体配置。</li>
<li><code>uuid</code></li>
</ul>
<h3 id="u793A_u4F8B_u8BBE_u7F6E"><a href="#u793A_u4F8B_u8BBE_u7F6E" class="headerlink" title="示例设置"></a>示例设置</h3><p>示例设置成功地在2009年的<strong>CeBIT博览会</strong>上展示，它由以下几部分组成：</p>
<ul>
<li><strong>媒体服务器</strong>：基于Atom的英特尔HTPC，运行Ubuntu 8.10和<code>rtpserver</code>。它可具有各种调谐器，包括一个DVB-S PCI卡或DVB-T USB加密狗。调谐后端则使用VDR。</li>
<li><strong>媒体渲染器</strong>：基于Atom的英特尔HTPC，运行Ubuntu 8.10和Jochen Grun写的媒体渲染器。解码在一个全功能的DVB-S卡中完成。</li>
<li><strong>媒体播放器</strong>：索尼的PlayStation III游戏机。虽然只支持HTTP传输，但它表现出了<code>rtpserver</code>和DLNA硬件设备之间的互通性，并引人注目。</li>
<li><strong>控制点</strong>：苹果iPhone 3G，运行<code>PlugPlayer</code>，一个UPnP AV控制点应用。</li>
<li><strong>网络</strong>：使用普通的用于家庭网络结点的无线路由器，包括一个小的以太网交换机和一个DHCP服务器。除了iPhone外的所有设备都通过802.3以太网连接。</li>
</ul>
<p>示例展示了使用RTP协议直播而不是HTTP协议的巨大优势：由于HTTP的缓存要求，PS3需要近10秒才开始播放，但基于RTP的媒体渲染器能够在频道之间几乎瞬间切换，就像它是来自一个传统DVB机顶盒一样。</p>
<h3 id="u4F7F_u7528_u6848_u4F8B_uFF1A_u901A_u8FC7RTSP/RTP_u8FDB_u884C_u6D41_u5A92_u4F53_u7535_u89C6_u76F4_u64AD"><a href="#u4F7F_u7528_u6848_u4F8B_uFF1A_u901A_u8FC7RTSP/RTP_u8FDB_u884C_u6D41_u5A92_u4F53_u7535_u89C6_u76F4_u64AD" class="headerlink" title="使用案例：通过RTSP/RTP进行流媒体电视直播"></a>使用案例：通过RTSP/RTP进行流媒体电视直播</h3><p>这是当用户从媒体渲染器的控制点开始电视台播放时发生的情况。</p>
<h4 id="u8BBE_u5907_u542F_u52A8_u548C_u53D1_u73B0"><a href="#u8BBE_u5907_u542F_u52A8_u548C_u53D1_u73B0" class="headerlink" title="设备启动和发现"></a>设备启动和发现</h4><p>在启动时，所有的设备都将从DHCP服务器获取IP地址。UPnP<em>设备</em>就会成为可被发现的并通过SSDP宣布它们自己。启动后，<code>rtpserver</code>将扫描配置的媒体文件夹中的媒体文件，并将它们映射到内容目录。在DVB源中查询可用频道，并将它们也插入到内容目录。<code>rtpserver</code>对电视和广播电台进行了区分，并把它们排序到两个单独的内容容器中。</p>
<h4 id="u5185_u5BB9_u53D1_u73B0"><a href="#u5185_u5BB9_u53D1_u73B0" class="headerlink" title="内容发现"></a>内容发现</h4><p>控制点通过发出SOAP请求触发媒体服务器的<code>ContentDirectory::Browse()</code>操作，来检索媒体服务器的内容目录。这通常发生在点播，即无论何时用户在内容项目列表中滚动或进入子目录，就从媒体服务器的内容目录获取新的可见的内容对象。<code>rtpserver</code>的每个内容项代表一个有两个<em>资源</em>的广播频道，一个用于HTTP传输，另一个用于RTSP/RTP。</p>
<h4 id="u4F1A_u8BDD_u521D_u59CB_u5316"><a href="#u4F1A_u8BDD_u521D_u59CB_u5316" class="headerlink" title="会话初始化"></a>会话初始化</h4><p>用户通常不仅选择要播放的内容，还选择要显示的内容的渲染器。控制点使用<code>ConnectionManager::GetProtocolInfo()</code>操作为一个可能的协议与格式列表查询所选择的媒体渲染器，以查看渲染器实际上是否能够显示所选择的内容。这里使用的媒体渲染器支持这些协议：</p>
<pre><code>rtsp-rtp-udp:*:video/mpeg2:,rtsp-rtp-udp:*:video/mpeg:
</code></pre><p>在这种情况下，这组支持的协议和给定电视台提供的资源之间的交点就只有一个资源。现在，控制点将通过媒体渲染器提供的<code>AVTransport::SetAVTransportURI()</code>操作发送资源，来初始化播放。然后调用<code>AVTransport::Play()</code>方法来启动播放。</p>
<p>对于HTTP和RTSP/RTP，运输配置都在UPnP的SOAP框架之外完成。对于RTSP/RTP传输，媒体渲染器首先使用RTSP<code>OPTIONS</code>方法获取可用的方法（第一段为请求内容，第二段为响应内容，下同）：</p>
<pre><code class="http">OPTIONS * RTSP/1.0
CSeq: 0
</code></pre>
<pre><code class="http">RTSP/1.0 200 OK
CSeq: 0
public: DESCRIBE, OPTIONS, PLAY, SETUP, TEARDOWN
server: rtpserver 0.0.2svn
</code></pre>
<p><code>rtpserver</code>目前仅支持播放所必需的最基本的方法。<br>当渲染器从控制点得到了RTSP URL，它将使用<code>DESCRIBE</code>方法从服务器获取有关它的附加信息：</p>
<pre><code class="http">DESCRIBE /rtpserver/radio/S19.2E-1-1093-28422.mpa?apid=431&amp;audio=MP2&amp;container=MPEGES&amp;ppid=0 RTSP/1.0
Host: 192.168.80.5:10554
CSeq: 1
</code></pre>
<pre><code class="http">RTSP/1.0 200 OK
CSeq: 1
server: rtpserver 0.0.2svn
Content-Type: application/sdp
Content-Length: 238

v=0
o=- 1240165012 1240165012 IN IP4 192.168.80.5
s=hr4
c=IN IP4 239.35.129.11
t=0 0
m=audio 0 RTP/AVP 33
a=control:rtsp://192.168.80.5:10554/rtpserver/radio/S19.2E-1-1093-28422.mpa?apid=431&amp;audio=MP2&amp;container=MPEGES&amp;ppid=0
</code></pre>
<p>服务器使用描述内容的SDP文件响应。需要注意的是到现在为止，<code>rtpserver</code>没有为流会话做任何准备。这只会发生在渲染器发送<code>SETUP</code>请求的时候：</p>
<pre><code class="http">SETUP rtsp://192.168.80.5:10554/rtpserver/tv/S19.2E-1-1079-28006.mpg?apid=120&amp;audio=MP2&amp;container=MPEGTS&amp;ppid=110&amp;video=MPEG2&amp;vpid=110 RTSP/1.0
CSeq: 3
Transport: RTP/AVP;multicast;ttl=1
user-agent: VLC media player (LIVE555 Streaming Media v2008.07.24)
</code></pre>
<pre><code class="http">RTSP/1.0 200 OK
CSeq: 3
Session: 1240167190
server: rtpserver 0.0.2svn
transport: RTP/AVP;multicast;mode=&quot;PLAY&quot;;destination=239.35.129.11;ttl=1;port=10004-10008
</code></pre>
<p>这里，客户端为电视频道请求设置会话。它使用<code>Transport</code>头表明支持组播。<code>rtpserver</code>现在将为请求的URL查找内容项。</p>
<h4 id="u8BBE_u7F6E_u7BA1_u9053"><a href="#u8BBE_u7F6E_u7BA1_u9053" class="headerlink" title="设置管道"></a>设置管道</h4><p><code>rtpserver</code>现在将组装与所选内容项相关联的管道。为使多播传输实际可用，<code>rtpserver</code>跟踪所有运行的多播传输，如果给定的广播频道已正在传输，将返回现有实例。但是这里假设被配置的传输是唯一的。</p>
<p>首先，源通过与内容项相关联的源提供者创建，这时提供者为<code>VDRSourceProvider</code>。为了节省带宽以及在现有的DVB调谐器的数量之下有效地工作，<code>VDRSourceProvider</code>跟踪所有VDR源，并且在相同频道的时候重复使用源。这里，一个新<code>VDRSource</code>将被创建，它将会连接到VDR以获取媒体流。</p>
<p>接着，接收器被创建，在这种情况下为<code>RTPSink</code>。一个组播通道和一组RTP端口将分配给它。</p>
<p>最后，在源和接收器之间的转换器链被组装，目前使用的是一套硬编码规则。因为<code>VDRSource</code>已经产生MPEG传输流，所以只有<code>MPEGTSPacketizer</code>是必要的，因此最终的管道将是<code>VDRSource</code> → <code>MPEGTSPacketizer</code> → <code>RTPSink</code>。</p>
<p>现在，客户端被指定了一个唯一的会话ID，服务器正在启动以在指定的多播频道上传输流到电视。由于它是通过一个单向的UDP传输实时流，立即启动流传输而不等待客户端是没有问题的。然而，一个普通的客户端现在将仍发出<code>PLAY</code>请求以开始流：</p>
<pre><code class="http">PLAY rtsp://192.168.80.5:10554/rtpserver/tv/S19.2E-1-1079-28006.mpg?apid=120&amp;audio=MP2&amp;container=MPEGTS&amp;ppid=110&amp;video=MPEG2&amp;vpid=110 RTSP/1.0
CSeq: 4
Session: 1240167190
range: npt=0,000-
user-agent: VLC media player (LIVE555 Streaming Media v2008.07.24)
</code></pre>
<pre><code class="http">RTSP/1.0 200 OK
CSeq: 4
Session: 1240167190
server: rtpserver 0.0.2svn
</code></pre>
<p>客户端现在将监听协商的UDP多播信道，以获取媒体流并渲染。</p>
<h4 id="u7ED3_u675F_u4F1A_u8BDD"><a href="#u7ED3_u675F_u4F1A_u8BDD" class="headerlink" title="结束会话"></a>结束会话</h4><p>当用户结束播放时，渲染器将使用<code>TEARDOWN</code>请求来结束RTSP会话：</p>
<pre><code class="http">TEARDOWN rtsp://192.168.80.5:10554/rtpserver/tv/S19.2E-1-1079-28006.mpg?apid=120&amp;audio=MP2&amp;ocntainer=MPEGTS&amp;ppid=110&amp;video=MPEG2&amp;vpid=110 RTSP/1.0
CSeq: 5
Session: 1240167190
user-agent: VLC media player (LIVE555 Streaming Media v2008.07.24)
</code></pre>
<pre><code class="http">RTSP/1.0 200 OK
CSeq: 5
Session: 1240167190
server: rtpserver 0.0.2svn
</code></pre>
<p>现在，服务器将释放本次会话的所有资源，除非它们也被其他会话使用（如DVB共享信道或组播会话）。</p>
<h3 id="DLNA_u517C_u5BB9_u6027_u6D4B_u8BD5"><a href="#DLNA_u517C_u5BB9_u6027_u6D4B_u8BD5" class="headerlink" title="DLNA兼容性测试"></a>DLNA兼容性测试</h3><h4 id="DLNA_u4E00_u81F4_u6027_u6D4B_u8BD5_u5DE5_u5177"><a href="#DLNA_u4E00_u81F4_u6027_u6D4B_u8BD5_u5DE5_u5177" class="headerlink" title="DLNA一致性测试工具"></a>DLNA一致性测试工具</h4><p>DLNA为他们的成员提供了测试应用程序套件，以验证“测试设备”（DUT）符合DLNA准则。该<strong>一致性测试工具</strong>（CTT）是一个Windows应用程序，为大多数准则针对DUT运行一个测试。该准则中被分类为<code>must</code>的规则是必须遵守的，<code>should</code>规则被是推荐遵守的，而<code>optional</code>则是DUT可以选择遵守也可选择不遵守的规则。几乎所有的<code>most</code>和大部分<code>should</code>规则都有一个测试用例，而大部分<code>optional</code>准则则没有。</p>
<p>启动CTT后，用户必须通过提供DUT（例如数字媒体服务器的DMS）类来创建设备配置文件，并检查盒子的附加功能（如无线网络支持，多网络支持或媒体上传）。然后CTT将按照选择的功能编译测试。</p>
<p>如果要测试的准则适用于该设备（即该准则适用于该设备的类，分类和功能），则测试要么通过，要么根据其类别，判定失败或得到一个警告状态。如果测试检测到设备声称不支持大纲描述的可选功能，它将返回<code>N/A</code>。有些测试还需要人工干预，如重新启动或循环DUT电源。</p>
<h4 id="rtpserver_u7684_u6D4B_u8BD5_u72B6_u6001"><a href="#rtpserver_u7684_u6D4B_u8BD5_u72B6_u6001" class="headerlink" title="rtpserver的测试状态"></a>rtpserver的测试状态</h4><p>CTT有几个缺点，使得测试<code>rtpserver</code>有点难度。最大的问题是对许多媒体有限的支持，大多数测试都涉及从<code>rtpserver</code>获取广播媒体并等待流结束，测试正常时不会发生任何情况。因此<code>rtpserver</code>具有一个特殊选项，将广播流限制为30秒。此外，某些测试和它们对应的准则记录不够清楚，所以有几个测试可能不满足。有些测试被纳入选择集合中，即使他们是<code>rtpserver</code>既不支持也没有说明的功能。最后，因为完整的RTSP/RTP支持是可选的，所有CTT没有纳入这个协议的测试。</p>
<p>尽管如此，<code>rtpserver</code>满足整个CTT测试，只有极少数的例外，其中失败的原因无法确定。CTT测试结果如下：</p>
<ul>
<li>568个准则/指导块与我们的设备配置文件（DMS）有关。</li>
<li>其中的124个，CTT没有提供测试。无论怎样，如果指导方针适用于<code>rtpserver</code>，它将尽量满足规则。</li>
<li>237个准则为可选功能，<code>rtpserver</code>（还）没有支持，例如媒体上传。CTT正确的标记它们为不适用。</li>
<li>188个测试通过，没有问题。</li>
<li>8个测试返回一个“警告”结果。他们或者是缺少内容项的图标（专辑封面，台标），或者是因为故意设置以加快测试的过小的SSDP<code>CACHE-CONTROL</code>值。</li>
<li>11个测试失败。对于他们中的5个，CTT发现数据错误，实际上数据从来没有在网络上发送。4个测试声称<code>rtpserver</code>支持媒体上传（当然任何企图的上传都失败），尽管<code>rtpserver</code>和CTT配置文件都没有声称支持媒体上传。剩下的两个未满足，因为参考文件要么含糊要么不可用了。</li>
</ul>
<h2 id="u7ED3_u8BBA"><a href="#u7ED3_u8BBA" class="headerlink" title="结论"></a>结论</h2><p>上面已经显示了，在家庭网络中，使用现有标准，一个广播电视可以有类似于传统方式传输的广播电视的体验。尽管还存在一些AV同步问题和一些有限的限制，通过HTTP在一个直播电视上使用商用DLNA客户端播放还是可能的。仍然缺失的就是一个完整电视机那样的体验，可以快速的响应遥控器控制，并切换频道，就像使用普通电视机一样。</p>
<h3 id="u672A_u6765_u5DE5_u4F5C"><a href="#u672A_u6765_u5DE5_u4F5C" class="headerlink" title="未来工作"></a>未来工作</h3><p>即使基本功能工作良好，也还有一些主题仍需要解决：</p>
<h4 id="u76F4_u63A5_u8BBF_u95EEDVB_u8C03_u8C10_u5668"><a href="#u76F4_u63A5_u8BBF_u95EEDVB_u8C03_u8C10_u5668" class="headerlink" title="直接访问DVB调谐器"></a>直接访问DVB调谐器</h4><p>目前DVB后端（<code>VDRSource</code>和<code>DVBStreamSource</code>）都依赖于第三方软件来调整DVB硬件、访问接收到的数据流。未来的<code>rtpserver</code>版本肯定会使用Linux的<code>DVB API</code>来直接访问DVB调谐器硬件。</p>
<h4 id="DVB-SI_u6620_u5C04_u548CEPG"><a href="#DVB-SI_u6620_u5C04_u548CEPG" class="headerlink" title="DVB-SI映射和EPG"></a>DVB-SI映射和EPG</h4><p><code>DVB-HN</code>指定服务信息如何嵌入到DVB流（<code>DVB-SI</code>）中，例如EPG（电子节目指南）数据，要被映射到内容目录。 当这完成时，每个单独的电视或广播节目被映射到一个单独的内容项。然后这些可以由记录客户端单独请求。</p>
<h4 id="u4E13_u7528_u63A7_u5236_u70B9"><a href="#u4E13_u7528_u63A7_u5236_u70B9" class="headerlink" title="专用控制点"></a>专用控制点</h4><p>无论是索尼的PlayStation 3，还是iPhone上的<code>PlugPlayer</code>都不提供频道之间的“快速”切换，因为这些设备在设计时考虑到存储的内容。因此，将来的项目可能考虑包括一个有电视体验般的DLNA控制点。通过<code>rtpserver</code>提供的内容目录已经包括了<code>upnp:channelNr</code>属性来在一个顺序列表中排列可用广播频道，就像在一个传统电视机那样。</p>
<h4 id="u5D4C_u5165_u5F0F_u5A92_u4F53_u670D_u52A1_u5668_u548C_u64AD_u653E_u5668"><a href="#u5D4C_u5165_u5F0F_u5A92_u4F53_u670D_u52A1_u5668_u548C_u64AD_u653E_u5668" class="headerlink" title="嵌入式媒体服务器和播放器"></a>嵌入式媒体服务器和播放器</h4><p>目前，媒体服务器和媒体渲染器都被安装到磁盘上，并运行在完整的Ubuntu中，这需要几分钟来启动，也需要手动操作来启动媒体服务器和渲染器。更人性化的设计可以包括一个小的、专用的Linux发行版，它可以快速的从一个闪存中直接启动应用程序。这样的设计可以提供比现有的一些商用IPTV平台更快的启动速度。基于连接状态（无论是显示器还是调谐器设备连接），无论是媒体服务器、媒体渲染器或这两者都可以被自动启动。</p>
<h4 id="u5185_u5BB9_u76EE_u5F55_u641C_u7D22"><a href="#u5185_u5BB9_u76EE_u5F55_u641C_u7D22" class="headerlink" title="内容目录搜索"></a>内容目录搜索</h4><p>UPnP<em>内容目录</em>指定一个可选的，功能强大的<em>搜索</em>操作，它可以根据用户指定的搜索参数返回一个内容项列表，甚至不需要使用普通的<em>浏览</em>请求就可以访问。这提供了包括基于网络的媒体平台的可能性，如YouTube，谷歌视频或Last.fm，只要实现一个适当的源类。</p>
<h4 id="u667A_u80FD_u8F6C_u7801_u5F15_u64CE"><a href="#u667A_u80FD_u8F6C_u7801_u5F15_u64CE" class="headerlink" title="智能转码引擎"></a>智能转码引擎</h4><p>转换器框架（第3.1.2节）中目前只有很少的转换器在开发<code>rtpserver</code>中是必要的。定义特定源/接收器组合管道的规则集也是硬编码的。使用外部库例如<code>ffmpeg</code>，有更多的转换器可以用来重新编码内容或改变容器。规则集可以使用图形算法替代，其可以自动确定最快或最优的路由路径。</p>
<h4 id="u91CD_u5199_u5E26_u7EA0_u9519_u7684RTP_u5E93"><a href="#u91CD_u5199_u5E26_u7EA0_u9519_u7684RTP_u5E93" class="headerlink" title="重写带纠错的RTP库"></a>重写带纠错的RTP库</h4><p>目前使用的带AHEC的RTP库，<code>libccrtp-ahec</code>，是<code>GNU libccrtp</code>的一个旧分支。这个库最初设计时考虑到IP语音电话，不容易在较新的Linux发行版中集成。从头设计一个新的带AHEC的库可以增加稳定性，并为新技术，如<strong>可扩展视频编解码器</strong>，做准备。</p>
<h2 id="u53C2_u8003_u6587_u732E"><a href="#u53C2_u8003_u6587_u732E" class="headerlink" title="参考文献"></a>参考文献</h2><ol>
<li>S. Cheshire, B. Aboba, and E. Guttman. Dynamic Configuration of IPv4 Link-Local Addresses. RFC 3927 (Proposed Standard), May 2005. <a href="http://www.ietf.org/rfc/rfc3927.txt" target="_blank" rel="external">http://www.ietf.org/rfc/rfc3927.txt</a>.</li>
<li>J. Cohen and S. Aggarwal. General Event Notification Architecture Base. IETF Draft (expired), July 1998. <a href="http://quimby.gnus.org/internet-drafts/draft-cohen-gena-p-base-01.txt" target="_blank" rel="external">http://quimby.gnus.org/internet-drafts/draft-cohen-gena-p-base-01.txt</a>.</li>
<li>Contributing Members of the UPnP Forum. AVTransport:1 Service Template Version 1.01, June 2002.</li>
<li>Contributing Members of the UPnP Forum. ConnectionManager:1 Service Template Version 1.01, June 2002.</li>
<li>Contributing Members of the UPnP Forum. ContentDirectory:1 Service Template Version 1.01, June 2002.</li>
<li>Contributing Members of the UPnP Forum. UPnP AV Architecture:0.83 v1.0, 2002.</li>
<li>Contributing Members of the UPnP Forum. UPnP Device Architecture v1.0, July 2006.</li>
<li>Digital Living Network Alliance. Digital Living Network Alliance: official web site. <a href="http://www.dlna.org" target="_blank" rel="external">http://www.dlna.org</a>.</li>
<li>Digital Living Network Alliance. DLNA Networked Device Interoperability Guidelines, October 2006.</li>
<li>Digital Living Network Alliance. DLNA Overview and Vision Whitepaper 2007, 2007.</li>
<li>European Telecommunications Standards Institute. ETSI TS 102 034 V1.3.1: Digital Video Broadcasting (DVB); Transport of MPEG-2 TS Based DVB Services over IP Based Networks, 2007.</li>
<li>Yaron Y. Goland, Ting Cai, Paul Leach, Ye Gu, and Shivaun Albright. Simple Service Discovery Protocol/1.0 Operating without an Arbiter. IETF Draft (expired), October 1999. ftp://ftp.pwg.org/pub/pwg/ipp/new_SSDP/draft-cai-ssdp-v1-03.txt.</li>
<li>Jochen Grün. Study Thesis: Implementierung eines DVB Digital Media Renderers, November 2008.</li>
<li>M. Handley and V. Jacobson. SDP: Session Description Protocol, April 1998. <a href="http://www.ietf.org/rfc/rfc2327.txt" target="_blank" rel="external">http://www.ietf.org/rfc/rfc2327.txt</a>.</li>
<li>Intel Corporation. Designing a UPnP AV MediaServer, 2003.</li>
<li>ISO/IEC. ISO/IEC 13818-1: Information technology — Generic coding of moving pic- tures and associated audio information: Systems, December 2000.</li>
<li>Michael Jeronimo and Jack Weast. UPnP Design by Example. Intel Press, April 2003.</li>
<li>Klaus Schmidinger. Video Disk Recorder. <a href="http://www.cadsoft.de/vdr" target="_blank" rel="external">http://www.cadsoft.de/vdr</a>.</li>
<li>H. Schulzrinne, S. Casner, R. Frederick, and V. Jacobson. RTP: A Transport Protocol for Real-Time Applications, July 2003. <a href="http://www.ietf.org/rfc/rfc3550.txt" target="_blank" rel="external">http://www.ietf.org/rfc/rfc3550.txt</a>.</li>
<li>H. Schulzrinne, A. Rao, and R. Lanphier. Real Time Streaming Protocol, April 1998. <a href="http://www.ietf.org/rfc/rfc2326.txt" target="_blank" rel="external">http://www.ietf.org/rfc/rfc2326.txt</a>.</li>
<li>Guoping Tan and Thorsten Herfet. Optimization of an RTP Level Hybrid Error Correction Scheme for DVB Systems Over Wireless Home Networks Under Restrict Delay Constraint. In IEEE Transactions on Broadcasting, Vol 53, Issue 1, Part 2, pages 297–307. IEEE, March 2007.</li>
<li>The DVB Project. DVB-HN (Home Network) Reference Model Phase 1. <a href="http://www.dvb.org/technology/standards/a109.tm3690r2.DVB-HN\_ref\_model.pdf" target="_blank" rel="external">http://www.dvb.org/technology/standards/a109.tm3690r2.DVB-HN\_ref\_model.pdf</a>, February 2007.</li>
</ol>
]]></content>
    <summary type="html">
    <![CDATA[<p>首先说明，这是毕设中要求翻译的一篇论文，原文相关信息如下：</p>
<ul>
<li>题目：<strong>Implementing a DLNA-compliant UPnP AV MediaServer with DVB and RTSP/RTP support</strong>.（实现一个DLNA兼容且支持DVB和RTSP/RTP的UPnP AV媒体服务器）</li>
<li>作者：<strong>Martin Emrich</strong></li>
<li>上传日期：2009年4月28日</li>
<li>导师：Manuel Gorius，硕士</li>
<li>初审者：Thorsten Herfet，博士，教授 </li>
<li>二审者：Philipp Slusallek，博士，教授</li>
</ul>
<p>本文只为翻译所用，<strong>一切版权和许可均归原作者所有</strong>。</p>
<blockquote>
<p><strong>同意声明</strong><br>我同意将论文的两个版本添加到计算机学院的图书馆，使其向公众开放。</p>
<p><strong>感谢</strong><br>本论文由英特尔股份有限公司的“数字家庭研究实验室”给予支持。 </p>
</blockquote>
<p><strong>摘要</strong><br>在家庭多媒体网络中，目前分布式存储的内容（照片、音乐、视频文件）是与直播电视和电台分离的，即使最近已经开始由IP网络传输。本文描述了一个支持发布内容到家庭网络且可以接收数字视频广播的原型媒体服务器的设计和实现。它遵守<code>DLNA</code>设备互操作指南，以兼容许多现有设备，并通过实时传输协议（<code>RTP</code>）以及<code>HTTP</code>提供到<strong>UPnP AV</strong>客户端的直播。 </p>]]>
    
    </summary>
    
      <category term="DLNA" scheme="http://3meng.github.io/tags/DLNA/"/>
    
      <category term="RTSP/RTP" scheme="http://3meng.github.io/tags/RTSP-RTP/"/>
    
      <category term="UPnP" scheme="http://3meng.github.io/tags/UPnP/"/>
    
      <category term="DLNA" scheme="http://3meng.github.io/categories/DLNA/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Treap树]]></title>
    <link href="http://3meng.github.io/2016/02/24/Treap-tree/"/>
    <id>http://3meng.github.io/2016/02/24/Treap-tree/</id>
    <published>2016-02-24T13:25:47.000Z</published>
    <updated>2016-02-25T08:18:44.000Z</updated>
    <content type="html"><![CDATA[<p>下面的题目是<strong>《算法导论（第三版）》</strong>中红黑树一章的思考题13-4，主要介绍与分析了<code>Treap树</code>的一些知识和性质。本文也将以原题内容作为线索，通过证明和解答其中的问题，来说明<code>Treap树</code>的主要特点。</p>
<p>有些问题也是比较棘手的，受限于个人能力，因此并无法保证所有证明过程的正确性，而在合适的时机，我将会给出社区讨论链接。</p>
<blockquote>
<p>原书中对部分地方配有图片描述，在这里，目前没有添加配图，如果有时间再行补上。</p>
</blockquote>
<a id="more"></a>
<h2 id="u5B9A_u4E49"><a href="#u5B9A_u4E49" class="headerlink" title="定义"></a>定义</h2><p>如果将一个含 <em>n</em> 个元素的集合插入到一棵二叉搜索树中，所得到的树可能会相当不平衡，从而导致查找时间很长。然而从<strong>12.4</strong>节（<strong>随机构建二叉搜索树</strong>）可知，随机构造二叉搜索树是趋向于平衡的。因此，一般来说，要为一组固定的元素建立一棵平衡树，可以采用的一种策略就是先随机排列这些元素，然后按照排列的顺序将它们插入到树中。</p>
<p>如果没法同时得到所有的元素，应该怎样处理呢？如果一次收到一个元素，是否仍然能用它们来随机建立一棵二叉搜索树？</p>
<p>我们将通过考察一个数据结构来正面回答这个问题。一棵<strong>treap树</strong>是一棵更改了结点排序方式的二叉搜索树。<del>图13-9显示了一个例子。</del>通常，树内的每个结点 <em>x</em> 都有一个关键字 <em>x.key</em>。另外，还要为每个结点指定 <em>x.priority</em>，它是一个独立选取的随机数。<strong>假设所有的优先级都是不同的，而且所有的关键字也是不同的。</strong> <strong>treap树</strong>的结点被排列成让关键字遵循二叉搜索树的性质，且优先级遵循最小堆顺序性质：</p>
<ul>
<li>如果 <em>v</em> 是 <em>u</em> 的左孩子，则 <em>v.key &lt; u.key</em>。</li>
<li>如果 <em>v</em> 是 <em>u</em> 的右孩子，则 <em>v.key &gt; u.key</em>。</li>
<li>如果 <em>v</em> 是 <em>u</em> 的孩子，则 <em>v.priority &gt; u.priority</em>。</li>
</ul>
<blockquote>
<p>这两个性质的结合就是这种树被称为“treap”树的原因：它同时具有二叉搜索树和堆的特征。</p>
</blockquote>
<h2 id="u57FA_u7840_u6027_u8D28"><a href="#u57FA_u7840_u6027_u8D28" class="headerlink" title="基础性质"></a>基础性质</h2><p>用以下方式考虑<strong>treap树</strong>是会有帮助的。假设将已有相应关键字的结点 `x_1, x_2, …, x_n`插入到一棵<strong>treap树</strong>内。得到的<strong>treap树</strong>是通过将这些结点以它们的优先级（随机选取的）顺序插入一棵正常的二叉搜索树形成的，即 `x_i.prio rity &lt; x_j.prio rity`表示 `x_i`在`x_j`之前被插入。</p>
<p><strong>a.</strong> 证明：给定一个已有相应关键字和优先级（互异）的结点`x_1, x_2, …, x_n`组成的集合，存在<strong>唯一</strong>的一棵treap树与这些结点相关联。</p>
<p>这第一个问题很容易给出一个非形式化的描述来证明。我们根据<strong>treap树</strong>的定义可以知道，当给定了一个结点集合之后，那么二叉树的根节点肯定是这些结点之中<strong>优先级最小</strong>的那个结点（堆的性质），然后又可以按照二叉搜索树的要求，将剩余的元素分为两个部分，分别用于构建根节点的左右子树。概括来讲，给定一个结点的集合之后，我们可以通过下列步骤来构建起一个<strong>treap树</strong>：</p>
<ol>
<li>从元素集合里面选取<strong>优先级最小</strong>的那个元素（集合为空，则选择<code>nil</code>）；</li>
<li>将剩余元素按照二叉搜索树要求方式分为两个部分，其中<strong>一部分所有元素均小于上面选择的元素，而另一部分则不小于</strong>；</li>
<li>以上面获得的两部分元素作为集合，转到步骤1递归执行，并将子过程选择的元素分别作为当前选取元素的左右孩子。</li>
</ol>
<p>由于每次运行步骤1的时候，选择的元素是唯一的，因此从第一次执行开始，对于一个给定的集合，我们每次执行的结果都是一定的，所以最后得到的<strong>treap树</strong>也是唯一的。</p>
<p><strong>b.</strong> 证明：treap树的期望高度是`Theta(lgn)`，因此在treap树内查找一个值所花的时间为`Theta(lgn)`。</p>
<blockquote>
<p>对于这一问题，我的答案最多只能作为参考思路，我并不确定解答过程的正确性。</p>
</blockquote>
<p>对于一个有 <em>n</em> 个元素的<strong>treap树</strong>，我们假设所有元素的关键字分别为 `k_1, k_2, …, k_n`，所有的优先级集合为 `p_1, p_2,…,p_n`，然后定义`A_(ij)`表示一个关键字为`k_j`、优先级为`p_i`的一个结点。因此一个 <em>n</em> 元素的<strong>treap树</strong>的高度 `h_n` 就是以结点 `A_(1j)` 为根的树的高度，并且我们可以知道根节点的两个子树分别有 `j-1` 和 `n-j` 个元素，其高度也可以表示为 `h_(j-1)` 和 `h_(n-j)`。因此，我们可以得到下面的表达式：</p>
<p style="text-align: center"><br>  `h_n = MAX(h_(j-1), h_(n-j)) + 1,  1 &lt;= j &lt;= n`<br></p>

<p>因此要计算`h_n`的期望，我们可以通过对 <em>j</em> 的所有取值所得结果取平均值，即：</p>
<p style="text-align: center"><br>  `E(h_n) = 1/n sum_(j=1)^n MAX(h_(j-1), h_(n-j)) + 1`<br></p>

<p>其中我们可以令`h_0 = 0`。</p>
<p>使用代入法来证明。即我们需要证明：存在一个正数<strong>C</strong>，使得`h_n &lt;= Clgn`。在这里，我们假设对于上面的<strong>MAX</strong>方法，每次返回的均是第二个参数的值，那么我们可以得到：</p>
<p style="text-align: center"><br>  `E(h_n) = 1/n sum_(j=0)^(n-1) h_j` <br><br>  `E(h_n) = 1/n sum_(j=1)^(n-1) Clgj` <br><br>  `E(h_n) = C/n lg(prod_(j=1)^(n-1))` <br><br>  `E(h_n) &lt;= C/n lg(n!)` <br><br>  `E(h_n) = C/n Theta(nlgn)` 因为`lg(n!) = Theta(nlgn)`<br></p>

<p>所以可推出`E(h_n) &lt;= C/n * nlgn = Clgn`，同理也可推出期望值下限为`Omega(lgn)`。因此<strong>treap树</strong>的期望高度为`Theta(lgn)`。</p>
<h2 id="u63D2_u5165_u64CD_u4F5C"><a href="#u63D2_u5165_u64CD_u4F5C" class="headerlink" title="插入操作"></a>插入操作</h2><p>让我们如何将一个新的结点插入到一个已存在的<strong>treap树</strong>中。要做的第一件事就是讲一个随机的优先级赋予这个新结点。然后调用成为<code>TREAT_INSERT</code>的插入算法，<del>其操作如图13-10所示。</del></p>
<blockquote>
<p>暂时没有配图，因此简述一下插入过程，当给定一个要插入的结点时，我们假设这个结点的关键字和优先级都已经设置好了，并且其左右孩子的值均为<code>nil</code>。</p>
<p>首先我们按照二叉搜索树的插入过程，将结点插入到相应的位置，这个过程只考虑结点的关键字；然后接下来我们就要开始通过<strong>旋转</strong>操作来恢复<strong>treap树</strong>的堆性质了，这个过程只考虑结点的优先级即可。</p>
</blockquote>
<p><strong>c.</strong> 解释<code>TREAP_INSERT</code>是如何工作的。说明其思想并给出伪代码。（提示：执行通常的二叉搜索树插入过程，然后做旋转来恢复最小堆顺序的性质。）</p>
<p>关于插入过程的工作概要已经在题目的提示以及上面的简述中说明了。之所以这么做可行，是因为<strong>treap树</strong>的关键字和优先级属性之间是独立的，相互之间并不存在影响，因此我们可以单独分别处理每一个属性。</p>
<ol>
<li><p>首先进行常规二叉搜索树的插入过程，也就是一次二叉树简单路径的搜索过程，最后将结点插入到某一个叶结点；</p>
<blockquote>
<p>这个时候，整个树的关键字集合已经满足二叉搜索树的性质了，但是优先级顺序不一定满足，因此我们需要通过<strong>旋转</strong>来恢复最小堆顺序的性质，因为<strong>旋转</strong>操作不改变二叉搜索树的性质；</p>
</blockquote>
</li>
<li><p>接下来从被插入的结点开始，如果其优先级小于父结点的优先级，则说明最小堆顺序的性质被破坏，根据结点是父结点的左孩子还是右孩子，执行相应的右旋或者左旋操作，然后重复这一过程直到恢复最小堆顺序的性质。</p>
</li>
</ol>
<p>伪代码：</p>
<pre><code class="c++">TREAP_INSERT(T, z)
    TREE_INSERT(T, z)   // 二叉搜索树的插入过程
    while z.priority &lt; z.p.priority
        if z == z.p.left
            RIGHT_ROTATION(T, z.p)  // 右旋
        else
            LEFT_ROTATION(T, z.p)   // 左旋
</code></pre>
<p>这里我们不用考虑如果 <em>z</em> 为根节点的时候的边界情况，因为我们假设在树中引入了哨兵<code>T.nil</code>来代替<code>nil</code>值，因此根节点的父结点也就是<code>T.nil</code>，我们将其优先级设置为`-oo`，这样就可以使我们减少对边界条件的判断（这也是旋转过程的基本假设条件）。</p>
<p><strong>d.</strong> 证明：<code>TREAP_INSERT</code>的期望运行时间是`Theta(lgn)`。</p>
<p><strong>证明：</strong>首先，对于<code>TREE_INSERT</code>过程的调用期望运行时间为`Theta(lgn)`。</p>
<p>然后我们可以分析第3到7行的<code>while</code>过程运行时间。第一次循环之前，<em>z</em> 是一个叶结点，最好情况下当然是循环过程一次都没有执行，此时这段代码的运行时间为`O(1)`；那么最坏情况呢？根据循环过程的代码，每次循环或者执行一次左旋、或者执行一次右旋操作，这两个操作都是常数级别的，并且操作结束之后，将会导致根节点到 <em>z</em> 的简单路径长度减一，因此我们很容易可以知道，最多经过 <em>z</em> 的初始高度的操作次数之后，循环将结束，而 <em>z</em> 的移动路径，也就是一条从根节点到 <em>z</em> 的简单路径，因此最坏情况下也就是 <em>z</em> 从叶结点一直移动到根节点，期望运行时间为`O(lgn)`。</p>
<p>所以最后整个过程的期望运行时间为上面两个部分的运行时间之和，即`Theta(lgn)`。</p>
<h2 id="u5F15_u7406_u5B9A_u4E49"><a href="#u5F15_u7406_u5B9A_u4E49" class="headerlink" title="引理定义"></a>引理定义</h2><p><code>TREAP_INSERT</code>先执行一个查找，然后做一系列旋转。虽然这两种操作的期望运行时间相同，但他们的实际代价不同。查找操作从<strong>treap树</strong>中读取信息而不做修改。相反，旋转操作会改变<strong>treap树</strong>内的父结点和子节点的指针。在大部分的计算机上，读取操作要比写入操作快很多。所以我们希望<code>TREAP_INSERT</code>执行少量的旋转。后面将说明所执行旋转的期望次数有一个常数界。</p>
<p>为此，需要做一些定义，<del>如图13-11所示。</del>一棵二叉搜索树 <em>T</em> 的<strong>左脊柱</strong>（left spine）是从根节点到有最小关键字的结点的简单路径。换句话说，左脊柱是从根节点开始只包含左边缘的简单路径。对称的，<em>T</em> 的<strong>右脊柱</strong>（right spine）是从根节点开始只包含右边缘的简单路径。<strong>一条脊柱的长度是它包含的结点数目。</strong></p>
<p><strong>e.</strong> 考虑利用<code>TREAP_INSERT</code>插入结点 <em>x</em> 后的 treap <em>T</em>。设 <em>C</em> 为 <em>x</em> 左子树的右脊柱的长度，<em>D</em> 为 <em>x</em> 右子树的左脊柱的长度。证明：在插入 <em>x</em> 期间所执行的旋转的总次数等于 <em>C + D</em>。</p>
<p>这一个问题我们也可以通过非形式化的说明来解决。考察一下旋转操作，对于左旋来说，操作结果就是 <em>x</em> 的右孩子结点 <em>y</em> 接替了 <em>x</em> 的位置，同时 <em>x</em> 成了其结点 <em>y</em> 的的左孩子，而原来结点 <em>y</em> 的左孩子则成为了 <em>x</em> 的右孩子，因此，对结点 <em>x</em> 的一次左旋操作，其结果就是让结点 <em>y</em> 的左子树的右脊柱长度加一（增加了 <em>x</em> 结点）。同理对于右旋操作来说，结果就是让 <em>y</em> 结点的右子树的左脊柱长度加一。</p>
<p>回到题目，因为被插入结点 <em>x</em> 最开始左右子树均为<code>nil</code>，因此 <em>C = D = 0</em>，然后每执行一次左旋操作，<em>C</em> 的值加一，而每执行一次右旋操作，<em>D</em> 的值加一，因此当操作结束之后，<em>C + D</em> 的值也就是左旋和右旋的总次数。</p>
<h2 id="u6027_u80FD_u5206_u6790"><a href="#u6027_u80FD_u5206_u6790" class="headerlink" title="性能分析"></a>性能分析</h2><p>现在来计算 <em>C</em> 和 <em>D</em> 的期望值。不失一般性，假设关键字为1，2，…，n，因为只是将它们两两比较。</p>
<p>对 treap <em>T</em> 中的结点 <em>x</em> 和 <em>y</em>，其中`y != x`，设 <em>k = x.key</em> 以及 <em>i = y.key</em>。定义指示器随机变量</p>
<p style="text-align: center"><br>  `X_(ik) = I{y`在`x`的左子树的右脊柱中`}`<br></p>

<p><strong>f.</strong> 证明：`X_(ik) = 1`当且仅当`y.prio rity &gt; x.prio rity, y.key &lt; x.key`成立，且对于每个满足`y.key &lt; z.key &lt; x.key`的 <em>z</em>，有`y.prio rity &lt; z.prio rity`。</p>
<p><strong>证明：</strong>首先我们来证明正向推导过程。如果`X_(ik) = 1`，则意味着 <em>y</em> 在 <em>x</em> 的左子树的右脊柱中，因此有`y.prio rity &gt; x.prio rity, y.key &lt; x.key`，而对于满足`y.key &lt; z.key &lt; x.key`条件的 <em>z</em>结点，可以确定 <em>z</em> 必然在 <em>y</em> 的右子树中，所以`y.prio rity &lt; z.prio rity`成立。</p>
<p>然后证明逆向过程。根据`y.prio rity &gt; x.prio rity, y.key &lt; x.key`可以得知，<em>y</em> 必然在 <em>x</em> 的左子树中。现在假设 <em>y</em> 不在 <em>x</em> 的左子树的右脊柱中，那么也就意味着 <em>y</em> 在 <em>x</em> 的左孩子结点的左子树中，那么我们很容易就可以发现，对于 <em>x</em> 的左孩子结点 <em>z</em> 来说，其满足`y.key &lt; z.key &lt; x.key`，但是却又有`y.prio rity &lt; z.prio rity`，这与题设不符合，因此可知 <em>y</em> 必然在 <em>x</em> 的左子树的右脊柱中，才能使每个满足`y.key &lt; z.key &lt; x.key`的 <em>z</em>，有`y.prio rity &lt; z.prio rity`。</p>
<p>综合上述过程，可以证明`X_(ik) = 1`当且仅当`y.prio rity &gt; x.prio rity, y.key &lt; x.key`成立，且对于每个满足`y.key &lt; z.key &lt; x.key`的 <em>z</em>，有`y.prio rity &lt; z.prio rity`。</p>
<p><strong>g.</strong> 证明：</p>
<p style="text-align: center"><br>  `Pr{X_(ik)=1} = ((k-i-1)!)/((k-i+1)!) = 1/((k-i+1)(k-i))`<br></p>

<p><strong>证明：</strong>由于每个结点的关键字和优先级之间是独立的，因此我们可以把所有结点按照关键字排序，则`X_(ik)`则涉及到从关键字从 <em>i</em> 到 <em>k</em> 的所有结点，由上面的假设关键字为1到n，可以得知`X_(ik)`涉及的结点个数为 <em>k - i + 1</em>。为了方便起见，我们把每个结点都用其关键字表示，由于序列已经按照关键字排序，因此`X_(ik)`对应的序列可以表示为<code>T[i..k]</code>。</p>
<p>根据上一题中的证明结果，`X_(ik) = 1`意味着在序列<code>T[i..k]</code>中，<code>T[k]</code>的优先级应该是最小的，而<code>T[i]</code>的优先级应该是第二小的。因为序列<code>T[i..k]</code>排列顺序是随机的，所以<code>T[i..k]</code>使得`X_(ik) = 1`成立的概率为：</p>
<p style="text-align: center"><br>  `1/(k-i+1) * 1/(k-i) = 1/((k-i+1)(k-i))`<br></p>

<p>所以</p>
<p style="text-align: center"><br>  `Pr{X_(ik)=1} = ((k-i-1)!)/((k-i+1)!) = 1/((k-i+1)(k-i))`<br></p>

<p>而对于上式中间的表达式的解释，我们可以理解为：对于序列<code>T[i..k]</code>，其元素排列所有可能顺序的总数为 (k - i + 1) 个元素的一个全排列，即 <em>(k - i + 1)!</em>；而当`X_(ik) = 1`时，则我们需要固定序列中的两个元素，其它元素仍然是可以随机排列的，这样，其可能顺序的总数为 (k - i + 1 - 2) 个元素的一个全排列，即 <em>(k - i - 1)!</em>。因此，最后概率即为`X_(ik) = 1`成立的排列数与总排列数的比值。</p>
<p><strong>h.</strong> 证明：</p>
<p style="text-align: center"><br>  `E[C] = sum_(j=1)^(k-1) 1/(j(j+1)) = 1-1/k`<br></p>

<p><strong>证明：</strong>根据`X_(ik)`的定义可知，一个结点 <em>x</em> 的左子树的右脊柱的长度为：</p>
<p style="text-align: center"><br>  `C = sum_(j=1)^(k-1) X_(jk)`<br></p>

<p>对上式两边取期望，可得：</p>
<p style="text-align: center"><br>  `E[C] = sum_(j=1)^(k-1) E[X_(jk)] = sum_(j=1)^(k-1) Pr{X_(jk)=1}`<br></p>

<p>代入问题<strong>g</strong>中的证明结果，并稍作变换（令<code>j = k - j</code>），即可得到下式：</p>
<p style="text-align: center"><br>  `E[C] = sum_(j=1)^(k-1) 1/(j(j+1))`<br></p>

<p>而`1/(j(j+1)) = 1/j - 1/(j+1)`，展开上面等号右边的和式，得：</p>
<p style="text-align: center"><br>  `sum_(j=1)^(k-1) 1/(j(j+1)) = 1/1 - 1/2 + 1/2 - 1/3 + … + 1/(k-1) - 1/k = 1 - 1/k`<br></p>

<p>因此</p>
<p style="text-align: center"><br>  `E[C] = sum_(j=1)^(k-1) 1/(j(j+1)) = 1-1/k`<br></p>

<p>得证。</p>
<p><strong>i.</strong> 利用对称性证明：</p>
<p style="text-align: center"><br>  `E[D] = 1-1/(n-k+1)`<br></p>

<p><strong>证明：</strong>如果 <em>y</em> 在 <em>x</em> 的左子树中，有 <em>y.key &lt; x.key</em>，而如果在 <em>x</em> 的右子树中，则有 <em>y.key &gt; x.key</em>。因此，根据对称性，我们有：</p>
<p style="text-align: center"><br>  `Pr{X_(ik)=1} = 1/((i-k+1)(i-k))` <br><br>  `D = sum_(j=k+1)^n X_(jk)` <br><br>  `E[D] = sum_(j=k+1)^n E[X_(jk)] = sum_(j=k+1)^n Pr{X_(jk)=1}` <br><br>  `E[D] = sum_(j=1)^(n-k) 1/(j(j+1)) = 1-1/(n-k+1)`<br></p>

<p>所以原式得证。</p>
<p><strong>j.</strong> 得出如下结论：<strong>当在一棵treap树中插入一个结点时，执行旋转的期望次数小于2</strong>。</p>
<p><strong>证明：</strong>有了<strong>h</strong>和<strong>i</strong>中的结果，这一结论的得出也就是水到渠成了。执行旋转的总次数为 <em>C + D</em>，根据期望的线性性质，我们有：</p>
<p style="text-align: center"><br>  `E[C+D] = E[C]+E[D] = 1-1/k+1-1/(n-k+1) = 2-1/k-1/(n-k+1)`<br></p>

<p>由于`0 &lt; k &lt;= n`，所以有`1/k &gt; 0`且`1/(n-k+1) &gt; 0`，所以</p>
<p style="text-align: center"><br>  `E[C+D] = 2-1/k-1/(n-k+1) &lt; 2`<br></p>

<p>得证。</p>
<h2 id="u7ED3_u675F"><a href="#u7ED3_u675F" class="headerlink" title="结束"></a>结束</h2><p>通过跟踪书中的<strong>a</strong>到<strong>j</strong>各个问题，逐步给出了<strong>Treap树</strong>的一些基本性质。对于问题<strong>b</strong>，过程仍需讨论和改进，但是<strong>b</strong>的结论我们是可以直接使用的。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>下面的题目是<strong>《算法导论（第三版）》</strong>中红黑树一章的思考题13-4，主要介绍与分析了<code>Treap树</code>的一些知识和性质。本文也将以原题内容作为线索，通过证明和解答其中的问题，来说明<code>Treap树</code>的主要特点。</p>
<p>有些问题也是比较棘手的，受限于个人能力，因此并无法保证所有证明过程的正确性，而在合适的时机，我将会给出社区讨论链接。</p>
<blockquote>
<p>原书中对部分地方配有图片描述，在这里，目前没有添加配图，如果有时间再行补上。</p>
</blockquote>]]>
    
    </summary>
    
      <category term="Algorithm" scheme="http://3meng.github.io/tags/Algorithm/"/>
    
      <category term="Treap" scheme="http://3meng.github.io/tags/Treap/"/>
    
      <category term="Algorithm" scheme="http://3meng.github.io/categories/Algorithm/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[自定义Hexo主题]]></title>
    <link href="http://3meng.github.io/2016/02/21/custom-the-hexo-theme/"/>
    <id>http://3meng.github.io/2016/02/21/custom-the-hexo-theme/</id>
    <published>2016-02-21T15:53:41.000Z</published>
    <updated>2016-02-28T15:44:40.000Z</updated>
    <content type="html"><![CDATA[<p>很久很久以前就说过，要修改博客界面的一些细节样式，但是一直没有去做多少，只是在当前主题上修改了一点小细节（这也主要是因为这个主题基本符合我的要求，所以一直懒得继续修改）。</p>
<blockquote>
<p>当前使用主题为<code>Jacman</code>，作者博客<a href="http://wuchong.me/" target="_blank" rel="external">在此</a>，顺便附上<a href="https://github.com/wuchong/jacman" target="_blank" rel="external">GitHub链接</a>。</p>
</blockquote>
<p>这里讲记录所有对<code>Hexo</code>主题的自定义部分，当然，所有的操作都是基于<code>Jacman</code>主题的，因此，<strong>有些操作可能并不适用于其它主题</strong>。</p>
<blockquote>
<p>另外，主题安装日期为<strong>2015年3月18日</strong>，此后并未进行更新过，因此不保证代码和GitHub上最新版一致。也许某些下面提到的修复或者更改已经在上述GitHub链接中添加。</p>
</blockquote>
<a id="more"></a>
<h2 id="u9690_u85CF_u8BC4_u8BBA_u6A21_u5757"><a href="#u9690_u85CF_u8BC4_u8BBA_u6A21_u5757" class="headerlink" title="隐藏评论模块"></a>隐藏评论模块</h2><p>有些时候，我们可能需要在某一个页面隐藏评论模块，但这个在原生主题中并没有提供，因此需要自己添加支持。至于方式，我们也可以采用类似默认配置的样式，在<code>front-matter</code>（即标题以及日期等设置所在位置，以三个<code>-</code>标记结束）中添加配置，然后在代码中可以使用<code>page</code>属性来检查是否设置了相关配置。</p>
<p>比如这里我添加了一个属性名：<code>disableshare</code>，<code>bool</code>类型，用来标记是否需要隐藏评论模块，当设置了该属性并且其值为<code>true</code>的时候，将不会再相应页面生成结果中添加评论模块，否则将会加入。这里需要注意的是，如果我们的<code>.md</code>文件中本就没有写这个配置的话，将等价于属性值为<code>false</code>，因此对于之前的一些文件，完全不需要修改配置部分。</p>
<p>与评论模块相关的源代码位于<code>[jacman]/layout/_partial/post/footer.ejs</code>文件中，其中<code>[jacman]</code>为你的主题目录。修改后代码如下：</p>
<pre><code class="html">&lt;footer class=&quot;article-footer clearfix&quot;&gt;
&lt;%- partial(&#39;catetags&#39;) %&gt;
&lt;% if (!index){ %&gt;
    &lt;div class=&quot;article-share&quot; id=&quot;share&quot;&gt;
    &lt;% if(theme.jiathis.enable){ %&gt;
    &lt;div class=&quot;share-jiathis&quot;&gt;
      &lt;%- partial(&#39;jiathis&#39;) %&gt;
     &lt;/div&gt;
    &lt;!-- 此处首先检查设置，而不是直接输出 --&gt;
    &lt;% } else if(!page.disableshare) { %&gt;
      &lt;div data-url=&quot;&lt;%- item.permalink %&gt;&quot; data-title=&quot;&lt;% if (item.title){ %&gt;&lt;%= item.title %&gt; | &lt;% } %&gt;&lt;%= config.title %&gt;&quot; data-tsina=&quot;&lt;%= theme.author.tsina %&gt;&quot; class=&quot;share clearfix&quot;&gt;
      &lt;/div&gt;
    &lt;% } %&gt;
    &lt;/div&gt;
&lt;% } %&gt;
&lt;% if (index){ %&gt;
&lt;div class=&quot;comments-count&quot;&gt;
    &lt;% if((config.disqus_shortname || theme.disqus_shortname) &amp;&amp; !theme.duoshuo_shortname) { %&gt;
          &lt;span&gt;&lt;/span&gt;
        &lt;a href=&quot;&lt;%- config.root %&gt;&lt;%- item.path %&gt;#disqus_thread&quot; class=&quot;comments-count-link&quot;&gt;Comments&lt;/a&gt;
    &lt;% } else if(theme.duoshuo_shortname) { %&gt;
          &lt;span&gt;&lt;/span&gt;
        &lt;a href=&quot;&lt;%- config.root %&gt;&lt;%- item.path %&gt;#comments&quot; class=&quot;ds-thread-count comments-count-link&quot; data-thread-key=&quot;&lt;%- item.path %&gt;&quot; data-count-type=&quot;comments&quot;&gt;&amp;nbsp;&lt;/a&gt;
    &lt;% } %&gt;
&lt;/div&gt;
&lt;% } %&gt;
&lt;/footer&gt;
</code></pre>
<p>最后别忘了在需要的页面添加配置<code>disableshare: true</code>。</p>
<h2 id="u6570_u5B66_u516C_u5F0F"><a href="#u6570_u5B66_u516C_u5F0F" class="headerlink" title="数学公式"></a>数学公式</h2><p>在<code>Jacman</code>主题中，已经内置了数学公式的支持，因此就不用我们自己去手动修改源码了。相关文件位置为<code>[jacman]/layout/_partial/mathjax.ejs</code>，其中<code>[jacman]</code>表示你的主题目录，这个文件默认类容大概如下：</p>
<pre><code class="html">&lt;!-- mathjax config similar to math.stackexchange --&gt;
&lt;% if (page.mathjax){ %&gt;
&lt;script type=&quot;text/x-mathjax-config&quot;&gt;
  MathJax.Hub.Config({
    tex2jax: {
      inlineMath: [ [&#39;$&#39;,&#39;$&#39;], [&quot;\\(&quot;,&quot;\\)&quot;] ],
      processEscapes: true
    }
  });
&lt;/script&gt;

&lt;script type=&quot;text/x-mathjax-config&quot;&gt;
    MathJax.Hub.Config({
      tex2jax: {
        skipTags: [&#39;script&#39;, &#39;noscript&#39;, &#39;style&#39;, &#39;textarea&#39;, &#39;pre&#39;, &#39;code&#39;]
      }
    });
&lt;/script&gt;

&lt;script type=&quot;text/x-mathjax-config&quot;&gt;
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for(i=0; i &lt; all.length; i += 1) {
            all[i].SourceElement().parentNode.className += &#39; has-jax&#39;;
        }
    });
&lt;/script&gt;

&lt;script type=&quot;text/javascript&quot; src=&quot;http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML&quot;&gt;
&lt;/script&gt;
&lt;% } %&gt;
</code></pre>
<p>这是默认的类容，而我更愿意使用<a href="http://asciimath.org/" target="_blank" rel="external">AsciiMath语法</a>来书写数学公式，具体来说，就是使用两个<code>` </code>符号包围数学公式的字符串就可以了，而公式语法形式也非常类似与平时在代码中的样式，因此上手相对要快一些。例如，下面的内容：</p>
<pre><code class="c">`x = (-b +- sqrt(b^2-4ac))/(2a) .`
</code></pre>
<p>将会被转换成如下样式：</p>
<p style="text-align:center"><br>  `x = (-b +- sqrt(b^2-4ac))/(2a) .`<br></p>

<p>这里使用了<a href="https://www.mathjax.org" target="_blank" rel="external">MathJax</a>来解析数学公式，有关这个JS库的使用方法，可以参见<a href="http://docs.mathjax.org/en/latest/start.html" target="_blank" rel="external">它的文档</a>。需要注意的是，由于我们是在<code>Markdown</code>文档中使用<code>AsciiMath</code>语法，因此<strong>需要注意代码区块与数学公式区块之间的区别</strong>，因为他们使用了同一种字符来标记（当然，<code>MathJax</code>中可以配置数学公式区块的标记字符）。</p>
<p>而还有一些细节，可能关乎到具体你使用的<code>Markdown</code>解析器，就不多说了。</p>
<p>下面是修改后的<code>mathjax.ejs</code>文件内容，主要是更换了JS文件引用，删除了一些无用的配置代码：</p>
<pre><code class="html">&lt;!-- custom mathjax config --&gt;
&lt;% if (page.mathjax){ %&gt;
&lt;script type=&quot;text/x-mathjax-config&quot;&gt;
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for(i=0; i &lt; all.length; i += 1) {
            all[i].SourceElement().parentNode.className += &#39; has-jax&#39;;
        }
    });
&lt;/script&gt;

&lt;script type=&quot;text/javascript&quot; async src=&quot;https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=AM_CHTML&quot;&gt;
&lt;/script&gt;
&lt;% } %&gt;
</code></pre>
<p>而最后，需要记得在有数学公式的页面，<code>front-matter</code>中加入<code>mathjax: true</code>。</p>
<h2 id="u4FEE_u590Dclose_aside_u914D_u7F6E_u65E0_u6548_u7684_u95EE_u9898"><a href="#u4FEE_u590Dclose_aside_u914D_u7F6E_u65E0_u6548_u7684_u95EE_u9898" class="headerlink" title="修复close_aside配置无效的问题"></a>修复<code>close_aside</code>配置无效的问题</h2><p>在这一版本中，有一个配置<code>close_aside</code>用于设置当进入文章阅读页面的时候，时候关闭右边的侧栏（侧栏中包括有<strong>标签</strong>、<strong>分类</strong>、<strong>友链</strong>等等小部件），从而提供更好的阅读体验。但是当实际配置的时候，即使在<code>_config.yml</code>文件中设置<code>close_aside: true</code>也没有作用，进入内容详情页，右边侧栏依然默认是展开的，之前就说要看看这个问题所在，但是也一直没有去查看原因，今天也算是一起解决了。</p>
<p>因为那个侧边栏上本来就有个汉堡按钮来控制边栏的隐藏与否，因此很容易想到在源代码的某个地方，肯定提供了JS控制方法，所以最简单的方法就是找到这些方法所在位置，并在后面按照主题中的配置来决定时候执行隐藏边栏的方法。</p>
<p><code>Jacman</code>源代码的组织还是很具有结构性的，从主题源代码根目录下<code>layout</code>目录中可以找到一个<code>layout.ejs</code>文件，这个文件用于控制每个页面布局，包括首页以及每个文章详情页，在其中我们可以找到这样的一个调用：</p>
<pre><code class="javascript">&lt;%- partial(&#39;_partial/after_footer&#39;) %&gt;
</code></pre>
<p>然后在<code>_partial</code>目录下可以看到有个<code>after_footer.ejs</code>文件，打开就可以看到所有的<code>JavaScript</code>引用以及代码了。其中有个<code>&lt;script&gt;</code>元素内容如下：</p>
<pre><code class="javascript">$(document).ready(function(){ 
  $(&#39;.navbar&#39;).click(function(){
    $(&#39;header nav&#39;).toggleClass(&#39;shownav&#39;);
  });
  var myWidth = 0;
  function getSize(){
    if( typeof( window.innerWidth ) == &#39;number&#39; ) {
      myWidth = window.innerWidth;
    } else if( document.documentElement &amp;&amp; document.documentElement.clientWidth) {
      myWidth = document.documentElement.clientWidth;
    };
  };
  var m = $(&#39;#main&#39;),
      a = $(&#39;#asidepart&#39;),
      c = $(&#39;.closeaside&#39;),
      o = $(&#39;.openaside&#39;);
  $(window).resize(function(){
    getSize(); 
    if (myWidth &gt;= 1024) {
      $(&#39;header nav&#39;).removeClass(&#39;shownav&#39;);
    }else
    {
      m.removeClass(&#39;moveMain&#39;);
      a.css(&#39;display&#39;, &#39;block&#39;).removeClass(&#39;fadeOut&#39;);
      o.css(&#39;display&#39;, &#39;none&#39;);
      &lt;% if( is_post()&amp;&amp;(page.toc !== false) &amp;&amp; theme.toc.aside){ %&gt;
      $(&#39;#toc.toc-aside&#39;).css(&#39;display&#39;, &#39;none&#39;);
      &lt;% } %&gt;  
    }
  });
  c.click(function(){
    a.addClass(&#39;fadeOut&#39;).css(&#39;display&#39;, &#39;none&#39;);
    o.css(&#39;display&#39;, &#39;block&#39;).addClass(&#39;fadeIn&#39;);
    m.addClass(&#39;moveMain&#39;);
  });
  o.click(function(){
    o.css(&#39;display&#39;, &#39;none&#39;).removeClass(&#39;beforeFadeIn&#39;);
    a.css(&#39;display&#39;, &#39;block&#39;).removeClass(&#39;fadeOut&#39;).addClass(&#39;fadeIn&#39;);      
    m.removeClass(&#39;moveMain&#39;);
  });
  $(window).scroll(function(){
    o.css(&quot;top&quot;,Math.max(80,260-$(this).scrollTop()));
  });
});
</code></pre>
<p>主要控制代码就在<code>c.click()</code>以及<code>o.click()</code>中了，稍作修改，就可以实现我们需要的效果了；同时也顺便对<code>$(window).resize()</code>中的不完善之处稍作修改。最终主要代码如下：</p>
<pre><code class="javascript">  // ...

  var m = $(&#39;#main&#39;),
      a = $(&#39;#asidepart&#39;),
      c = $(&#39;.closeaside&#39;),
      o = $(&#39;.openaside&#39;);
  var is_open = true;
  function closeAside(){
    a.addClass(&#39;fadeOut&#39;).css(&#39;display&#39;, &#39;none&#39;);
    o.css(&#39;display&#39;, &#39;block&#39;).addClass(&#39;fadeIn&#39;);
    m.addClass(&#39;moveMain&#39;);
    is_open = false;
  };
  function openAside(){
    o.css(&#39;display&#39;, &#39;none&#39;).removeClass(&#39;beforeFadeIn&#39;);
    a.css(&#39;display&#39;, &#39;block&#39;).removeClass(&#39;fadeOut&#39;).addClass(&#39;fadeIn&#39;);      
    m.removeClass(&#39;moveMain&#39;);
    is_open = true;
  }
  $(window).resize(function(){
    getSize(); 
    if (myWidth &gt;= 1024) {
      $(&#39;header nav&#39;).removeClass(&#39;shownav&#39;);
      if (is_open) {
        openAside();
      } else {
        closeAside();
      }
    }else
    {
      m.removeClass(&#39;moveMain&#39;);
      a.css(&#39;display&#39;, &#39;block&#39;).removeClass(&#39;fadeOut&#39;);
      o.css(&#39;display&#39;, &#39;none&#39;);
      &lt;% if( is_post()&amp;&amp;(page.toc !== false) &amp;&amp; theme.toc.aside){ %&gt;
      $(&#39;#toc.toc-aside&#39;).css(&#39;display&#39;, &#39;none&#39;);
      &lt;% } %&gt;  
    }
  });
  c.click(function(){
    closeAside();
  });
  o.click(function(){
    openAside();
  });
  &lt;% if (is_post() &amp;&amp; theme.close_aside){ %&gt;
  closeAside();
  $(&#39;#toc.toc-aside&#39;).css(&#39;display&#39;, &#39;block&#39;).addClass(&#39;fadeIn&#39;);
  &lt;% } %&gt;

  // ...
</code></pre>
<p>中间曾去找过判断当前页面是否是首页的方法，但是几种方式均代价太大，需要修改的地方也不少，直到偶然看到上面有一句<code>if (is_post() &amp;&amp; ...)</code>语句调用，猜测这个<code>is_post()</code>方法便是判断当前页面是否为详情页（<code>layout</code>属性为<code>post</code>），于是也照着用，运行良好，可以保证只在详情页才会自动关闭边栏。</p>
<p>最后顺便修改了一下开关侧边栏那个按钮点击时的行为，默认情况那个按钮是个<code>&lt;a&gt;</code>元素，并且其<code>href</code>属性为<code>#</code>，因此点击时候会回到页面顶部；将<code>href</code>值改为<code>javascript:void(0)</code>就好了。</p>
<h2 id="u4EE3_u7801_u9AD8_u4EAE"><a href="#u4EE3_u7801_u9AD8_u4EAE" class="headerlink" title="代码高亮"></a>代码高亮</h2><p><code>Hexo</code>的一切都不错，但是唯独这个代码高亮做的总是不尽如人意，在<code>Hexo</code>（而非其主题）的配置文件中，有一个<code>highlight</code>配置，可以通过<code>enable</code>属性配置开关，当设置<code>enable: true</code>之后，就可以启用<code>Hexo</code>的默认代码高亮行为，这是一个预处理行为，也就是在编译时期就已经确定了每个被显示的字符(串)的颜色，而无需再运行时在进行分析处理。</p>
<p>但是很不幸的一点是，<code>Hexo</code>中使用的默认分析器没有做的足够好，很多时候都会出现不完整甚至错误的高亮行为，而更为棘手的一点是，这个用于处理代码高亮的模块，好像被内置于<code>Hexo</code>的默认<code>Markdown</code>编译器中了，外部可以更改的仅有几种简单的颜色属性；而在翻遍主题源码以及<a href="https://hexo.io/docs/" target="_blank" rel="external">Hexo官网文档</a>无果后，只能选择在运行时使用JS方式处理高亮。</p>
<p>既然决定使用JS进行高亮处理，那么自然也就不用使用内置的行为了，因为如果启用了内置行为，那么我们看起来一行行的代码，其实不知道被分成了多少个<code>&lt;p&gt;</code>、<code>&lt;span&gt;</code>等进行组织；这里就有一点很幸运了，当关闭内置处理之后，代码块会使用<code>&lt;pre&gt;&lt;code&gt;...&lt;/code&gt;&lt;/pre&gt;</code>处理，而这就很符合一般代码高亮插件的要求了。而如果我们使用下面的方式来表示代码块：</p>
<pre><code class="markdown">``` language-type
// ...
```
</code></pre>
<p>那么会自动转换成如下的HTML代码：</p>
<pre><code class="html">&lt;pre&gt;&lt;code class=&quot;language-type&quot;&gt;...&lt;/code&gt;&lt;/pre&gt;
</code></pre>
<p>这种处理方式，刚好符合<a href="https://highlightjs.org/" target="_blank" rel="external">highlight.js</a>要求。而在这里，我也是决定使用<code>highlight.js</code>来进行高亮处理。</p>
<blockquote>
<p>有关<strong>highlight.js</strong>的主题样式，可以在这个<a href="https://highlightjs.org/static/demo/" target="_blank" rel="external">Demo站点</a>查看。</p>
</blockquote>
<p>为了方便，也是为了能尽可能的利用浏览器缓存进行加速，我是选择从网上寻找一个提供<strong>highlight.js</strong>的CDN服务器。我目前使用的是<a href="http://www.bootcdn.cn/highlight.js/" target="_blank" rel="external">这个站点</a>里面给出的地址。</p>
<p>在选择需要处理的语言以及代码块的主题样式之后，我们就可以将对应的<code>css</code>以及<code>js</code>文件引用分别加入到布局模板中了。其中在<code>[jacman]/layout/_partial/head.ejs</code>添加需要的CSS样式文件引用（根据你需要的主题设置）：</p>
<pre><code class="html">&lt;link rel=&quot;stylesheet&quot; href=&quot;//cdn.bootcss.com/highlight.js/9.1.0/styles/hopscotch.min.css&quot;&gt;
</code></pre>
<p>然后在<code>&lt;body&gt;</code>元素结尾的地方加入需要的JS引用，如上面所述，在<code>[jacman]/layout/_partial/after_footer.ejs</code>中修改：</p>
<pre><code class="javascript">&lt;script src=&quot;//cdn.bootcss.com/highlight.js/9.1.0/highlight.min.js&quot;&gt;&lt;/script&gt;
&lt;script&gt;hljs.initHighlightingOnLoad();&lt;/script&gt;
</code></pre>
<blockquote>
<p>多说一句，这里我们可以看到链接中有个版本号，所以当<code>highlight.js</code>更新之后，只要CDN服务器已经同步更新，我们也可以直接更新相关文件引用。</p>
</blockquote>
<p>同样，这里可以根据需要，选择更专门化的js文件。</p>
<blockquote>
<p>经过测试，在主动标示语言类型的时候，需要使用小写方式，例如<strong>JavaScript</strong>应该写成<strong>javascript</strong>。</p>
</blockquote>
<h3 id="u7279_u6B8A_u5904_u7406"><a href="#u7279_u6B8A_u5904_u7406" class="headerlink" title="特殊处理"></a>特殊处理</h3><p>由于<code>Jacman</code>默认生成的代码块样式与高亮插件有点冲突，可能需要自己手动调整一下，例如在<code>&lt;head&gt;</code>元素中手动重写一遍高亮样式，并使用<code>!important</code>来保证不会被覆盖。</p>
<p>下面记录下我修改的部分样式（添加于<code>head</code>标签最后面）：</p>
<pre><code class="css">&lt;style type=&quot;text/css&quot;&gt;
    pre {display: block; overflow: auto !important; background: #322931 !important; padding: 0.5em;}
    pre code {display: inline-block !important; color: #b9b5b8 !important;}
&lt;/style&gt;
</code></pre>
<p>这里，为<code>pre</code>标签设置了<code>overflow</code>属性，并为<code>pre</code>中的<code>code</code>标签设置了<code>display</code>样式，以保证代码块中的每一行被正确显示到一行之中，当页面宽度过窄时，代码块显示一个水平的滚动条而不是将代码中断换行。</p>
<p>至此，语法高亮基本解决（除了行号以外），如果有不完善的地方，以后再慢慢修正了。</p>
<h2 id="u663E_u793A_u6807_u9898_u7F16_u53F7"><a href="#u663E_u793A_u6807_u9898_u7F16_u53F7" class="headerlink" title="显示标题编号"></a>显示标题编号</h2><p>默认情况下，<code>hexo</code>生成的文章详情页中，只有目录部分会显示标题编号，而到了正文中，每个标题却又如同一般<code>Markdown</code>渲染器那样，只显示个标题了事，并没有给每个标题编号，如<code>1.1</code>、<code>3.2.4</code>等。一开始以为目录中的标题编号是主题自己做的，结果翻到了对应源码位置，发现又是<code>hexo</code>自带了个<code>toc</code>方法，这个方法的第二个参数就是设置是否生成标题编号的，也就是说，这个方法又是一个集成到系统内部的，没有暴露出太多细节，这不得不说是一种遗憾。</p>
<p>那没办法，只能再次通过js来在运行时动态设置了。通过查看<code>Jacman</code>主题生成的详情页的默认结构，可以发现文章正文全部包含在一个class为<code>.article-content</code>的<code>div</code>元素中，每个标题对应的标签（<code>h1</code>、<code>h2</code>、…）都是该元素的直接子元素，并且内容结构都是类似的：一个长宽都为0的<code>&lt;a&gt;</code>标签（不知道有什么作用）、以及实际的标题文本内容。因此我们可以很容易使用<code>JQuery</code>来操作修改。</p>
<p>需要注意的是，我们一般并不会同时使用到完整的六种标题，大多数情况下就是使用两种或三种，有时候甚至只有一种，因此我们不能简单的根据标题分类来给标题编号（比如一个二级标题就一定编号为<code>*.1</code>、<code>*.2</code>等）；而在特殊情况下我们有可能会跳过某一级标题（比如只使用二级、三级、五级标题），因此确定了起点标题（比如为二级标题）之后，我们也不能简单的根据当前标题（比如五级标题）与起点标题的级数差来确定编号中的分级。</p>
<p>下面给出这里使用的js代码，原理很简单，就是先找出每一级标题的数量，如果不为0（即此类型标题存在），那就在数组相应位置标记一下该级别标题的出现顺序。比如在一个只含有二级、三级、四级标题的列表中，二级标题出现顺序就为1，相应的，四级标题顺序为3，这样我们就可以确定每一级标题的编号中需要的分级数量了（即有多少个点<code>.</code>分割）。</p>
<pre><code class="javascript">$(document).ready(function(){
  var $article = $(&quot;.article-content&quot;);
  var count = [0, 0, 0, 0, 0, 0];
  var mark = [0, 0, 0, 0, 0, 0];

  (function setMark(){
    var hTag = [&quot;h1&quot;, &quot;h2&quot;, &quot;h3&quot;, &quot;h4&quot;, &quot;h5&quot;, &quot;h6&quot;];
    var index = 0;
    for (var i = 0; i &lt; 6; ++i) {
      if ($article.children(hTag[i]).length &gt; 0) {
        ++index;
        mark[i] = index;
      }
    }
  })();

  $article.children(&quot;:header&quot;).each(function(){
    var t = $(this);
    var pos = 0;
    switch (t[0].tagName) {
      case &quot;H1&quot;: pos = 0; break;
      case &quot;H2&quot;: pos = 1; break;
      case &quot;H3&quot;: pos = 2; break;
      case &quot;H4&quot;: pos = 3; break;
      case &quot;H5&quot;: pos = 4; break;
      case &quot;H6&quot;: pos = 5; break;
    }

    var len = mark[pos];
    if (len &lt; 6) { count[len] = 0; }
    count[len - 1]++;

    var listStr = count[0] + &quot;&quot;;
    for (var i = 1; i &lt; len; ++i) { listStr += &quot;.&quot; + count[i]; }
    listStr += &quot; &quot;;
    t.html(listStr + t.html());
  });
});
</code></pre>
<p>这里我并未没有考虑比如第一个遇到的标题类型并不是最顶级的标题这样的情况，因为在一般博客中，几乎很少有这种现象，因此就不做更多考虑了。如果你需要处理这种情况的话，可以自行修改代码。</p>
<p>而最后需要注意的是，因为我们只需要在文章详情页使用这段js代码，因此记得使用<code>is_post()</code>方法判断一下是否插入代码。至于代码插入位置，依然是那个<code>after_footer.ejs</code>文件了。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>很久很久以前就说过，要修改博客界面的一些细节样式，但是一直没有去做多少，只是在当前主题上修改了一点小细节（这也主要是因为这个主题基本符合我的要求，所以一直懒得继续修改）。</p>
<blockquote>
<p>当前使用主题为<code>Jacman</code>，作者博客<a href="http://wuchong.me/">在此</a>，顺便附上<a href="https://github.com/wuchong/jacman">GitHub链接</a>。</p>
</blockquote>
<p>这里讲记录所有对<code>Hexo</code>主题的自定义部分，当然，所有的操作都是基于<code>Jacman</code>主题的，因此，<strong>有些操作可能并不适用于其它主题</strong>。</p>
<blockquote>
<p>另外，主题安装日期为<strong>2015年3月18日</strong>，此后并未进行更新过，因此不保证代码和GitHub上最新版一致。也许某些下面提到的修复或者更改已经在上述GitHub链接中添加。</p>
</blockquote>]]>
    
    </summary>
    
      <category term="Hexo" scheme="http://3meng.github.io/tags/Hexo/"/>
    
      <category term="Jacman" scheme="http://3meng.github.io/tags/Jacman/"/>
    
      <category term="随笔" scheme="http://3meng.github.io/categories/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[非递归遍历二叉树：线性时间&常量额外空间]]></title>
    <link href="http://3meng.github.io/2016/02/17/non-recursive-traversal-of-binary-tree/"/>
    <id>http://3meng.github.io/2016/02/17/non-recursive-traversal-of-binary-tree/</id>
    <published>2016-02-17T11:45:09.000Z</published>
    <updated>2016-02-24T13:31:35.000Z</updated>
    <content type="html"><![CDATA[<p>今天看到了<strong>《算法导论（第三版）》</strong>第三部分中第十章内容，在<code>10.4节</code>遇到了一个题目，要求在<code>O(n)</code>（即上限渐进时间为线性）时间内非递归遍历二叉树，并且只能使用固定量的额外存储空间。</p>
<blockquote>
<p><strong>10.4-5</strong> 给定一个<em>n</em>结点的二叉树，写出一个<code>O(n)</code>时间的非递归过程，将该树每个节点的关键字输出。要求除该树本身的存储空间外只能使用固定量的额外存储空间，且在过程中不得修改该树，即使是暂时的修改也不允许。</p>
</blockquote>
<p>部分理解需要联系上下文，比如说关键字是前文定义的一个树的结点通常具有的结构，包括一个关键字<code>key</code>、一个左孩子结点指针<code>leftChild</code>、一个右孩子结点指针<code>rightChild</code>以及一个父结点指针<code>parent</code>，另外带有可选的卫星数据。</p>
<a id="more"></a>
<p>在开始之前，给出一些基本的树结点定义，然后可以先看看二叉树常规的遍历方式。</p>
<h2 id="u5B9A_u4E49"><a href="#u5B9A_u4E49" class="headerlink" title="定义"></a>定义</h2><p>在下面的讨论中，对于树结点的定义都按照这个定义：</p>
<pre><code class="c++">struct Node
{
    int key;
    Node *leftChild;
    Node *rightChild;
    Node *parent;
}
</code></pre>
<p>只包括主要的数据，至于可能存在的其它卫星数据之类的与讨论无关，就不包括了。<br>而按照上面的定义也知道，我们将假定二叉树是按照链式结构存储的，因此其迭代器类型可视为一个双向迭代器而非随机迭代器。</p>
<p>从定义中可以看出，每个结点还有一个指向其父结点的属性，对于根结点，该值为<code>null</code>。并非所有的二叉树结点定义中都需要这个属性，但是为了完成前面题目中的要求，我们这里的讨论中需要它；有这个属性，我们才可以在<code>O(1)</code>时间内从一个结点导航到它的父结点。</p>
<h2 id="u9012_u5F52_u65B9_u5F0F"><a href="#u9012_u5F52_u65B9_u5F0F" class="headerlink" title="递归方式"></a>递归方式</h2><p>遍历一颗二叉树，我们最容易想到的就是递归方式了。因为二叉树本身的定义也符合递归思想，而其实，一般书籍中对二叉树定义都是采用递归方式的。</p>
<blockquote>
<p><strong>二叉树</strong><em>T</em>是定义在有限结点集上的结构，它</p>
<ul>
<li>或者不包含任何结点，</li>
<li>或者包含三个<strong>不相交</strong>的结点集合：一个<strong>根</strong>结点，一颗称为<strong>左子树</strong>的二叉树，以及一颗称为<strong>右子树</strong>的二叉树。</li>
</ul>
</blockquote>
<p>因此我们在遍历的时候，也可以很容易根据定义来。下面给出<strong>二叉树先根递归方式遍历</strong>伪代码：</p>
<pre><code class="c++">void visit(const Node *node)
{
    if (nullptr == node) return;

    cout &lt;&lt; node-&gt;key;
    visit(node-&gt;leftChild);
    visit(node-&gt;rightChild);
}
</code></pre>
<p>首先输出根结点的值，然后分别输出其左右子树。当达到叶节点的时候，递归开始回升。</p>
<h2 id="u975E_u9012_u5F52_26amp_3B_u4E0D_u9650_u5236_u5B58_u50A8_u7A7A_u95F4"><a href="#u975E_u9012_u5F52_26amp_3B_u4E0D_u9650_u5236_u5B58_u50A8_u7A7A_u95F4" class="headerlink" title="非递归&amp;不限制存储空间"></a>非递归&amp;不限制存储空间</h2><p>其实这也就是一般的将递归调用过程优化为迭代过程所使用的方法，一般思路就是我们使用一个栈来存储之前在递归过程中间产生的临时值，然后调整一下调用过程就行。</p>
<p>这里我们主要就是要将迭代过程中我们经过的根结点按照顺序依次保存起来，然后当到达叶节点的时候开始退栈。下面是<strong>非递归、使用栈作为辅助结构</strong>的二叉树先根遍历伪代码：</p>
<pre><code class="c++">void print(const Node *node)
{
    std::stack&lt;const Node*&gt; stack;

    while (node || !stack.empty())
    {
        while (node)
        {
            stack.push(node);
            cout &lt;&lt; node-&gt;key;
            node = node-&gt;leftChild;
        }
        node = stack.top();
        stack.pop();
        node = stack-&gt;rightChild;
    }
}
</code></pre>
<p>非递归过程用一个栈结构作为辅助，来存储在递归过程中函数参数中所传递的信息（函数参数通常也是通过栈传递的）。这里的基本过程也就是我们接下来讨论的基础。</p>
<h2 id="u975E_u9012_u5F52_26amp_3B_u5E38_u91CF_u989D_u5916_u5B58_u50A8_u7A7A_u95F4"><a href="#u975E_u9012_u5F52_26amp_3B_u5E38_u91CF_u989D_u5916_u5B58_u50A8_u7A7A_u95F4" class="headerlink" title="非递归&amp;常量额外存储空间"></a>非递归&amp;常量额外存储空间</h2><p>现在回到正题，按照题目要求，我们只能使用固定量的额外存储空间，因此，栈是不能使用了。但是我们在使用栈作为辅助结构的时候，其实目的是为了方便遍历过程的回退（即从孩子结点回到父结点），因此，这里我们也可以借用这个基本流程，但是需要改变的是回退方法。</p>
<p>没有了栈，我们就要自己想办法从孩子结点正确的回退到下一个需要被访问的<strong>祖先结点</strong>，按照先根遍历方式的话，我们就需要回退到<strong>下一个具有右孩子结点的祖先结点</strong>了。</p>
<ul>
<li>如果我们当前位于一个左子树上，那么回退很简单，只需要不断的往父结点方向搜索直到找到第一个具有右子树的结点或者到达根节点的<code>parent</code>而结束遍历；</li>
<li>但是如果我们是从右子树遍历过来的，那么就不能简单的采用左子树回退方式了，因为那样会导致死循环（从右子树回退到其父结点，然后发现存在右子树，又遍历这个右子树），这时候我们就需要首先判断当前结点是否为其父结点的右孩子，如果是，就直接回退，一直到父结点为<code>nullptr</code>或者不是右孩子为止，也就是我们回退到了一个左子树路径上，这个时候，我们就可以按照左子树中回退方式，来寻找下一个合适的结点了。</li>
</ul>
<p>上面提到的是回退，而向下的过程则很简单了，就是按照先序遍历顺序，对每个节点都沿着其左子树一直遍历到底即可。</p>
<p>按照上面的分析，可以写出代码：</p>
<pre><code class="c++">void print(Node *p)
{
    while (p)
    {
        while (p-&gt;leftChild)
        {
            cout &lt;&lt; p-&gt;key;
            p = p-&gt;leftChild;
        }
        cout &lt;&lt; p;

        if (p.rightChild)
        {
            p = p.rightChild;
            continue;
        }

        // 到达叶节点，开始回退
        // 回退右子树路径上的结点
        while (p.parent &amp;&amp; p.parent.rightChild == p)
        {
            p = p.parent;
        }
        // 回退左子树路径上的结点
        p = p.parent;
        while (p &amp;&amp; !p.rightChild)
        {
            p = p.parent;
        }

        if (p) p = p.rightChild;
    }
}
</code></pre>
<p>上面过程中除了参数所占用的一个指针空间之外，没有使用其它额外的存储空间。而对过程的分析可以知道，在遍历过程中，我们会对所有的<strong>非叶子结点</strong>访问过两次，一次是向下遍历，一次是回退时候；而对所有的<strong>叶子结点</strong>，我们只需要访问一次，也就是输出它的信息。因此从这个非形式化的分析可以得知，上面代码中循环次数大约为<code>3n/2</code>，所以整个过程的时间复杂度为<code>O(n)</code>。</p>
<h3 id="u53E6_u4E00_u79CD_u601D_u8DEF"><a href="#u53E6_u4E00_u79CD_u601D_u8DEF" class="headerlink" title="另一种思路"></a>另一种思路</h3><p>在这里再附加上另一种思路，更详细内容（代码）见<a href="http://clrs.skanev.com/10/04/05.html" target="_blank" rel="external">此链接</a>。</p>
<blockquote>
<p>对于基本的遍历，我们按照下列规则进行：</p>
<ul>
<li>如果我们从父结点出来，那么在访问其左孩子结点；</li>
<li>如果我们从一个左孩子结点出来，那么接下来访问那个对应的右孩子结点；</li>
<li>如果我们离开一个右孩子结点，那么接下来就将指针移到其父结点上。</li>
</ul>
<p>而为了处理那些少于两个孩子结点的情况，当下列对应条件满足时，我们转移到相应的步骤：</p>
<ul>
<li>如果一个结点只有右孩子，那么当访问完这个结点之后，接下来访问其右孩子结点；</li>
<li>如果一个结点只有左孩子，当我们访问完这个左孩子结点之后，返回其父结点；</li>
<li>如果一个结点没有孩子，返回其父结点。</li>
</ul>
</blockquote>
<p><strong>注意上面所说父结点、孩子结点均是相对于当前正在被遍历的结点来说的。</strong></p>
<p>只是在该页面最后附加的C代码好像有点问题，对于那个全局的额外占用的一个数组空间的使用，只有不断写入，却从没调用过那个重置方法。如果去掉那个<code>store(key)</code>的调用，然后在<code>if</code>分支中进行输出（<code>if</code>分支花括号之后，其它语句开始之前），也可以完成遍历。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>今天看到了<strong>《算法导论（第三版）》</strong>第三部分中第十章内容，在<code>10.4节</code>遇到了一个题目，要求在<code>O(n)</code>（即上限渐进时间为线性）时间内非递归遍历二叉树，并且只能使用固定量的额外存储空间。</p>
<blockquote>
<p><strong>10.4-5</strong> 给定一个<em>n</em>结点的二叉树，写出一个<code>O(n)</code>时间的非递归过程，将该树每个节点的关键字输出。要求除该树本身的存储空间外只能使用固定量的额外存储空间，且在过程中不得修改该树，即使是暂时的修改也不允许。</p>
</blockquote>
<p>部分理解需要联系上下文，比如说关键字是前文定义的一个树的结点通常具有的结构，包括一个关键字<code>key</code>、一个左孩子结点指针<code>leftChild</code>、一个右孩子结点指针<code>rightChild</code>以及一个父结点指针<code>parent</code>，另外带有可选的卫星数据。</p>]]>
    
    </summary>
    
      <category term="Algorithm" scheme="http://3meng.github.io/tags/Algorithm/"/>
    
      <category term="Binary Tree" scheme="http://3meng.github.io/tags/Binary-Tree/"/>
    
      <category term="Algorithm" scheme="http://3meng.github.io/categories/Algorithm/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[最大子数组查找算法]]></title>
    <link href="http://3meng.github.io/2016/02/08/Algorithm-of-Finding-Maximum-SubArray/"/>
    <id>http://3meng.github.io/2016/02/08/Algorithm-of-Finding-Maximum-SubArray/</id>
    <published>2016-02-08T06:10:07.000Z</published>
    <updated>2016-02-22T14:16:01.000Z</updated>
    <content type="html"><![CDATA[<p>最近开始看<strong>《算法导论（第三版）》</strong>这本书，在第4章讲解<em>分治策略</em>的时候，举了一个例子：<strong>最大子数组</strong>问题（<code>4.1节</code>），简单来说，就是在一个给定的数组中，找出一个非空<strong>连续</strong>子数组，使这个数组中元素的<strong>总和最大</strong>，我们称这样的子数组为<strong>最大子数组</strong>。</p>
<p>在书中讲解分析了两种解决方法，一种就是最容易想到的暴力求解方法，另一种自然就是主题相关的分治法；然后在结束的时候，提到了可以实现一种更快速的线性时间的算法，这里将给出我的思路（原书这里描述有误，不知道是作者/译者笔误还是印刷错误）。</p>
<a id="more"></a>
<p>下面先给出书中提到的两种方案，然后附上最后的线性时间的解决方法。</p>
<blockquote>
<p>对于讨论的子数组问题，只有当被查找的数组中存在负数的时候才有意义，因为对于一个全部为正数的数组，最大子数组自然是其本身。</p>
</blockquote>
<p><strong>2016年2月10日更新：加入另一种线性时间的代码（来源于网络，地址见下文）和分析。</strong></p>
<h2 id="u66B4_u529B_u6C42_u89E3_u65B9_u6CD5"><a href="#u66B4_u529B_u6C42_u89E3_u65B9_u6CD5" class="headerlink" title="暴力求解方法"></a>暴力求解方法</h2><p>暴力求解，自然就是<strong>枚举</strong>所有的子数组，计算每个子数组的和，然后查找出和最大的那个子数组。对于一段长度为n的数组，我们需要检查<code>n + (n-1) + ... + 1 = n(n+1)/2</code>个子数组，时间复杂度可以表示为<code>O(n^2)</code>，另一方面，虽然计算一个子数组之和所需的时间是线性的，但是当计算所有子数组之和时，我们可以通过缓存之前计算出的子数组和来计算当前子数组的和，使得每个子数组和的计算时间为<code>O(1)</code>，因此暴力求解方法所花费的时间为<code>O(n^2)</code>。</p>
<blockquote>
<p>暴力求解算法很简单，就不附加相关代码了。</p>
</blockquote>
<h2 id="u5206_u6CBB_u7B56_u7565_u6C42_u89E3_u65B9_u6CD5"><a href="#u5206_u6CBB_u7B56_u7565_u6C42_u89E3_u65B9_u6CD5" class="headerlink" title="分治策略求解方法"></a>分治策略求解方法</h2><p>假定我们需要寻找子数组<code>A[low..high]</code>的最大子数组。</p>
<blockquote>
<p>下面的描述中，也将采用这种描述数组的方式，方括号中使用一对由<code>..</code>分开的整数（变量），分别指示数组下标的下限和上限（包含上下限）。</p>
</blockquote>
<p>使用<strong>分治策略</strong>意味着需要将子数组划分为两个规模尽量相等的子数组，将子数组<code>A[low..high]</code>的中央位置下标记为<code>mid</code>，然后考虑求解两个子数组<code>A[low..mid]</code>和<code>A[mid+1..high]</code>，那么<code>A[low..high]</code>的任何连续子数组<code>A[i..j]</code>所处的位置必然是以下三种情况之一：</p>
<ul>
<li>完全位于子数组<code>A[low..mid]</code>中，因此 <em>low &lt;= i &lt;= j &lt;= high</em>。</li>
<li>完全位于子数组<code>A[mid+1..high]</code>中，因此 <em>mid &lt; i &lt;= j &lt;= high</em>。</li>
<li>跨越了中点，因此 <em>low &lt;= i &lt;= mid &lt; j &lt;= high</em>。</li>
</ul>
<p>因此，<code>A[low..high]</code>的一个最大子数组所处位置必然是这三种情况之一。实际上，<code>A[low..high]</code>的一个最大子数组必然是完全位于<code>A[low..mid]</code>中、完全位于<code>A[mid+1..high]</code>中或者跨越中点的<strong>所有</strong>子数组中和的最大者。我们可以递归的求解<code>A[low..mid]</code>和<code>A[mid+1..high]</code>的最大子数组，因为这两个子问题仍是最大子数组问题，只是规模更小。因此剩下的问题就是寻找跨越中点的最大子数组，然后在三种情况中选择最大者。</p>
<blockquote>
<p>寻找跨越中点的最大子数组，并不是原问题的规模更小的实例，因为它加入了限制：求和的子数组必须跨越中点，因为任何跨越中点的子数组都是由两个子数组<code>A[i..mid]</code>和<code>A[mid+1..j</code>组成，其中 <em>low &lt;= i &lt;= mid</em> 且 <em>mid &lt; j &lt;= high</em>。因此我们只需要找出形如<code>A[i..mid]</code>和<code>A[mid+1..j]</code>的最大子数组，然后将其合并即可。</p>
</blockquote>
<h3 id="FIND_MAX_CROSSING_SUBARRAY"><a href="#FIND_MAX_CROSSING_SUBARRAY" class="headerlink" title="FIND_MAX_CROSSING_SUBARRAY"></a>FIND_MAX_CROSSING_SUBARRAY</h3><p>使用过程<code>FIND_MAX_CROSSING_SUBARRAY</code>描述这个方法，这个过程接收数组<em>A</em>和下标<em>low</em>、<em>mid</em>、<em>high</em>为输入，返回一个具有三个元素的元组，这三个元素分别表示最大子数组的上下边界以及值得和。</p>
<p>下面给出伪代码：</p>
<pre><code class="python">FIND_MAX_CROSSING_SUBARRAY(A, low, mid, high)
left_sum = -1
sum = 0
max_left = mid
for (i = mid; i &gt;= low; --i)
    sum += A[i]
    if (sum &gt; left_sum)
        left_sum = sum
        max_left = i

right_sum = -1
sum = 0
max_right = mid + 1
for (j = mid + 1; j &lt;= high; ++j)
    sum += A[j]
    if (sum &gt; right_sum)
        right_sum = sum
        max_right = j

return (max_left, max_right, left_sum + right_sum)
</code></pre>
<p>两个循环分别向左向右搜索使<code>left_sum</code>和<code>right_sum</code>取值最大的下标，然后返回结果：子数组<code>A[max_left..max_right]</code>和相应的和<code>left_sum + right_sum</code>。可以很容易看出上面两个循环迭代一共执行了<code>(mid - lwo + 1) + (high - mid) = high - low + 1 = n</code>次，因此这个计算过程的时间复杂度可以记为<code>O(n)</code>。</p>
<h3 id="FIND_MAXIMUM_SUBARRAY"><a href="#FIND_MAXIMUM_SUBARRAY" class="headerlink" title="FIND_MAXIMUM_SUBARRAY"></a>FIND_MAXIMUM_SUBARRAY</h3><p>有了这个<code>FIND_MAX_CORSSING_SUBARRAY</code>在手，就可以设计求解最大子数组的分治算法的伪代码了：</p>
<pre><code class="python">FIND_MAXIMUM_SUBARRAY(A, low, high)
if (high == low)
    return (low, high, A[low])  // 递归底层，开始回归
else
    mid = (low + high) / 2  // C语言整数计算方式，结果向下取整
    (left_low, left_high, left_sum) = FIND_MAXIMUM_SUBARRAY(A, low, mid)
    (right_low, right_high, right_sum) = FIND_MAXIMUM_SUBARRAY(A, mid+1, high)
    (cross_low, cross_high, cross_sum) = FIND_MAX_CROSSING_SUBARRAY(A, low, mid, high)

    if (left_sum &gt;= right_sum &amp;&amp; left_sum &gt;= cross_sum)
        return (left_low, left_high, left_sum)
    if (right_sum &gt;= left_sum &amp;&amp; right_sum &gt;= cross_sum)
        return (right_low, right_high, right_sum)
    else
        return (cross_low, cross_high, cross_sum)
</code></pre>
<p>初始调用<code>FIND_MAXIMUM_SUBARRAY(A, 0, A.length-1)</code>。</p>
<p>时间复杂度不再细述，由递归深度<code>lg(n)</code>可以得出过程<code>FIND_MAXIMUM_SUBARRAY</code>的时间复杂度为<code>O(n*lg(n))</code>。</p>
<h2 id="u4E00_u4E2A_u7EBF_u6027_u65F6_u95F4_u7684_u7B97_u6CD5"><a href="#u4E00_u4E2A_u7EBF_u6027_u65F6_u95F4_u7684_u7B97_u6CD5" class="headerlink" title="一个线性时间的算法"></a>一个线性时间的算法</h2><p>在书中分治算法分析结束的时候，提到了对于这个求解最大子数组的问题，存在一个线性时间的算法，并在附加的练习题目中给出了提示：</p>
<blockquote>
<p>使用如下思想为最大子数组问题设计一个非递归的、线性时间的算法。从数组的左边界开始，由左至右处理，记录到目前为止已经处理过的最大子数组。若已知<code>A[0..j]</code>的最大子数组，那么基于如下性质将解扩展为<code>A[0..j+1]</code>的最大子数组：<code>A[0..j+1]</code>的最大子数组要么是<code>A[0..j]</code>的最大子数组，要么是某个子数组<code>A[i..j+1]</code>（<em>0 &lt;= i &lt;= j+1</em>）。在已知<code>A[0..j]</code>的最大子数组的情况下，可以在<strong><em>线性时间</em></strong>内找出形如<code>A[i..j+1]</code>的最大子数组。</p>
</blockquote>
<p>上面引用中最后一句话中被标记为加粗斜体的文字，是我认为书中记录失误的地方，很显然，如果找出最大子数组的时间仍然是线性的，那么总的时间必然是<code>O(n^2)</code>，可以想象为一个双重循环样式。而实际上，通过缓存一些中间结果的方式，我们可以做到在<strong>常量时间</strong>内从前一个最大子数组推出下一个最大子数组。</p>
<h3 id="u5206_u6790"><a href="#u5206_u6790" class="headerlink" title="分析"></a>分析</h3><p>根据题目的提示，我们很容易可以推断出这个迭代过程中，第一个最大子数组就是<code>A[0]</code>，然后开始下一步迭代。在我们将数组扩展到下一个元素的时候（从<code>A[0..j]</code>扩展到<code>A[0..j+1]</code>），那么下一个最大子数组将只有以下两种形式：</p>
<ul>
<li>包含原来的最大子数组。</li>
<li>不包含原来的最大子数组。</li>
</ul>
<p>而不会出现跨越原来的最大子数组的情况。我们将原来的最大子数组记为<code>A[m..n]</code>，假设可以跨越原来的最大子数组的话，我们将新的最大子数组记为<code>A[x..y]</code>，其中<em>m &lt; x &lt;= n</em>且<em>n &lt;= y</em>，那么很显然我们可以构造一个新的子数组<code>A[m..y]</code>，这个子数组完全包含了原来的最大子数组<code>A[m..n]</code>，<code>A[x..y]</code>和<code>A[m..y]</code>可表示如下：</p>
<pre><code class="python">A[x..y] = A[x..n] + A[n..y] // 去掉重合的A[n]
A[m..y] = A[m..n] + A[n..y] // 去掉重合的A[n]
</code></pre>
<p>由于<code>A[x..n]</code>被<strong>最大</strong>子数组<code>A[m..n]</code>所包含，那么很容易得知<code>A[m..n]</code>的和大于<code>A[x..n]</code>的和，所以可推得<code>A[m..y]</code>的和大于<code>A[x..y]</code>的和，那么<code>A[x..y]</code>就不是最大子数组了，与假设矛盾，因此不存在部分包含原来的最大子数组的情况。</p>
<p>现在我们考虑推导下一个最大子数组的问题。首先要想通下面几条规则：</p>
<blockquote>
<ul>
<li>如果包含原来的最大子数组的话，那么下一个最大子数组起始下标必然等于原来的最大子数组起始下标。</li>
<li>如果不包含原来的最大子数组的话，那么下一个最大子数组起始下标必然是原来的最大子数组结束下标之后的某一个<strong>正数</strong>的位置。不可能是负数，那是在做负功。</li>
</ul>
</blockquote>
<h3 id="u6C42_u89E3"><a href="#u6C42_u89E3" class="headerlink" title="求解"></a>求解</h3><p>为了方便说明，从现在开始，我们将原来的最大子数组记为<code>A[p..q]</code>，而下一个最大子数组记为<code>A[r..s]</code>。<strong>请丢掉上面反证法中定义的各种东西</strong>。</p>
<p>那么现在第一个问题是如何确定下一个最大子数组是否要包含原来的最大子数组呢？先考虑一种最简单的情况，根据最大子数组的定义，如果包含的话（<code>p == r &amp;&amp; s &gt; q</code>），很显然必须有<code>A[q+1..s]</code>的和大于0，否则岂不是做了负功，让<code>A[r..s]</code>的和比<code>A[p..q]</code>的和还要小。</p>
<blockquote>
<p>因此可以顺便提一下，当我们遍历数组元素的时候，就可以顺便计算出上面需要的<code>A[q+1..s]</code>的和并缓存了，而不用等到需要的时候又再去重复遍历计算。</p>
</blockquote>
<p>而在这里，我们也可以确定触发计算下一个最大子数组的几乎必要的条件：当前元素必须为正数，如果为负数，我们只需要简单的将其用来计算<code>A[q+1..s]</code>的和；否则如果计算确定需要包含的话，那么可以很简单的将原最大子数组“扩容”即可，也就是将结束下标更改为当前遍历时刻的元素下标，并重置各种中间缓存变量的值，比如我们缓存的从当前最大子数组结束下标到下一个可能的最大子数组开始坐标之间的元素之和，就需要重置为0了。</p>
<p>那么第二个问题也来了，当我们确定不包含原来的最大子数组之和，那么下一个最大子数组的起始下标该如何获取？按照上面说的，这个位置是个正数元素，但未必是原来的最大子数组结束之后的第一个正数位置，考虑下面的序列：</p>
<blockquote>
<p>8, -10, 3, -4, 9</p>
</blockquote>
<p>如果当前最大子数组为第一个元素，那么当遍历到第三个元素（值为3）的时候，由于<code>-10 + 3 = -7 &lt; 0</code>，因此新的最大子数组不可能为<code>8, -10, 3</code>，而<code>3 &lt; 8</code>，所以新的最大子数组也不可能为<code>3</code>，我们需要继续遍历，但是要记录当前这个正数位置，万一它后面就是个非常大的正数呢。当然在这里，为了说明情况，我给它后面弄了个比-3还小的元素，因此我们就可以丢掉刚刚记录的正数位置了，因为没有用，如果新的最大子数组不包含原来的话，那么也不应该从这个记录的正数位置开始，因为它的值被后面的负数“中和”了，如果带上它，我们将会被迫同时带上它后面的那个负数，结果就很容易想到了。</p>
<p>所以继续遍历，第五个元素是9，是个正数，我们可以更新记录位置的那个变量了。很显然，<code>-10 + 3 - 4 + 9 = -2 &lt; 0</code>，新的可能的最大子数组开始位置就应该是刚刚记录的正数位置了，而<code>9 &gt; 8</code>，因此，新的最大子数组起始位置应该为第五个元素了（当然，目前结束位置也应该是）。</p>
<p><strong>现在考虑一点例外。</strong></p>
<p>把上面的结论推广，也就是从当前最大子数组开始考虑，如果为了方便思考的话，可以将当前最大子数组等价替换为当前位置的一个元素，其值等于最大子数组的和。那么有时候即使上面的<code>A[q+1..s]</code>计算为正，我们也不能直接包含当前最大子数组。考虑下面这个序列：</p>
<blockquote>
<p>6, -8, 10</p>
</blockquote>
<p>最开始的最大子数组为<code>6</code>，然后我们按照前面的计算方式，可以得到<code>-8 + 10 = 2 &gt; 0</code>，但是这个时候，很明显可以看出正确的最大子数组应该为<code>10</code>，而不是<code>6, -8, 10</code>。至于原因，也很容易根据上面计算需要的正数位置的方法来解释，因为<code>6 - 8 = -2</code>，所以我们的下一个可能的最大子数组不可以从<code>6</code>开始，这个正数指针（此处不一定代表C语言中的那种指针，只是意义类似）应该被更新到下一个正数，然后继续进行相似的验证。</p>
<p>到这里，恰好统一了，初始情况下我们的正数指针应该指向第一个最大子数组的起始位置。而任何时候我们更新了当前最大子数组，也需要同步设置这个正数指针的值。而只要这个指针的值不等于当前最大子数组的起始地址，说明如果需要更新最大子数组的信息的话，需要从当前这个正数地址开始。</p>
<p>最后，还有个例外也需要考虑，那就是数组中全负数的情况，这时候就完全不需要上面这么麻烦了，只需要找出整个序列的最大值即可。</p>
<h3 id="u603B_u7ED3"><a href="#u603B_u7ED3" class="headerlink" title="总结"></a>总结</h3><blockquote>
<ul>
<li>当正数指针值等于当前最大子数组的起始地址时，如果从当前最大子数组结束后被遍历元素之和大于0，则需要“扩容”当前最大子数组。</li>
<li>当正数指针值不等于当前最大子数组的起始地址时，如果从这个正数指针开始的一个序列元素的和大于当前子数组的和，则需要将这个序列设置为当前最大子数组。</li>
<li>当开头一段序列全部是负数的时候，可以忽略掉这些元素；作为一个特例的情况，序列如果全部是负数，那么只需要返回其中的最大值。</li>
</ul>
</blockquote>
<p>好了，现在基本分析可以说已经完毕了，剩下的还是通过代码来理顺吧。</p>
<p>伪<code>C++</code>代码</p>
<pre><code class="c++">tuple&lt;unsigned int, unsigned int, int&gt; find_maximum_subarray(vector&lt;int&gt; &amp;array)
{
    /* 不考虑异常等情况，比如array为空之类的 */
    unsigned int start = 0;
    unsigned int end = 0;
    int cur_sum = array[0];

    unsigned int i = 1;
    if (cur_sum &lt;= 0)
    {
        for (; i &lt; array.size() &amp;&amp; array[i] &lt;= 0; ++i)   // 略过开始的非正数序列
        {
            if (cur_sum &lt; array[i])
            {
                cur_sum = array[i];
                start = i;
            }
        }

        if (i == array.size())  // 全负数特例
        {
            return tuple&lt;unsigned int, unsigned int, int&gt;(start, start, cur_sum);
        }
        cur_sum = array[i];
        start = end = i;
    }


    int temp_sum = 0;   // 缓存当前最大子数组后面被遍历元素之和
    unsigned int next_start = start;  // 下一个候选最大子数组，以正数开始
    int next_sum = cur_sum;   // 下一个候选最大子数组的累积和

    for (; i &lt; array.size(); ++i)
    {
        temp_sum += array[i];

        if (array[i] &gt; 0 &amp;&amp; next_sum &lt;= 0)
        {
            /* 出现正数被负数抵消情况 */
            next_start = i;
            next_sum = array[i];
        }
        else
        {
            next_sum += array[i];
        }

        if (next_start == start &amp;&amp; temp_sum &gt; 0)
        {
            end = i;
            cur_sum += temp_sum;
            temp_sum = 0;
            next_sum = cur_sum;
        }
        else if (next_start != start &amp;&amp; next_sum &gt; cur_sum)
        {
            start = next_start;
            end = i;
            cur_sum = next_sum;
            temp_sum = 0;
        }
    }

    return tuple&lt;unsigned int, unsigned int, int&gt;(start, end, cur_sum);
}
</code></pre>
<p>大概代码最终如上，还没有进行测试，也许考虑仍有不周。但是就上述代码来说，运行时间为线性的，第一个循环是针对开始的负数序列，同时也包括了全负数的形式。而当进入第二个循环的时候，两个保存元素和的变量<code>cur_sum</code>、<code>next_sum</code>均为正值，因此这个循环中的代码可以只针对正数/正负数混合优化，而不用考虑有全负数序列，也不用测试<code>cur_sum</code>等是否为负。而通过变量<code>i</code>的值可知，迭代次数一共为n（==<code>array.size()</code>）次，因此，整个过程的时间复杂度为<code>O(n)</code>。</p>
<h3 id="u53E6_u4E00_u79CD_u89E3_u6CD5"><a href="#u53E6_u4E00_u79CD_u89E3_u6CD5" class="headerlink" title="另一种解法"></a>另一种解法</h3><p>在<a href="http://clrs.skanev.com/04/01/05.html" target="_blank" rel="external">clrs.skanev.com</a>上又发现了另外一种解决方法，使用<code>C</code>语言实现；<strong>相比较上面的方法，思路更加通俗易懂</strong>，可以很容易的从简单的思考中想到并优化获得最终的优化过的代码。</p>
<p>下面贴出页面的代码，然后简单分析一下。</p>
<pre><code class="c">typedef struct 
{
    unsigned left;
    unsigned right;
    int sum;
} max_subarray;

max_subarray find_maximum_subarray(int A[], unsigned low, unsigned high) 
{
    max_subarray suffixes[high - low];

    suffixes[0].left = low;
    suffixes[0].right = low + 1;
    suffixes[0].sum = A[low];

    for (int i = low + 1; i &lt; high; i++) 
    {
        if (suffixes[i - 1].sum &lt; 0) 
        {
            suffixes[i].left = i;
            suffixes[i].right = i + 1;
            suffixes[i].sum = A[i];
        } 
        else 
        {
            max_subarray *previous = &amp;suffixes[i - 1];
            suffixes[i].left = previous-&gt;left;
            suffixes[i].right = i + 1;
            suffixes[i].sum = previous-&gt;sum + A[i];
        }
    }

    max_subarray *max = &amp;suffixes[0];

    for (int i = low + 1; i &lt; high; i++) 
    {
        if (max-&gt;sum &lt; suffixes[i].sum) 
        {
            max = &amp;suffixes[i];
        }
    }

    return *max;
}
</code></pre>
<p>这段代码中一共需要对数组遍历两次，但是每次迭代过程中运行的代码也相对更少一些，与<code>C++</code>版本相比，在时间效率上相差不大，对于全正数序列，这段<code>C</code>代码相对要快一点，而如果是一个全负数序列，上面的<code>C++</code>版本运行应该更快，而其它情况下，则需要视实际序列情况而定，但总的来说，差别不大。而在空间复杂度上，<code>C</code>版本的代码很明显通常就需要更多的空间了，因为在第十行声明了一个长度等于<code>n</code>（==<code>high-low</code>）、大小为<code>sizeof(max_subarray) * n</code>的数组，相比而言，<code>C++</code>版本中总共只使用了大约<code>7 * sizeof(int)</code>字节的空间。</p>
<blockquote>
<p>除此之外，这段C代码由于使用了不定长数组语法，因此需要能支持<code>C99</code>标准的编译器来进行编译，当然，这在现在基本不是问题，只不过目前很多编译器即使支持部分或完整的<code>C99</code>标准，但默认编译选项依然是使用<code>C89</code>（<code>ISO C</code>/<code>ANSI C</code>）标准，需要注意查看。</p>
</blockquote>
<p>回到分析代码上，首先定义了一个结构体用于存储子数组的信息，<code>left</code>指示了子数组开始位置，<code>right</code>代表了子数组结束位置的下一位，注意这个位置是个哨兵位置，并不应该参与子数组和<code>sum</code>的计算。在方法体中声明的<code>suffixes</code>数组中，<code>suffixes[i]</code>存储在原数组<code>A</code>中以<code>A[i]</code>为结束位置的最大子数组的信息（所以<code>suffixes[i].right = i + 1</code>）。</p>
<p>因此，从最简单粗暴的方法入手，要获取以<code>A[i]</code>作为结束位置的最大子数组信息，只需要向前遍历计算就可以，但是这样一来，时间复杂度就达到了<code>O(n^2)</code>了。所以我们就要想办法利用缓存，利用上次计算的数据，在<code>O(1)</code>时间内计算出下一个最大子数组信息，分析一下上面的过程，每次都需要前向遍历，而实际上，每次遍历只比上一次同样的过程多分析一个元素：第一次是<code>A[0]</code>，第二次则是<code>A[0..1]</code>，第三次则是<code>A[0..2]</code>……一直重复，那么我们应该想办法利用上一次的结果以及当前的元素，计算出本次结果。借用上面的分析，如果一个最大子数组开始位置要不同于前一次的结果，那么只有当前一次的结果小于0，否则应该直接在前一次的结果上继续累加，只有前一次结果小于0的时候，才需要以当前位置作为新的开始位置。</p>
<blockquote>
<p>需要始终记住的是：当前元素必须作为结束位置，因此其实我们只有两种选择，要不加入前一次的结果（因为前一次的结果其实就相当于不包括当前元素的遍历结果），要不单独起始。而很容易想到，如果前一次结果已经被加到为负数了，当前元素无论为正为负，都肯定比加一个负数所得结果要大。</p>
</blockquote>
<p>因此出了第一次我们直接把起始元素的值作为<code>sum</code>的值，之后每次只需要利用前一次的结果经过常量时间的运算即可得到本次的结果。当所有结果都计算出来了之后，就很简单了，只需要一次寻找最大值得操作即可。</p>
<p>这段<code>C</code>代码很容易就可以证明其正确性，而有这段分析，类比之下，也许上面的<code>C++</code>算法的正确性也可以更容易验证了。</p>
<h2 id="u5C3E_u6CE8"><a href="#u5C3E_u6CE8" class="headerlink" title="尾注"></a>尾注</h2><p>心血来潮，偶然为之。在最后的完成线性时间的算法时，也是经历了不断的修正，也许结果仍然不完善，待测试。最后所为算法并没有完全按照题目的提示，但是第二个循环中最后的<code>if</code>和<code>else if</code>语句中，由<code>end = i</code>可知，这两个判断都是为了从当前最大子数组获取下一个具有<code>A[i..j+1]</code>形式的最大子数组，而在条件判断之外则没有更新过最大子数组信息，也就是依然等于<code>A[0..j]</code>的最大子数组。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>最近开始看<strong>《算法导论（第三版）》</strong>这本书，在第4章讲解<em>分治策略</em>的时候，举了一个例子：<strong>最大子数组</strong>问题（<code>4.1节</code>），简单来说，就是在一个给定的数组中，找出一个非空<strong>连续</strong>子数组，使这个数组中元素的<strong>总和最大</strong>，我们称这样的子数组为<strong>最大子数组</strong>。</p>
<p>在书中讲解分析了两种解决方法，一种就是最容易想到的暴力求解方法，另一种自然就是主题相关的分治法；然后在结束的时候，提到了可以实现一种更快速的线性时间的算法，这里将给出我的思路（原书这里描述有误，不知道是作者/译者笔误还是印刷错误）。</p>]]>
    
    </summary>
    
      <category term="Algorithm" scheme="http://3meng.github.io/tags/Algorithm/"/>
    
      <category term="Maximum SubArray" scheme="http://3meng.github.io/tags/Maximum-SubArray/"/>
    
      <category term="Algorithm" scheme="http://3meng.github.io/categories/Algorithm/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[将Hexo从Windows迁移到OS X]]></title>
    <link href="http://3meng.github.io/2016/01/14/Migrate-hexo-from-Windows-to-OS-X/"/>
    <id>http://3meng.github.io/2016/01/14/Migrate-hexo-from-Windows-to-OS-X/</id>
    <published>2016-01-14T09:49:00.000Z</published>
    <updated>2016-02-28T13:34:29.000Z</updated>
    <content type="html"><![CDATA[<p>几个月之前就想过，在 <strong>OS X</strong> 上配置一下<code>Hexo</code>，方便偶尔更新一下文章什么的，只是这么长时间了一拖再拖，总是在做着各种其它的事情，甚至Mac都很久没打开过了……</p>
<blockquote>
<p><strong>题外话：</strong>Mac的设计抛开不说，配合<strong>OS X</strong>用起来体验也不错，重点是续航，这都最少一个多月没开，现在开了，电量还有<em>60%</em>多，所有的App状态都还是之前合盖时候的状态。</p>
<p>顺便也得说一下，<strong>OS X</strong>上应用是少了一点，但是能用的基本都是布局很精美，也许部分是系统的一贯主题特色，而<strong>Retina</strong>屏幕的显示效果也是相当赞的。当然，用的也不多，除了系统那个<code>Finder</code>是个真尴尬的东西之外，基本其它的都感觉不错，比如现在正在用来编辑此文的<code>MacDown</code>，除了主题差了一点，各种显示效果是真的不错，文本编辑起来也是很舒服。</p>
</blockquote>
<p>扯远了，继续上文。最近准备弄弄<code>C++</code>，所以又打开了Mac，当然不是说<strong>Windows</strong>上面做不了开发，毕竟<code>Visual Studio</code>不是吹的，只是这次有点问题，一个依赖的项目在<strong>Windows</strong>上编译有问题，使用<code>MinGW</code>+<code>Clion</code>一直编译不通过，连接失败；然后我想着到<strong>OS X</strong>上试试，结果稍微改了一下<code>CMakeLists.txt</code>文件，就通过编译成功执行了。于是将项目搬到了Mac上面。</p>
<p>然后昨天又弄了一下，又将<code>Minecraft</code>给弄到<strong>OS X</strong>上面跑了，这下也基本可以单用<strong>OS X</strong>一阵子了，所以才有了标题所说的，想着准备把<code>Hexo</code>也弄过来了。这次也就没再往下拖延了。</p>
<a id="more"></a>
<h2 id="u8FC1_u79FB"><a href="#u8FC1_u79FB" class="headerlink" title="迁移"></a>迁移</h2><p>说起来当初在<strong>Windows</strong>上面配置<code>Hexo</code>还是<em>2015年3月</em>左右的时候，现在都几乎快忘了当初都对<code>Hexo</code>和上面的自定义主题做了什么修改了，特别是还有部分代码也做了改动，而正是因为这，所以一直就往后拖，没有迁移到Mac上……</p>
<p>不过，想想<code>Hexo</code>是基于<code>node</code>的，而且也是目录式的配置，应该只需要对比迁移在<strong>Windows</strong>上面的文档目录就行了，最关键的地方，基本应该都不用去改，直接拷贝<strong>Windows</strong>的配置就可以了，特别是主题，直接完整的把目录拷贝过来放到相应的<code>Theme</code>文件夹中，基本应该没啥问题。</p>
<h3 id="u521D_u59CB_u5316"><a href="#u521D_u59CB_u5316" class="headerlink" title="初始化"></a>初始化</h3><p>首先当然还是要安装和配置一些基本的东西，<code>git</code>和<code>node.js</code>我都早已经安装了，所以现在可以跳过，如果需要的话，可以直接到对应的官网上去下载安装包，或者直接用<code>Homebrew</code>安装更简单。现在我就直接开始安装<code>Hexo</code>了，很简单，终端中输入下面的命令就好：</p>
<pre><code class="bash">$&gt; npm install -g hexo
</code></pre>
<p>然后静静等待安装完成，期间我看到还调用了<code>clang</code>，所以也许还需要安装<code>XCode</code>开发环境。</p>
<p>当安装结束之后，就可以进入需要存放Blog文档的根目录了，进行初始化：</p>
<pre><code class="bash">$&gt; hexo init
</code></pre>
<p>然后还需要按照提示的，更新<code>Hexo</code>依赖：</p>
<pre><code class="bash">$&gt; npm install
</code></pre>
<h3 id="u8FD8_u539F_u914D_u7F6E"><a href="#u8FD8_u539F_u914D_u7F6E" class="headerlink" title="还原配置"></a>还原配置</h3><p>好了，现在可以开始对比这个默认的设置和目录结构与原来的有什么区别了。而对比之后，其实区别并不是很大，出了有些默认自带的插件以及<code>Hexo</code>本身版本号改变了一点，基本配置文件还是原来的几个，所以先直接覆盖了，主要是那个<code>_config.yml</code>文件，这里对比了一下，配置基本还是一样的，所以直接用上了原来的配置。</p>
<p>然后根目录下面有个<code>package.json</code>文件，这个主要就是记录插件和一些相应版本信息的，因此直接用<code>Visual Studio Code</code>打开这个默认生成的和原来<strong>Windows</strong>上面使用的文件进行对比，看看当初安装了哪些插件，就又重新安装了一遍。下面给出一些常用的插件安装命令：</p>
<pre><code class="bash">npm install hexo-generator-index --save
npm install hexo-generator-archive --save
npm install hexo-generator-category --save
npm install hexo-generator-tag --save
npm install hexo-server --save
npm install hexo-deployer-git --save
npm install hexo-deployer-heroku --save
npm install hexo-deployer-rsync --save
npm install hexo-deployer-openshift --save
npm install hexo-renderer-marked --save
npm install hexo-renderer-stylus --save
npm install hexo-generator-feed --save
npm install hexo-generator-sitemap --save
</code></pre>
<p>当然，有部分插件其实默认自带了的，只需要注意在全局配置文件中启用就行。我这里就是直接复原当初安装的，然后直接拷贝覆盖当初的配置就好了，里面已经启用插件并进行配置了。</p>
<p>然后再就是主题部分了，这个基本没遇到问题，直接把目录完全拷贝进来就好了，毕竟原先的配置中是已经修改启用主题了。至于对主题中曾经动工过的代码文件，就懒得去翻了。</p>
<h3 id="u8FD8_u539F_u6587_u6863"><a href="#u8FD8_u539F_u6587_u6863" class="headerlink" title="还原文档"></a>还原文档</h3><p>当然，上面的一切，都是为这一步服务，一切的中心当然还是为了能完全还原当初的文档效果，既然上面都准备好了，这里就只需要将整个<code>source</code>目录下面的文档包括文件夹都拷贝过来了。然后开始测试，启动预览：</p>
<pre><code class="bash">$&gt; hexo s -g
</code></pre>
<p>当然，这里是使用的简写语法，你也可以执行完整的命令，先编译文档：<code>hexo generate</code>，然后启动服务器：<code>hexo server</code>。接着就可以打开浏览器，输入地址进行访问了，默认是<code>http:://0.0.0.0:4000/</code>或者<code>http://localhost:4000/</code>。</p>
<p>这里预览一切正常，效果也和原来的一样，对比了一下生成的<code>public</code>目录，也没有问题，所有插件都运行正常，该有的文件都正常生成了，包括RSS和sitemap之类的xml文档。</p>
<h2 id="u6536_u5DE5"><a href="#u6536_u5DE5" class="headerlink" title="收工"></a>收工</h2><p>得益于<code>node</code>的跨平台性，所以这次迁移基本就没遇到什么困难，就是还原了一下配置而已，而主要也就是确保完整的还原，如果你担心出现兼容问题，可以在安装<code>hexo</code>和对应插件的时候，完整的限制版本号，等到最后确保没有问题的时候，在升级插件之类的即可。</p>
<p>接下来，也就该准备在<code>git</code>上建立一个仓库，用于同步所有的源文档了，也就是各种<code>Markdown</code>文件等，这样才方便在<strong>OS X</strong>和<strong>Windows</strong>之间完整的同步所有数据。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>几个月之前就想过，在 <strong>OS X</strong> 上配置一下<code>Hexo</code>，方便偶尔更新一下文章什么的，只是这么长时间了一拖再拖，总是在做着各种其它的事情，甚至Mac都很久没打开过了……</p>
<blockquote>
<p><strong>题外话：</strong>Mac的设计抛开不说，配合<strong>OS X</strong>用起来体验也不错，重点是续航，这都最少一个多月没开，现在开了，电量还有<em>60%</em>多，所有的App状态都还是之前合盖时候的状态。</p>
<p>顺便也得说一下，<strong>OS X</strong>上应用是少了一点，但是能用的基本都是布局很精美，也许部分是系统的一贯主题特色，而<strong>Retina</strong>屏幕的显示效果也是相当赞的。当然，用的也不多，除了系统那个<code>Finder</code>是个真尴尬的东西之外，基本其它的都感觉不错，比如现在正在用来编辑此文的<code>MacDown</code>，除了主题差了一点，各种显示效果是真的不错，文本编辑起来也是很舒服。</p>
</blockquote>
<p>扯远了，继续上文。最近准备弄弄<code>C++</code>，所以又打开了Mac，当然不是说<strong>Windows</strong>上面做不了开发，毕竟<code>Visual Studio</code>不是吹的，只是这次有点问题，一个依赖的项目在<strong>Windows</strong>上编译有问题，使用<code>MinGW</code>+<code>Clion</code>一直编译不通过，连接失败；然后我想着到<strong>OS X</strong>上试试，结果稍微改了一下<code>CMakeLists.txt</code>文件，就通过编译成功执行了。于是将项目搬到了Mac上面。</p>
<p>然后昨天又弄了一下，又将<code>Minecraft</code>给弄到<strong>OS X</strong>上面跑了，这下也基本可以单用<strong>OS X</strong>一阵子了，所以才有了标题所说的，想着准备把<code>Hexo</code>也弄过来了。这次也就没再往下拖延了。</p>]]>
    
    </summary>
    
      <category term="Hexo" scheme="http://3meng.github.io/tags/Hexo/"/>
    
      <category term="随笔" scheme="http://3meng.github.io/categories/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[深入探究 {x:Bind}]]></title>
    <link href="http://3meng.github.io/2015/12/08/Deep-research-with-x-Bind/"/>
    <id>http://3meng.github.io/2015/12/08/Deep-research-with-x-Bind/</id>
    <published>2015-12-08T09:16:17.000Z</published>
    <updated>2016-02-22T15:08:56.000Z</updated>
    <content type="html"><![CDATA[<p>今天无意间谈到了<code>UWP</code>应用中为数据绑定新引入的一个<code>XAML</code>标记：<code>{x:Bind}</code>，对于这个新的标记的作用和原理，网上的一般说法都是：</p>
<blockquote>
<p>相比较传统的<code>{Binding}</code>方式，<code>{x:Bind｝</code>的效率更高，因为<code>{x:Bind}</code>的数据绑定发生编译期间，绑定工作在编译时期就已经完成了，所以我们在使用<code>{x:Bind}</code>的时候，需要一个明确的数据类型（按：这也符合强类型语言的特点）。</p>
</blockquote>
<p>这些也都基本说的过去，相对于传统的<code>{Binding}</code>方式，这种类型严格的绑定行为，最起码也可以减少对象装箱和拆箱行为的性能损耗，而至于其它的由于强类型带来的可以优化的地方，就要看编译器的行为了。</p>
<p>但是基本上也就到此为止了，大部分关于<code>{x:Bind}</code>的说明文章，接下来就是将示例，陈述简单的用法，不说讲解一下<code>{x:Bind}</code>的实现方式，就连深入一点的用法，比如双向绑定等都没有提到多少。</p>
<blockquote>
<p>这里别说那些示例中写了个<code>Mode=TwoWay</code>就是双向绑定了，如果双向绑定这么简单，那在传统的<code>{Binding}</code>方式中又为什么要弄个<code>INotifyPropertyChanged</code>接口，还要弄个叫依赖属性的东西出来？</p>
</blockquote>
<a id="more"></a>
<h2 id="u7F18_u8D77"><a href="#u7F18_u8D77" class="headerlink" title="缘起"></a>缘起</h2><p>所以今天突然提起了这个新的绑定方式，一时间就突然发现认识的还是太少了，仅仅只是从网上看到了一点关于它的一点概述而已，一旦深入讨论下去，才发现很多东西都没有关注过，也许是我搜索的少了吧，没看到有谁深入的说明这个新加入的标记，即使是MSDN上也是说明了一下用法以及与<code>{Binding}</code>的对比而已。</p>
<p>多的也不多说了，既然找不到，那还不如自己去测试探索一翻。</p>
<p>先把网上总结的一些<code>{x:Bind}</code>特点罗列一下：</p>
<ul>
<li>强类型，因此某些时候你需要使用XAML中的方式强制类型转换。</li>
<li>上下文是<code>Page</code>或者<code>UserControl</code>。</li>
<li>默认的绑定模式是<strong>OneTime</strong>。</li>
<li>在数据模版中使用时，需要指定<code>{x:DataType}</code>。</li>
<li>支持绑定事件到方法。</li>
</ul>
<p>而关于<code>{x:Bind}</code>的更多详细说明，可以参考MSDN文档：<a href="https://msdn.microsoft.com/zh-cn/library/windows/apps/mt204783.aspx" title="{x:Bind} 标记扩展" target="_blank" rel="external">{x:Bind} 标记扩展</a>。关于<code>{x:Bind}</code>和<code>{Binding}</code>标记使用方法和功能的对比，也可以参考MSDN的说明：<a href="https://msdn.microsoft.com/zh-cn/library/windows/apps/mt210946.aspx#_x_bind_____binding______" title="{x:Bind} 和 {Binding} 功能比较" target="_blank" rel="external">{x:Bind} 和 {Binding} 功能比较</a>。</p>
<h2 id="u6D4B_u8BD5"><a href="#u6D4B_u8BD5" class="headerlink" title="测试"></a>测试</h2><p>新建一个UWP项目，然后开始测试了。因为只是看看<code>{x:Bind}</code>的工作方式，因此程序有些设计细节就不用过多关注了……</p>
<h3 id="OneTime_u7ED1_u5B9A"><a href="#OneTime_u7ED1_u5B9A" class="headerlink" title="OneTime绑定"></a>OneTime绑定</h3><p>这是<code>{x:Bind}</code>的默认绑定模式，也基本是比较常用的模式了，这种情况没什么好测试的了，正常的写法都能跑起来，而且也可以想像得到编译器会怎么处理：直接在页面构造的某个时期赋值一次罢了。这里需要注意的所有事项也就是<code>{x:Bind}</code>的基本用法注意事项了。</p>
<pre><code class="csharp">// ** .cs **
public string Title { get; set; } = &quot;Title&quot;;

// ** .xaml **
&lt;TextBlock Text=&quot;{x:Bind Title}&quot; /&gt;
</code></pre>
<h3 id="OneWay__26amp_3B_TwoWay_u7ED1_u5B9A"><a href="#OneWay__26amp_3B_TwoWay_u7ED1_u5B9A" class="headerlink" title="OneWay &amp; TwoWay绑定"></a>OneWay &amp; TwoWay绑定</h3><p>这两个之所以放到一起，是因为我没有测试过<strong>OneWay</strong>模式，而是直接观察<strong>TwoWay</strong>模式下的绑定情况的。</p>
<p>下面是测试用的XAML主要代码：</p>
<pre><code class="xml">&lt;Grid Background=&quot;{ThemeResource ApplicationPageBackgroundThemeBrush}&quot;&gt;
    &lt;TextBlock
        Text=&quot;{x:Bind Time, Mode=TwoWay}&quot;
        HorizontalAlignment=&quot;Right&quot;
        VerticalAlignment=&quot;Top&quot;
        Height=&quot;100&quot;/&gt;
    &lt;TextBox
        Text=&quot;{x:Bind Time, Mode=TwoWay}&quot;
        Margin=&quot;0,100,0,0&quot;
        VerticalAlignment=&quot;Top&quot;/&gt;
    &lt;Button
        VerticalAlignment=&quot;Bottom&quot;
        Content=&quot;Update Time&quot;
        Click=&quot;ButtonBase_OnClick&quot;/&gt;
&lt;/Grid&gt;
</code></pre>
<p>其中中间那个<code>TextBox</code>是测试过程中加入的，是因为<strong>TwoWay</strong>模式的<code>TextBlock</code>不好测试，没有文本框方便。</p>
<p>C#主要代码如下：</p>
<pre><code class="csharp">public sealed partial class MainPage : Page
{
    public string Time { get; set; }

    public MainPage()
    {
        this.InitializeComponent();
    }

    private void ButtonBase_OnClick(object sender, RoutedEventArgs e)
    {
        this.Time = DateTime.Now.ToString(&quot;D&quot;);
    }
}
</code></pre>
<p>这个相对于默认用法来说，其实也就是简单的给<code>{x:Bind}</code>加了一句说明：<code>Mode=TwoWay</code>，这也是网上大部分示例的做法。</p>
<p>在第一次测试中，忽略那个<code>TextBox</code>控件，我们使用按钮更改<code>Time</code>的值，看看界面的变化。而测试结果也在意料之中，不管你怎么点击那个按钮，界面都不会有任何的变化，<code>Time</code>的值根本不能传到控件属性上，这很好解释，这个<code>Time</code>就是一个很简单的自动属性而已，深入一点也就是两个普通的对象方法而已，根本没有地方把属性值传出去，甚至外界也根本不知道这个值已经变化了。</p>
<h3 id="TwoWay_u7ED1_u5B9A_u4E2D_u4ECE_u76EE_u6807_u5230_u6E90"><a href="#TwoWay_u7ED1_u5B9A_u4E2D_u4ECE_u76EE_u6807_u5230_u6E90" class="headerlink" title="TwoWay绑定中从目标到源"></a>TwoWay绑定中从目标到源</h3><p>继续上面那个测试，不同的是这次使用<code>TextBox</code>控件。</p>
<p>给<code>Time</code>属性的<em>set</em>访问器添加断点，然后开始在<code>TextBox</code>中输入一些内容，然后让文本框失去焦点，这时候可以看到断点命中了，当运行完毕之后，<code>Time</code>的值也被设置成为了文本框中输入的内容。当然这个时候<code>TextBlock</code>的内容仍然没有任何变化，原因和上面的一样，这时候的<code>Time</code>只是个普通属性。</p>
<p>但是无论如何，这里可以说明<code>{x:Bind}</code>是具有一般绑定的行为的，那么目前我们就剩下一个问题了，为什么从绑定源到绑定目标的路径不通？也就是绑定源的变化无法反馈给绑定目标？</p>
<h3 id="INotifyPropertyChanged"><a href="#INotifyPropertyChanged" class="headerlink" title="INotifyPropertyChanged"></a>INotifyPropertyChanged</h3><p>既然<code>{x:Bind}</code>和<code>{Binding}</code>如此类似，那么可不可以借鉴在<code>{Binding}</code>方式中使用的一些方式呢？比如<code>INotifyPropertyChanged</code>。上面提到无法报告绑定源的变化，而在传统的绑定中，出了使用依赖属性之外，我们还可以使用<code>INotifyPropertyChanged</code>接口，而在<code>{x:Bind}</code>方式中呢，是不是也可以试试这种方式，将属性的变化通知出去。</p>
<p>那么对C#代码稍微改变一下：</p>
<pre><code class="csharp">public sealed partial class MainPage : Page, INotifyPropertyChanged
{
    public event PropertyChangedEventHandler PropertyChanged;

    private string _time;

    public string Time
    {
        get { return _time; }
        set
        {
            if (value != _time)
            {
                _time = value;
                PropertyChanged?.Invoke(this, new PropertyChangedEventArgs(&quot;Time&quot;));
            }
        }
    }

    // ...
}
</code></pre>
<p>然后在运行测试一下，结果很出人意外。</p>
<p>无论是更改文本框的内容，还是点击按钮主动更新<code>Time</code>的值，都没有任何反应，也就是说，绑定仍然没有起作用，准确来说，是绑定仍然无法完成从绑定源到绑定目标的更新。</p>
<p>这也就是说，传统的方式无法适用于<code>{x:Bind}</code>了。因此需要看看编译器对这个标记扩展做了哪些工作了，而在VS的智能提示中，输入<code>this.</code>之后也可以看到一个新的<code>Page</code>类的字段：<code>Bindings</code>，也许和这种新的编译时绑定有关。</p>
<h2 id="u6DF1_u5165"><a href="#u6DF1_u5165" class="headerlink" title="深入"></a>深入</h2><p>既然要看看编译器究竟对XAML文档中的<code>{x:Bind}</code>做了什么，第一个想法当然是看看编译后生成的代码了，于是找到<strong>obj</strong>目录下临时文件，找到所有的以<em>MainPage</em>开头的文件，然后打开看看其中的内容。而很幸运，在这里找到了答案，具体来说，实在下面三个文件中：</p>
<ul>
<li>MainPage.g.i.cs</li>
<li>MainPage.g.cs</li>
<li>MainPage.xaml</li>
</ul>
<h3 id="MainPage-g-i-cs"><a href="#MainPage-g-i-cs" class="headerlink" title="MainPage.g.i.cs"></a>MainPage.g.i.cs</h3><p>下面是这个文件中的主要内容：</p>
<pre><code class="csharp">partial class MainPage : global::Windows.UI.Xaml.Controls.Page
{
    [global::System.CodeDom.Compiler.GeneratedCodeAttribute(&quot;Microsoft.Windows.UI.Xaml.Build.Tasks&quot;,&quot; 14.0.0.0&quot;)]
    private bool _contentLoaded;

    /// &lt;summary&gt;
    /// InitializeComponent()
    /// &lt;/summary&gt;
    [global::System.CodeDom.Compiler.GeneratedCodeAttribute(&quot;Microsoft.Windows.UI.Xaml.Build.Tasks&quot;,&quot; 14.0.0.0&quot;)]
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
    public void InitializeComponent()
    {
        // ...
    }


    private interface IMainPage_Bindings
    {
        void Initialize();
        void Update();
        void StopTracking();
    }
#pragma warning disable 0169
    private IMainPage_Bindings Bindings;
#pragma warning restore 0169
}
</code></pre>
<p>可以看到这里声明了一个私有接口和对应的字段。在这个接口中定义了三个操作方法，而在看完后面两个文件内容之后，就可以知道每个方法的作用了。而这个接口，也是整个绑定环节中的一个重要部分。</p>
<h3 id="MainPage-g-cs"><a href="#MainPage-g-cs" class="headerlink" title="MainPage.g.cs"></a>MainPage.g.cs</h3><p>这个文件内容有点多，也是绑定实现的主要部分。</p>
<pre><code class="csharp">partial class MainPage : 
    global::Windows.UI.Xaml.Controls.Page, 
    global::Windows.UI.Xaml.Markup.IComponentConnector,
    global::Windows.UI.Xaml.Markup.IComponentConnector2
{
    internal class XamlBindingSetters
    {
        public static void Set_Windows_UI_Xaml_Controls_TextBlock_Text(global::Windows.UI.Xaml.Controls.TextBlock obj, global::System.String value, string targetNullValue)
        {
            if (value == null &amp;&amp; targetNullValue != null)
            {
                value = targetNullValue;
            }
            obj.Text = value ?? global::System.String.Empty;
        }
        public static void Set_Windows_UI_Xaml_Controls_TextBox_Text(global::Windows.UI.Xaml.Controls.TextBox obj, global::System.String value, string targetNullValue)
        {
            if (value == null &amp;&amp; targetNullValue != null)
            {
                value = targetNullValue;
            }
            obj.Text = value ?? global::System.String.Empty;
        }
    };

    private class MainPage_obj1_Bindings :
        global::Windows.UI.Xaml.Markup.IComponentConnector,
        IMainPage_Bindings
    {
        private global::TestApp1.MainPage dataRoot;
        private bool initialized = false;
        private const int NOT_PHASED = (1 &lt;&lt; 31);
        private const int DATA_CHANGED = (1 &lt;&lt; 30);

        // Fields for each control that has bindings.
        private global::Windows.UI.Xaml.Controls.TextBlock obj2;
        private global::Windows.UI.Xaml.Controls.TextBox obj3;

        private MainPage_obj1_BindingsTracking bindingsTracking;

        public MainPage_obj1_Bindings()
        {
            this.bindingsTracking = new MainPage_obj1_BindingsTracking(this);
        }

        // IComponentConnector

        public void Connect(int connectionId, global::System.Object target)
        {
            switch(connectionId)
            {
                case 2:
                    this.obj2 = (global::Windows.UI.Xaml.Controls.TextBlock)target;
                    (this.obj2).RegisterPropertyChangedCallback(global::Windows.UI.Xaml.Controls.TextBlock.TextProperty,
                        (global::Windows.UI.Xaml.DependencyObject sender, global::Windows.UI.Xaml.DependencyProperty prop) =&gt;
                        {
                            if (this.initialized)
                            {
                                // Update Two Way binding
                                this.dataRoot.Time = (this.obj2).Text;
                            }
                        });
                    break;
                case 3:
                    this.obj3 = (global::Windows.UI.Xaml.Controls.TextBox)target;
                    (this.obj3).LostFocus += (global::System.Object sender, global::Windows.UI.Xaml.RoutedEventArgs e) =&gt;
                        {
                            if (this.initialized)
                            {
                                // Update Two Way binding
                                this.dataRoot.Time = (this.obj3).Text;
                            }
                        };
                    break;
                default:
                    break;
            }
        }

        // IMainPage_Bindings

        public void Initialize()
        {
            if (!this.initialized)
            {
                this.Update();
            }
        }

        public void Update()
        {
            this.Update_(this.dataRoot, NOT_PHASED);
            this.initialized = true;
        }

        public void StopTracking()
        {
            this.bindingsTracking.ReleaseAllListeners();
            this.initialized = false;
        }

        // MainPage_obj1_Bindings

        public void SetDataRoot(global::TestApp1.MainPage newDataRoot)
        {
            this.bindingsTracking.ReleaseAllListeners();
            this.dataRoot = newDataRoot;
        }

        public void Loading(global::Windows.UI.Xaml.FrameworkElement src, object data)
        {
            this.Initialize();
        }

        // Update methods for each path node used in binding steps.
        private void Update_(global::TestApp1.MainPage obj, int phase)
        {
            if (obj != null)
            {
                if ((phase &amp; (NOT_PHASED | DATA_CHANGED | (1 &lt;&lt; 0))) != 0)
                {
                    this.Update_Time(obj.Time, phase);
                }
            }
        }
        private void Update_Time(global::System.String obj, int phase)
        {
            if((phase &amp; ((1 &lt;&lt; 0) | NOT_PHASED | DATA_CHANGED)) != 0)
            {
                XamlBindingSetters.Set_Windows_UI_Xaml_Controls_TextBlock_Text(this.obj2, obj, null);
                XamlBindingSetters.Set_Windows_UI_Xaml_Controls_TextBox_Text(this.obj3, obj, null);
            }
        }

        private class MainPage_obj1_BindingsTracking
        {
            global::System.WeakReference&lt;MainPage_obj1_Bindings&gt; WeakRefToBindingObj; 

            public MainPage_obj1_BindingsTracking(MainPage_obj1_Bindings obj)
            {
                WeakRefToBindingObj = new global::System.WeakReference&lt;MainPage_obj1_Bindings&gt;(obj);
            }

            public void ReleaseAllListeners()
            {
            }

        }
    }
    /// &lt;summary&gt;
    /// Connect()
    /// &lt;/summary&gt;
    [global::System.CodeDom.Compiler.GeneratedCodeAttribute(&quot;Microsoft.Windows.UI.Xaml.Build.Tasks&quot;,&quot; 14.0.0.0&quot;)]
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
    public void Connect(int connectionId, object target)
    {
        switch(connectionId)
        {
        case 4:
            {
                global::Windows.UI.Xaml.Controls.Button element4 = (global::Windows.UI.Xaml.Controls.Button)(target);
                #line 23 &quot;..\..\..\MainPage.xaml&quot;
                ((global::Windows.UI.Xaml.Controls.Button)element4).Click += this.ButtonBase_OnClick;
                #line default
            }
            break;
        default:
            break;
        }
        this._contentLoaded = true;
    }

    [global::System.CodeDom.Compiler.GeneratedCodeAttribute(&quot;Microsoft.Windows.UI.Xaml.Build.Tasks&quot;,&quot; 14.0.0.0&quot;)]
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
    public global::Windows.UI.Xaml.Markup.IComponentConnector GetBindingConnector(int connectionId, object target)
    {
        global::Windows.UI.Xaml.Markup.IComponentConnector returnValue = null;
        switch(connectionId)
        {
        case 1:
            {
                global::Windows.UI.Xaml.Controls.Page element1 = (global::Windows.UI.Xaml.Controls.Page)target;
                MainPage_obj1_Bindings bindings = new MainPage_obj1_Bindings();
                returnValue = bindings;
                bindings.SetDataRoot(this);
                this.Bindings = bindings;
                element1.Loading += bindings.Loading;
            }
            break;
        }
        return returnValue;
    }
}
</code></pre>
<p>不过具体内容也很好理解，抛开几个属于<code>MainPage</code>类的方法先不管，在这里定义了几个内部类：<code>XamlBindingSetters</code>、<code>MainPage_obj1_Bindings</code>，其中<code>MainPage_obj1_Bindings</code>类实现了前面定义的那个接口，同时还定义了一个内部类<code>MainPage_obj1_BindingsTracking</code>作为所谓跟踪的一个实现，具体在这里我们不管它的作用。</p>
<p>首先看第一个类<code>XamlBindingSetters</code>，这个类中定义的方法很明显是给控件属性赋值使用的，而且是专门真对声明了<code>{x:Bind}</code>标记的控件和属性。</p>
<p>然后是主要的类<code>MainPage_obj1_Bindings</code>了，这个实现了所谓绑定接口的类中，我们重点关注接口声明的三个方法。而对于另外有个相对比较长的方法<code>Connect</code>，可以看出来就是实现从绑定目标到绑定源的更新了，这里就不分析了，很简单的代码。</p>
<p>对于接口中三个方法的实现中，可以抛去<code>StopTracking()</code>方法不管，这个方法和上面所说的<code>MainPage_obj1_BindingsTracking</code>类有关，也许是我的例子过于简单，在这个类中看不出来有什么特殊的工作要做，除了保持了一个弱引用。</p>
<p>而剩下的两个方法，最后的调用都指向了一个名叫<code>Update_</code>的私有方法，在这个方法里面有调用了一个针对具体属性的<code>Update_Time</code>方法，而从这里，我们就可以看到对<code>XamlBindingSetters</code>类的调用了，而这个类是为了设置控件的绑定属性的值的。那么很显然，<strong>在</strong><code>{x:Bind}</code><strong>方式的绑定中，从绑定源到绑定目标的更新是由上述内部接口中定义的</strong><code>Update</code><strong>方法来完成的</strong>。</p>
<p>具体为什么跳跃这么远，又扯到了上一个文件中定义的接口，我们可以上面最后一个方法的内容：</p>
<pre><code class="csharp">MainPage_obj1_Bindings bindings = new MainPage_obj1_Bindings();
this.Bindings = bindings;
</code></pre>
<p>因此，具体来说，是<strong>使用私有字段</strong><code>Bindings</code><strong>来完成更新的</strong>。</p>
<p>到这里已经基本结束了，也许关于那些<code>switch</code>分支中的数字感到有些莫名其妙，那么可以再看看最后一个文件。</p>
<h3 id="MainPage-xaml"><a href="#MainPage-xaml" class="headerlink" title="MainPage.xaml"></a>MainPage.xaml</h3><p>内容很少，可以很容易看出那些奇怪的数字来源：</p>
<pre><code class="xml">&lt;Page x:ConnectionId=&#39;1&#39;
    x:Class=&quot;TestApp1.MainPage&quot;
    xmlns=&quot;http://schemas.microsoft.com/winfx/2006/xaml/presentation&quot;
    xmlns:x=&quot;http://schemas.microsoft.com/winfx/2006/xaml&quot;
    xmlns:local=&quot;using:TestApp1&quot;
    xmlns:d=&quot;http://schemas.microsoft.com/expression/blend/2008&quot;
    xmlns:mc=&quot;http://schemas.openxmlformats.org/markup-compatibility/2006&quot;
    mc:Ignorable=&quot;d&quot;&gt;

    &lt;Grid Background=&quot;{ThemeResource ApplicationPageBackgroundThemeBrush}&quot;&gt;
        &lt;TextBlock x:ConnectionId=&#39;2&#39;

            HorizontalAlignment=&quot;Right&quot;
            VerticalAlignment=&quot;Top&quot;
            Height=&quot;100&quot;/&gt;
        &lt;TextBox x:ConnectionId=&#39;3&#39;

            Margin=&quot;0,100,0,0&quot;
            VerticalAlignment=&quot;Top&quot;/&gt;
        &lt;Button x:ConnectionId=&#39;4&#39;
            VerticalAlignment=&quot;Bottom&quot;
            Content=&quot;Update Time&quot;
                                      /&gt;
    &lt;/Grid&gt;
&lt;/Page&gt;
</code></pre>
<p>所谓留空的地方也不是我故意弄得，使本来就如此，对比一下，可以发现留空的位置就是我们使用了绑定或者声明事件的位置。</p>
<h3 id="u989D_u5916_u7684"><a href="#u989D_u5916_u7684" class="headerlink" title="额外的"></a>额外的</h3><p>其实关于上面三个文件，特别是第二个里面，有些地方我们不用深究，最起码对于这个简单的例子不用，比如那些奇怪的数字和常量定义，还有那条件判断等。除非你打算在深入研究这个框架，不过那时候也不应该看这些代码了。</p>
<p>而对于上面这些具体代码，具体的方法，我们也不用过分深究究竟是什么时候被调用的，我们只需要知道当你在XAML中使用了<code>{x:Bind}</code>的时候，<code>Bindings</code>字段就处于可用的情况了，至于那些<code>Initialize</code>、<code>Initialize</code>、<code>GetBindingConnector</code>方法是什么时候调用的，可以不用管了。而如果不放心，你可以像我下面调用的那样使用。</p>
<h2 id="u6700_u540E"><a href="#u6700_u540E" class="headerlink" title="最后"></a>最后</h2><p>最后就留下测试之后的正确工作的代码吧，改动也不大，就是换了一个通知方式而已。</p>
<pre><code class="csharp">public sealed partial class MainPage : Page
{
    private string _time;

    public string Time
    {
        get { return _time; }
        set
        {
            if (value != _time)
            {
                _time = value;
                this.Bindings?.Update();
            }
        }
    }

    public MainPage()
    {
        this.InitializeComponent();
    }

    private void ButtonBase_OnClick(object sender, RoutedEventArgs e)
    {
        this.Time = DateTime.Now.ToString(&quot;D&quot;);
    }
}
</code></pre>
<p>重点就是属性的<em>set</em>访问器中的对<code>Bindings.Update()</code>方法的调用了。</p>
<h2 id="u7ED3_u8BED"><a href="#u7ED3_u8BED" class="headerlink" title="结语"></a>结语</h2><p>关于<code>{x:Bind}</code>目前就告一段落吧，其实还有很多细节可以去深究，比如针对依赖属性的行为。如果你多去试试，未尝不能和<code>{Binding}</code>一样玩出各种花样来。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>今天无意间谈到了<code>UWP</code>应用中为数据绑定新引入的一个<code>XAML</code>标记：<code>{x:Bind}</code>，对于这个新的标记的作用和原理，网上的一般说法都是：</p>
<blockquote>
<p>相比较传统的<code>{Binding}</code>方式，<code>{x:Bind｝</code>的效率更高，因为<code>{x:Bind}</code>的数据绑定发生编译期间，绑定工作在编译时期就已经完成了，所以我们在使用<code>{x:Bind}</code>的时候，需要一个明确的数据类型（按：这也符合强类型语言的特点）。</p>
</blockquote>
<p>这些也都基本说的过去，相对于传统的<code>{Binding}</code>方式，这种类型严格的绑定行为，最起码也可以减少对象装箱和拆箱行为的性能损耗，而至于其它的由于强类型带来的可以优化的地方，就要看编译器的行为了。</p>
<p>但是基本上也就到此为止了，大部分关于<code>{x:Bind}</code>的说明文章，接下来就是将示例，陈述简单的用法，不说讲解一下<code>{x:Bind}</code>的实现方式，就连深入一点的用法，比如双向绑定等都没有提到多少。</p>
<blockquote>
<p>这里别说那些示例中写了个<code>Mode=TwoWay</code>就是双向绑定了，如果双向绑定这么简单，那在传统的<code>{Binding}</code>方式中又为什么要弄个<code>INotifyPropertyChanged</code>接口，还要弄个叫依赖属性的东西出来？</p>
</blockquote>]]>
    
    </summary>
    
      <category term="Binding" scheme="http://3meng.github.io/tags/Binding/"/>
    
      <category term="XAML" scheme="http://3meng.github.io/tags/XAML/"/>
    
      <category term="UWP" scheme="http://3meng.github.io/categories/UWP/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[开发问题记录]]></title>
    <link href="http://3meng.github.io/2015/11/14/dev-issue/"/>
    <id>http://3meng.github.io/2015/11/14/dev-issue/</id>
    <published>2015-11-14T14:35:25.000Z</published>
    <updated>2015-12-08T12:25:22.000Z</updated>
    <content type="html"><![CDATA[<p>记录一些开发过程中遇到的问题，或者疑惑的地方，在记录的时候，还没有解决或者找到原因，也许会在以后的时间里去验证和解决。如果知道了原因所在，也会及时更新并记录下来。</p>
<p>就当是一个历史的记忆，也避免日后在重复同样的问题。</p>
<blockquote>
<p>最近更新时间：<code>2015年11月14日</code></p>
</blockquote>
<a id="more"></a>
<ul>
<li>2015年11月14日：UWP中Storyboard问题</li>
</ul>
<h2 id="UWP"><a href="#UWP" class="headerlink" title="UWP"></a>UWP</h2><p>在开发UWP应用过程中遇到的一些问题（疑惑）。</p>
<h3 id="Storyboard_u4E2D_u7684_u52A8_u753B_u7EBF_u4E0D_u8FD0_u884C_uFF08_u65E0_u6548_uFF09"><a href="#Storyboard_u4E2D_u7684_u52A8_u753B_u7EBF_u4E0D_u8FD0_u884C_uFF08_u65E0_u6548_uFF09" class="headerlink" title="Storyboard中的动画线不运行（无效）"></a>Storyboard中的动画线不运行（无效）</h3><p>开发UWP应用，肯定少不了做响应式设计，毕竟在这里微软就直接没把调整窗口大小的权利交给开发者，所以为了保证在任何（绝大多数）情况下应用都能有正确的呈现，应用一般都需要针对不同大小的窗口做出不同的优化和响应。</p>
<p>我在应用中使用了一个<code>RelativePanel</code>作为布局容器，然后使用<code>AdaptiveTrigger</code>来响应不同的分辨率，最开始是只使用了<code>VisualState.Setters</code>属性，做了一下简单的显示和隐藏。但是在测试过程中，总是感觉这样直接的隐藏内容有些突兀，视觉上的感受很不顺眼，因此决定加一点动画，原本以为很简单的一件事，毕竟<code>VisualState</code>中就提供了<code>Storyboard</code>属性，可以直接添加一些针对UI元素的动画效果，因此直接使用了<code>DoubleAnimation</code>来操作控件的<code>Width</code>属性，结果运行之后却发现没有效果，控件宽度根本没有发生变化。</p>
<p>于是查看了一下新的<code>DoubleAnimation</code>对象的属性列表，发现有个<code>EnableDependentAnimation</code>属性，用于控制被认为是<a href="https://msdn.microsoft.com/zh-cn/library/windows/apps/xaml/jj819807.aspx#dependent" target="_blank" rel="external">从属动画</a>的动画是否可以运行，而根据定义，我上面定义的动画应该属于<em>从属动画</em> 的，因此我显式的将这个属性设置为<code>True</code>，但是结果却很意外，该动画仍然没有起作用。</p>
<blockquote>
<p>微软为了优化应用性能也是用尽了方法，现在连动画系统都改变这么多，不再是以前那样所有动画都一视同仁，只要声明动画目标和属性路径就行了。</p>
</blockquote>
<p>最后无奈之下，只好换成<code>RenderTransform</code>来实现效果，也就是独立动画，但是有些效果却没有按照计划样式来实现，因为毕竟使用<code>RenderTransform</code>并不会触发布局时间，也就不会引起布局的更新，而有所改变的也只有一个受<code>RenderTransform</code>控制的元素罢了。</p>
<p>下面是应用运行环境：</p>
<ul>
<li><strong>系统</strong>：Windows 10 专业版，版本 1511（OS内部版本 10586.3），会员快速通道</li>
<li><strong>Runtime</strong>：.Net Framework 4.6</li>
<li><strong>Visual Studio</strong>：版本 14.0.23107.0 D14REL</li>
<li><strong>Microsoft .NET Framework</strong>：版本 4.6.01038</li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<p>记录一些开发过程中遇到的问题，或者疑惑的地方，在记录的时候，还没有解决或者找到原因，也许会在以后的时间里去验证和解决。如果知道了原因所在，也会及时更新并记录下来。</p>
<p>就当是一个历史的记忆，也避免日后在重复同样的问题。</p>
<blockquote>
<p>最近更新时间：<code>2015年11月14日</code></p>
</blockquote>]]>
    
    </summary>
    
      <category term="Storyboard" scheme="http://3meng.github.io/tags/Storyboard/"/>
    
      <category term="笔记" scheme="http://3meng.github.io/categories/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[开发笔记]]></title>
    <link href="http://3meng.github.io/2015/07/31/development-notes/"/>
    <id>http://3meng.github.io/2015/07/31/development-notes/</id>
    <published>2015-07-31T13:30:47.000Z</published>
    <updated>2016-02-22T15:05:39.000Z</updated>
    <content type="html"><![CDATA[<p>在开发过程中的一些笔记心得，包括一些技巧方法和记录。不定期整理更新。</p>
<blockquote>
<p>最近更新时间：<code>2015年11月16日</code></p>
</blockquote>
<a id="more"></a>
<ul>
<li>2015年7月31日，初始化。</li>
<li>2015年11月12日，<code>VisualStateManager</code>使用细节。</li>
<li>2015年11月16日，<code>UIElement.Transitions</code>使用注意。</li>
</ul>
<h2 id="u521D_u59CB_u5316"><a href="#u521D_u59CB_u5316" class="headerlink" title="初始化"></a>初始化</h2><p>文章原文件建立很早了，但是期间由于各种各样的问题（包括自身和外界的），一直到今天（2015年11月12日）才继续，不仅仅是继续这篇文章，也是继续博客。期间因为更换了电脑硬盘，重装了一次系统，所以很多程序都没有安装，这也是一直拖到今天的原因之一，其它的，不一一细表。</p>
<h2 id="VisualStateManager_u7528_u6CD5_u7EC6_u8282"><a href="#VisualStateManager_u7528_u6CD5_u7EC6_u8282" class="headerlink" title="VisualStateManager用法细节"></a>VisualStateManager用法细节</h2><blockquote>
<p>2015年11月12日</p>
</blockquote>
<p>今天开始尝试<code>Universal Windows Platform (UWP)</code>应用程序开发，首先当然是找到Windows 10中针对响应式程序设计所新增的内容，从网上搜索，发现一片都是提<code>RelativePanel</code>控件和<code>AdaptiveTrigger</code>的，于是就从这两个开始入门了。</p>
<p>但是在测试过程中，发现设定的<code>AdaptiveTrigger</code>并没有起作用，到MSDN中搜索发现了下面的一句话：</p>
<blockquote>
<p>When you use <code>StateTriggers</code>, <strong>ensure</strong> that the <code>VisualStateGroup</code> is declared under the first child of the root in order for the triggers to take effect automatically.</p>
</blockquote>
<p>看来问题出在这里了，使用了<code>StateTriggers</code>属性之后，必须确保<code>VisualStateGroup</code>是在根节点的第一个子节点下声明的，而在这里，根节点为<code>Page</code>元素，默认是有一个<code>Grid</code>类型的布局子元素，也就是我们需要在这个<code>Grid</code>元素下面声明我们的状态组对象，而这里我直接写到了根节点（<code>Page</code>）下了，所以会没有被触发。</p>
<p>当修改之后，可以很直观的在VS的XAML设计器中看到状态的变化，这一点很赞，不用再去编译运行来查看效果了。</p>
<p>而这里的提示，也可以作为一条“潜规则”了，回想一下，以前自定义控件样式/模版的时候，也都是把控件的视觉状态组声明到元素<code>ControlTemplate</code>的子节点下，虽然那时候并没有使用<code>StateTriggers</code>，（因为没有），但是这个习惯却可以保持下去，免得出现不必要的bug。</p>
<blockquote>
<p>顺便提一句，有关UWP的内容，最好尽量选择查看英文MSDN页面，因为目前好像中文版还没有更新，仍然是老旧的内容说明。比如，你可以对比一下上面的<code>Visual State</code>类的两种语言说明：<a href="https://msdn.microsoft.com/zh-cn/library/windows/apps/windows.ui.xaml.visualstate.aspx" title="Visual State类中文页面" target="_blank" rel="external">Visual State 类</a> &amp; <a href="https://msdn.microsoft.com/en-us/library/windows/apps/windows.ui.xaml.visualstate.aspx" title="Visual State class" target="_blank" rel="external">Visual State class</a>，可以很明显的发现中文页面内容仍然是以前的WinRT说明。</p>
</blockquote>
<h2 id="UIElement-Transitions"><a href="#UIElement-Transitions" class="headerlink" title="UIElement.Transitions"></a>UIElement.Transitions</h2><p><code>Transitions</code>是<code>UIElement</code>类型的一个属性，所以所有的UWP控件都有这个属性，它控制了控件在展示时候的一些变换。但是在使用XAML样式为这个属性赋值的时候，却有些细节需要注意。</p>
<p><code>Transitions</code>属性是一个集合类型，而通常在XAML中，对于集合类型，我们可以采用集合类型的隐式赋值方式，也就是省略集合类型的声明，而直接写集合中的元素。但是对于<code>Transitions</code>属性来说，我们却必须显式的声明一个<code>TransitionCollection</code>对象作为其子元素，如果直接利用隐式集合语法赋值的话，将会在运行时产生一个<code>System.AccessViolationException</code>异常：</p>
<blockquote>
<p><code>System.AccessViolationException</code>类型的未经处理的异常在 <strong>YourApp.exe</strong> 中发生</p>
<p>其他信息：Attempted to read or write protected memory. This is often an indication that other memory is corrupt.</p>
</blockquote>
<p>上面的异常将会在页面对象构造时候发送，从异常抛出位置可以看出是在<code>this.InitializeComponent()</code>方法中，但是这个异常并没有更多的详细信息，因此只能推测是XAML分析构造过程中出现了异常，而经过验证最近的改动，最终确定就是由于在给<code>Transitions</code>赋值时采用了隐式集合写法导致的：</p>
<pre><code class="xml">&lt;UIElement&gt;  
    &lt;UIElement.Transitions&gt;
        oneOrMoreTransitions
    &lt;/UIElement.Transitions&gt;
&lt;/UIElement&gt;
</code></pre>
<p>而将声明改成如下形式，程序就可以正常运行了：</p>
<pre><code class="xml">&lt;UIElement&gt;
    &lt;UIElement.Transitions&gt;
        &lt;TransitionCollection&gt;
            oneOrMoreTransitions
        &lt;/TransitionCollection&gt;
    &lt;/UIElement.Transitions&gt;
&lt;/UIElement&gt;
</code></pre>
<p>而其实仔细想来，对于<code>Transitions</code>属性来说，确实是必须采用下面的显式赋值方式，因为所谓的隐式集合语法，其实只是XAML分析器帮我们做了一些事情，分析器会自动调用集合属性的<code>Add</code>方法（大部分情况下都是）来添加我们在集合中声明的元素。而这里就需要注意，分析器是不会主动去为集合属性赋值的，而通常也是不需要的，因为一般集合属性是只读的，也就是说当我们使用这个集合属性的时候，属性所有者会确保这个集合属性已经初始化了。而我们再去查看<code>Transitions</code>的声明：</p>
<pre><code class="csharp">public TransitionCollection Transitions { get; set; }
</code></pre>
<p>验证可以知道默认情况下这个属性值为<code>null</code>，因此如果我们采用隐式集合语法，将会引发<code>NullReferenceException</code>类型的异常，因此我们需要显示的声明一个<code>TransitionCollection</code>对象，将其赋值给<code>Transitions</code>属性。而为什么实际抛出的异常不是空引用异常呢？从抛出的异常描述来看，异常是一直等到向属性写入内容的时候产生的，也就类似与在C/C++中对一个空指针进行操作，这个时候的异常就是由操作系统产生的了，因为指针所指的内存区域是不可以被应用程序操作的；因此我们可以猜测微软对XAML分析器有一个非常底层的实现（为了效率），因此除了少数操作，大部分XAML异常将会更类似于C/C++中的异常提示。</p>
<p>最后，其实在MSDN上的<a href="https://msdn.microsoft.com/zh-cn/library/windows/apps/windows.ui.xaml.uielement.transitions.aspx" target="_blank" rel="external">UIElement.Transitions Property</a>页面也有对此的备注提示：</p>
<blockquote>
<p><strong>重要事项</strong> 使用<code>TransitionCollection</code>值的所有属性的 XAML 语法出现异常，所以你必须将一个显式<code>TransitionCollection</code>对象元素声明为值，然后为要使用的每个过渡动画提供对象元素作为<code>TransitionCollection</code>的子元素。对于大多数其他 XAML 集合属性，你可以省略集合对象元素，因为它可以是隐式的，但是使用<code>TransitionCollection</code>的属性不支持隐式集合用法。</p>
</blockquote>
]]></content>
    <summary type="html">
    <![CDATA[<p>在开发过程中的一些笔记心得，包括一些技巧方法和记录。不定期整理更新。</p>
<blockquote>
<p>最近更新时间：<code>2015年11月16日</code></p>
</blockquote>]]>
    
    </summary>
    
      <category term="Transitions" scheme="http://3meng.github.io/tags/Transitions/"/>
    
      <category term="VisualStateManager" scheme="http://3meng.github.io/tags/VisualStateManager/"/>
    
      <category term="笔记" scheme="http://3meng.github.io/categories/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[C# 6 新特性]]></title>
    <link href="http://3meng.github.io/2015/07/21/New-Language-Features-in-CSharp6/"/>
    <id>http://3meng.github.io/2015/07/21/New-Language-Features-in-CSharp6/</id>
    <published>2015-07-21T06:52:31.000Z</published>
    <updated>2016-02-22T14:42:09.000Z</updated>
    <content type="html"><![CDATA[<p>微软新一代开发工具<code>Visual Studio 2015</code>正式版已经于北京时间 2015年7月20日 23:30 发布了，而作为<code>.Net</code>开发中的主力开发语言<code>C#</code>，也已经走到了<code>C# 6</code>。</p>
<p>那么作为<code>C#</code>开发语言的最新版本，微软又给它添加或改进了哪些特性呢？</p>
<p><code>C# 6</code>的新特性是和微软的 .Net 开源编译器<a href="https://github.com/dotnet/roslyn" target="_blank" rel="external">Roslyn</a>紧密相连的，在其 GitHub 页面中，也给出了<code>C# 6</code>新特性：<a href="https://github.com/dotnet/roslyn/wiki/New-Language-Features-in-C%23-6" target="_blank" rel="external">New Language Features in C# 6</a>。下面内容一部分为简单的翻译，以及在查看时的一些理解和疑问，由于目前我还没发下载最新版 Win10 和 VS 2015，因此有些地方暂时还没发验证猜想。等待后续更新。</p>
<p>下面先列出<code>C# 6</code>中的新特性：</p>
<ul>
<li><p>自动属性初始值表达式</p>
<blockquote>
<p><code>public int X { get; set; } = x;</code></p>
</blockquote>
</li>
<li><p>只读自动属性</p>
<blockquote>
<p><code>public int Y { get; } = y;</code></p>
</blockquote>
</li>
<li><p>静态导入<code>using static</code></p>
<blockquote>
<pre><code class="csharp">using static System.Console;
// ...
Write(4);
</code></pre>
</blockquote>
</li>
<li><p>索引器对象初始化</p>
<blockquote>
<p><code>new JObject { [&quot;x&quot;] = 3 }</code></p>
</blockquote>
</li>
<li><p>在<code>catch</code>和<code>finally</code>块中使用<code>await</code></p>
<blockquote>
<p><code>try { ... } catch { await ... } finally { await ... }</code></p>
</blockquote>
</li>
<li><p>异常筛选器</p>
<blockquote>
<p><code>catch(Exception e) when (e.Count &gt; 5) { ... }</code></p>
</blockquote>
</li>
<li><p>函数/属性表达式</p>
<blockquote>
<p><code>public double Dist =&gt; Sqrt(X * X + Y * Y);</code></p>
</blockquote>
</li>
<li><p>Null条件运算符</p>
<blockquote>
<p><code>customer?.Orders?[5]</code></p>
</blockquote>
</li>
<li><p>字符串插值</p>
<blockquote>
<p><code>$&quot;{p.Name} is {p.Age} years old.&quot;</code></p>
</blockquote>
</li>
<li><p><code>nameof</code>运算符</p>
<blockquote>
<p><code>string s = nameof(Console.Write);</code></p>
</blockquote>
</li>
<li><p>其它改进</p>
<blockquote>
<ul>
<li>#pragma</li>
<li>集合初始化支持扩展方法<code>Add</code></li>
<li>重载方法解析改进</li>
</ul>
</blockquote>
</li>
</ul>
<a id="more"></a>
<h2 id="u81EA_u52A8_u5C5E_u6027_u589E_u5F3A"><a href="#u81EA_u52A8_u5C5E_u6027_u589E_u5F3A" class="headerlink" title="自动属性增强"></a>自动属性增强</h2><h3 id="u81EA_u52A8_u5C5E_u6027_u521D_u59CB_u503C_u8868_u8FBE_u5F0F"><a href="#u81EA_u52A8_u5C5E_u6027_u521D_u59CB_u503C_u8868_u8FBE_u5F0F" class="headerlink" title="自动属性初始值表达式"></a>自动属性初始值表达式</h3><p>现在可以为自动属性添加一个初始值表达式了，如下：</p>
<pre><code class="CSharp">public class Customer
{
    public string First { get; set; } = &quot;Jane&quot;;
    public string Last { get; set; } = &quot;Doe&quot;;
}
</code></pre>
<p>我们知道所谓自动属性，其实是属性的一种快速写法，编译器为我们做了额外的工作，包括为自动属性生成对应的字段以及添加读写方法。这里的自动熟悉初始值，会被直接赋值给属性对应的字段，而不经过自动属性的<code>setter</code>索引器，就如同直接给字段赋初始值一样。因此，如果我们在应用中使用了某些<code>AOP</code>框架，并且为属性添加了<code>NotifyPropertyChanged</code>或类似特性，当属性被初始化的时候，我们并不能得到通知。</p>
<blockquote>
<p>和字段的初始化一样，自动属性初始化表达式中不能引用<code>this</code>，因为在类被初始化之前它们就已经被执行了。</p>
</blockquote>
<h3 id="u53EA_u8BFB_u81EA_u52A8_u5C5E_u6027"><a href="#u53EA_u8BFB_u81EA_u52A8_u5C5E_u6027" class="headerlink" title="只读自动属性"></a>只读自动属性</h3><p>现在我们可以声明一个只读自动熟悉了，同时使用上面的自动熟悉初始化表达式设置初始值。</p>
<pre><code class="csharp">public class Customer
{
    public string First { get; } = &quot;Jane&quot;;
    public string Last { get; } = &quot;Doe&quot;;
}
</code></pre>
<p>只读自动属性对应的字段被隐式的声明为<code>readonly</code>。因此，一个只读属性还可以在其声明类型的构造函数中赋值，实质上也还是直接对属性所对应的字段赋值。</p>
<pre><code class="csharp">public class Customer
{
    public string Name { get; };
    public Customer(string first, string last)
    {
        Name = first + &quot; &quot; + last;
    }
}
</code></pre>
<blockquote>
<p>这使得我们可以更简洁的表述类型，但是它同时也消除了语言中可变类型与不可变类型之间的区别：自动属性是一种简写，只有当我们愿意让我们的类可变并且属性适合使用默认值初始化的时候才使用。现在，使用只读属性，可变与不可变之间区别不再。</p>
</blockquote>
<h2 id="u6210_u5458_u8868_u8FBE_u5F0F"><a href="#u6210_u5458_u8868_u8FBE_u5F0F" class="headerlink" title="成员表达式"></a>成员表达式</h2><p>Lambda表达式可以被定义为一个表达式主体以及传统函数那样由一个块包含的函数体。现在这种特性也可以用来定义类型成员了。</p>
<h3 id="u65B9_u6CD5_u8868_u8FBE_u5F0F"><a href="#u65B9_u6CD5_u8868_u8FBE_u5F0F" class="headerlink" title="方法表达式"></a>方法表达式</h3><p>方法、用户自定义运算符以及转换操作现在可以通过使用“Lambda箭头”给定一个表达主体来定义了。</p>
<pre><code class="csharp">public Point Move(int dx, int dy) =&gt; new Point(x + dx, y + dy); 
public static Complex operator +(Complex a, Complex b) =&gt; a.Add(b);
public static implicit operator string(Person p) =&gt; p.First + &quot; &quot; + p.Last;
</code></pre>
<p>就如同方法语句块中只有一个返回表达式一样。</p>
<p>对于无返回值的方法、包括返回<code>Task</code>类型的方法、这种语法仍然适用，但是箭头后面必须是一个声明表达式：</p>
<pre><code class="csharp">public void Print() =&gt; Console.WriteLine(First + &quot; &quot; + Last);
</code></pre>
<h3 id="u5C5E_u6027_u8868_u8FBE_u5F0F"><a href="#u5C5E_u6027_u8868_u8FBE_u5F0F" class="headerlink" title="属性表达式"></a>属性表达式</h3><p>属性和索引器可以有读方法（<code>get</code>）以及写方法（<code>set</code>）。上述的表达式写法可以被用到只读属性和索引器中：</p>
<pre><code class="csharp">public string Name =&gt; First + &quot; &quot; + Last;
public Customer this[long id] =&gt; store.LookupCustomer(id);
</code></pre>
<blockquote>
<p>注意这里并没有<code>get</code>关键字，使用这种语法时它是隐式声明的。</p>
</blockquote>
<h2 id="Using_static"><a href="#Using_static" class="headerlink" title="Using static"></a>Using static</h2><p>这个特性使我们可以声明静态方法所在命名空间，然后再代码中可以直接使用静态方法而不用添加其所在命名空间前缀。</p>
<pre><code class="csharp">using static System.Console;
using static System.Math;
using static System.DayOfWeek;
class Program
{
    static void Main()
    {
        WriteLine(Sqrt(3*3 + 4*4)); 
        WriteLine(Friday - Monday); 
    }
}
</code></pre>
<p>当我们需要使用特定域中的一组函数时很有用，<code>System.Math</code>只是一个常见的例子。同时，它还允许直接指定枚举类型个人命名，比如<code>System.DayOfWeek</code>。</p>
<h3 id="u6269_u5C55_u65B9_u6CD5"><a href="#u6269_u5C55_u65B9_u6CD5" class="headerlink" title="扩展方法"></a>扩展方法</h3><p>扩展方法是静态方法，但是被当作实例方法来使用。通过使用<code>using static</code>而不是引入命名空间，使得一个类型的扩展方法可被真正做为“扩展”方法。</p>
<pre><code class="csharp">using static System.Linq.Enumerable; // The type, not the namespace
class Program
{
    static void Main()
    {
        var range = Range(5, 17);                // Ok: not extension
        var odd = Where(range, i =&gt; i % 2 == 1); // Error, not in scope
        var even = range.Where(i =&gt; i % 2 == 0); // Ok
    }
}
</code></pre>
<h2 id="Null_u6761_u4EF6_u8FD0_u7B97_u7B26"><a href="#Null_u6761_u4EF6_u8FD0_u7B97_u7B26" class="headerlink" title="Null条件运算符"></a>Null条件运算符</h2><p>在我们的代码中通常要进行一堆的 null 检查，现在<code>C# 6</code>引入了新的运算符，只有当运算符作用者不为<code>null</code>时才能访问其成员和元素，否则表达式返回<code>null</code>。</p>
<pre><code class="csharp">int? length = customers?.Length; // null if customers is null
Customer first = customers?[0];  // null if customers is null
</code></pre>
<p>Null条件运算符可以和空合并运算符 <code>??</code> 联合使用：</p>
<pre><code class="csharp">int length = customers?.Length ?? 0; // 0 if customers is null
</code></pre>
<p>Null条件运算符只有在检查到成员非空时才会执行后面紧跟的成员访问、元素访问和方法调用。</p>
<pre><code class="csharp">int? first = customers?[0].Orders.Count();
</code></pre>
<p>上面这个例子本质上等价于：</p>
<pre><code class="csharp">int? first = (customers != null) ? customers[0].Orders.Count() : null;
</code></pre>
<p>除了<code>customers</code>被计算一次之外，除非<code>customers</code>非空，否则跟在 <code>?</code> 后面的成员访问和方法调用将不会被执行。</p>
<p>当然，Null条件运算符可以被连续调用，每次调用都会进行<code>null</code>检查。</p>
<pre><code class="csharp">int? first = customers?[0].Orders?.Count();
</code></pre>
<p>注意一个方法调用不可以直接跟在 <code>?</code> 运算符之后，因为这会导致太多的语法歧义。</p>
<blockquote>
<p>等待测试。这里在 <code>?</code> 运算符后面直接跟的方法是指当前类型中的方法还是 <code>?</code> 前面的变量所拥有的实例方法？看前面的示例，是可以直接调用变量的实力方法的（<code>...Orders?.Count();</code>），如果是说当前类型的方法，那么歧义是因为与三目运算符 <code>?:</code> 冲突吗？</p>
</blockquote>
<p>然而，我们可以调用委托中的<code>Invoke</code>方法：</p>
<pre><code class="csharp">if (predicate?.Invoke(e) ?? false) { … }
</code></pre>
<p>这种使用方法应该在事件触发的时候很常用：</p>
<pre><code class="csharp">PropertyChanged?.Invoke(this, args);
</code></pre>
<p>这是一种简单并且<code>线程安全</code>的方式去在触发事件之前做 null 检查。说它是<code>线程安全</code>的，是因为这个方式只执行 <code>?</code> 左边表达式一次，并且将其保存在一个临时变量中。</p>
<blockquote>
<p>说明：这里保存在临时变量中的是那个<code>PropertyChanged</code>实例。</p>
<p>也就是说，上面的事件触发代码等价于：</p>
<pre><code class="csharp">var handler = PropertyChanged;
if (handler != null)
{
    handler.Invoke(this, args);
}
</code></pre>
<p>而这里，需要说明在<code>.Net</code>中使用<code>C#</code>进行事件的订阅和取消时，其实返回的<code>Handler</code>是一个新的对象，所以对于上面的代码来说，当我们通过临时变量<code>handler</code>引用<code>PropertyChanged</code>实例之后，即使又有线程对这个事件进行了取消订阅操作导致事件变为<code>null</code>，也不会影响这个临时变量的值，因此不会导致接下来的调用出现异常。</p>
<p>因此，通过 <code>?</code> 方式触发事件是<code>线程安全</code>的（这个也应该是编译器特别优化的吧）。而在使用<code>C# 6</code>之前的语言编程时，如果要触发一个事件，我们也应该像上面那样通过一个临时变量引用事件实例，然后再判断触发，这样才能保证事件的线程安全。</p>
</blockquote>
<h2 id="u5B57_u7B26_u4E32_u63D2_u503C"><a href="#u5B57_u7B26_u4E32_u63D2_u503C" class="headerlink" title="字符串插值"></a>字符串插值</h2><p><code>string.Format</code>和它的同类被我们经常使用，但是它们的用法有一点笨拙且容易出错。特别是占位符<code>{0}</code>等，它们必须与参数分别提供：</p>
<pre><code class="csharp">var s = String.Format(&quot;{0} is {1} year old&quot;, p.Name, p.Age);
</code></pre>
<p>字符串插值允许我们通过“洞”来直接把表达式插入到正确的位置：</p>
<pre><code class="csharp">var s = $&quot;{p.Name} is {p.Age} year old&quot;;
</code></pre>
<p>和<code>string.Format</code>一样，我们可以定义一些可选的对齐及格式方式：</p>
<pre><code class="csharp">var s = $&quot;{p.Name,20} is {p.Age:D3} year old&quot;;
</code></pre>
<p>“洞”的内容可以是任意表达式，甚至是其它字符串：</p>
<pre><code class="csharp">var s = $&quot;{p.Name} is {p.Age} year{(p.Age == 1 ? &quot;&quot; : &quot;s&quot;)} old&quot;;
</code></pre>
<blockquote>
<p>注意条件表达式被括号括起来了，所以 <code>: &quot;s&quot;</code> 并不会和格式说明符混淆。</p>
</blockquote>
<h2 id="nameof_u8868_u8FBE_u5F0F"><a href="#nameof_u8868_u8FBE_u5F0F" class="headerlink" title="nameof表达式"></a>nameof表达式</h2><p>有时候我们会需要提供一些这样的字符串，字符串内容是某些程序元素的名称。比如当我们抛出一个<code>ArgumentNullException</code>异常的时候，我们希望可以给出出错的参数名称；而当我们激活一个<code>PropertyChanged</code>事件的时候，我们需要给出变化的属性的名称；等等。</p>
<p>使用一个硬编码的字符串很简单，但是很容易出错。我们可能一不小心出现拼写错误，又或者当进行代码重构时这个字符串就会过期。<code>nameof</code>表达式本质上是一个字符串，由编译器检查你所给的参数并赋值，Visual Studio 知道它所引用的内容，所以导航和重构都能正确工作。</p>
<pre><code class="csharp">(if x == null) throw new ArgumentNullException(nameof(x));
</code></pre>
<p>你可以在<code>nameof</code>表达式传递更复杂的由点分割的参数，但这只是告诉编译器该看哪里：只有最后的标识符将被使用：</p>
<pre><code class="csharp">WriteLine(nameof(person.Address.ZipCode)); // prints &quot;ZipCode&quot;
</code></pre>
<h2 id="u7D22_u5F15_u5668_u5BF9_u8C61_u521D_u59CB_u5316"><a href="#u7D22_u5F15_u5668_u5BF9_u8C61_u521D_u59CB_u5316" class="headerlink" title="索引器对象初始化"></a>索引器对象初始化</h2><p>对象和集合初始化可用于声明性的初始化对象字段和属性、或者给一组集合元素初始化，但是字典对象或者带索引器的对象初始化时却不甚优雅。现在我们可以通过新的对象初始化语法来给索引器指定的键设置初值，如下所示：</p>
<pre><code class="csharp">var numbers = new Dictionary&lt;int, string&gt; 
{
    [7] = &quot;seven&quot;,
    [9] = &quot;nine&quot;,
    [13] = &quot;thirteen&quot;
};
</code></pre>
<h2 id="u5F02_u5E38_u8FC7_u6EE4_u5668"><a href="#u5F02_u5E38_u8FC7_u6EE4_u5668" class="headerlink" title="异常过滤器"></a>异常过滤器</h2><p><code>VB</code>中存在，<code>F#</code>中也存在，现在<code>C#</code>中也有了。它长的大概像这样：</p>
<pre><code class="csharp">try { … }
catch (MyException e) when (myfilter(e))
{
    …
}
</code></pre>
<p>如果括号表达式中的结果为<code>true</code>，那么将运行<code>catch</code>块，否则异常将被继续向上抛出。</p>
<p>异常过滤器比捕捉然后重新抛出异常的方式更好，因为异常过滤器不会破坏堆栈内容。如果一个异常最后会导致堆栈被清空，使用过滤器方式你可以看到异常的原始来源，而不是它最后被重新抛出的地方。</p>
<p>异常过滤器有一些被普遍认可的“滥用”，比如日志记录，而这会导致一些副作用。它们可以检查而不拦截异常，这样，这些过滤器通常会给出一个<code>false</code>返回值，这会产生一些副作用，比如异常块总是不被执行：</p>
<pre><code class="csharp">private static bool Log(Exception e) { /* log it */ ; return false; }
…
try { … } catch (Exception e) when (Log(e)) {}
</code></pre>
<blockquote>
<p>不知道异常过滤器函数签名是不是被固定了，如果仅仅要求函数有一个bool返回值（以及一个<code>Exception</code>参数和其它可选参数），那么对于异常过滤器函数，我们可以通过传入更多的参数来决定返回值是<code>true</code>或者<code>false</code>，以此来控制异常处理块是否执行。</p>
</blockquote>
<h2 id="u5728catch_u548Cfinally_u5757_u4E2D_u4F7F_u7528await"><a href="#u5728catch_u548Cfinally_u5757_u4E2D_u4F7F_u7528await" class="headerlink" title="在catch和finally块中使用await"></a>在catch和finally块中使用await</h2><p>下面是微软原文的幽默：</p>
<blockquote>
<p><code>C# 5</code>中我们不允许在catch块和finally块中出现<code>await</code>关键字，因为我们设法让自己相信那是不可能实现的。但是现在我们弄懂了，显然这并不是不可能的。</p>
</blockquote>
<p>这实际上是一个很值得注意的限制，使得人们不得不用其它“丑陋的”解决方式。现在这个限制不在了：</p>
<pre><code class="csharp">Resource res = null;
try
{
    res = await Resource.OpenAsync(…);       // You could do this.
    …
} 
catch(ResourceException e)
{
    await Resource.LogAsync(res, e);         // Now you can do this …
}
finally
{
    if (res != null) await res.CloseAsync(); // … and this.
}
</code></pre>
<blockquote>
<p>这个实现是相当复杂的，但是你不用去担心。这是这个语言中异步的重点。</p>
</blockquote>
<h2 id="u96C6_u5408_u521D_u59CB_u5316_u5668_u6269_u5C55_u65B9_u6CD5"><a href="#u96C6_u5408_u521D_u59CB_u5316_u5668_u6269_u5C55_u65B9_u6CD5" class="headerlink" title="集合初始化器扩展方法"></a>集合初始化器扩展方法</h2><blockquote>
<p>当我们在<code>C#</code>中首次实现集合初始化器的时候，<code>Add</code>方法不能作为扩展方法调用。<code>VB</code>从一开始就有了，但是看起来我们似乎忘了在<code>C#</code>中加入。现在这个问题解决了：集合初始化代码中可以很愉快的使用一个叫做<code>Add</code>的扩展方法。这不是一个大的特性，但是它偶尔很有用，而结果证明在新的编译器中实现它相当于删除一个阻止它的检查。</p>
</blockquote>
<h2 id="u6539_u8FDB_u7684_u91CD_u8F7D_u89E3_u6790"><a href="#u6539_u8FDB_u7684_u91CD_u8F7D_u89E3_u6790" class="headerlink" title="改进的重载解析"></a>改进的重载解析</h2><blockquote>
<p>在重载解析上有很多小的改进，这可能会使得很多事情会按照你所期望的方式工作。所有的改进都和“betterness”有关，所谓“betterness”，是编译器决定对于指定参数两个重载方法哪一个更合适的方法。</p>
<p>当在可空值类型重载方法之间选择时，你可能会注意到这点；另一点是在函数组（相对于Lambdas）中重载期望的委托。细节不值得在这里多说，只是想让你知道！</p>
</blockquote>
]]></content>
    <summary type="html">
    <![CDATA[<p>微软新一代开发工具<code>Visual Studio 2015</code>正式版已经于北京时间 2015年7月20日 23:30 发布了，而作为<code>.Net</code>开发中的主力开发语言<code>C#</code>，也已经走到了<code>C# 6</code>。</p>
<p>那么作为<code>C#</code>开发语言的最新版本，微软又给它添加或改进了哪些特性呢？</p>
<p><code>C# 6</code>的新特性是和微软的 .Net 开源编译器<a href="https://github.com/dotnet/roslyn">Roslyn</a>紧密相连的，在其 GitHub 页面中，也给出了<code>C# 6</code>新特性：<a href="https://github.com/dotnet/roslyn/wiki/New-Language-Features-in-C%23-6">New Language Features in C# 6</a>。下面内容一部分为简单的翻译，以及在查看时的一些理解和疑问，由于目前我还没发下载最新版 Win10 和 VS 2015，因此有些地方暂时还没发验证猜想。等待后续更新。</p>
<p>下面先列出<code>C# 6</code>中的新特性：</p>
<ul>
<li><p>自动属性初始值表达式</p>
<blockquote>
<p><code>public int X { get; set; } = x;</code></p>
</blockquote>
</li>
<li><p>只读自动属性</p>
<blockquote>
<p><code>public int Y { get; } = y;</code></p>
</blockquote>
</li>
<li><p>静态导入<code>using static</code></p>
<blockquote>
<pre><code class="csharp">using static System.Console;
// ...
Write(4);
</code></pre>
</blockquote>
</li>
<li><p>索引器对象初始化</p>
<blockquote>
<p><code>new JObject { [&quot;x&quot;] = 3 }</code></p>
</blockquote>
</li>
<li><p>在<code>catch</code>和<code>finally</code>块中使用<code>await</code></p>
<blockquote>
<p><code>try { ... } catch { await ... } finally { await ... }</code></p>
</blockquote>
</li>
<li><p>异常筛选器</p>
<blockquote>
<p><code>catch(Exception e) when (e.Count &gt; 5) { ... }</code></p>
</blockquote>
</li>
<li><p>函数/属性表达式</p>
<blockquote>
<p><code>public double Dist =&gt; Sqrt(X * X + Y * Y);</code></p>
</blockquote>
</li>
<li><p>Null条件运算符</p>
<blockquote>
<p><code>customer?.Orders?[5]</code></p>
</blockquote>
</li>
<li><p>字符串插值</p>
<blockquote>
<p><code>$&quot;{p.Name} is {p.Age} years old.&quot;</code></p>
</blockquote>
</li>
<li><p><code>nameof</code>运算符</p>
<blockquote>
<p><code>string s = nameof(Console.Write);</code></p>
</blockquote>
</li>
<li><p>其它改进</p>
<blockquote>
<ul>
<li>#pragma</li>
<li>集合初始化支持扩展方法<code>Add</code></li>
<li>重载方法解析改进</li>
</ul>
</blockquote>
</li>
</ul>]]>
    
    </summary>
    
      <category term="C#" scheme="http://3meng.github.io/tags/C/"/>
    
      <category term="随笔" scheme="http://3meng.github.io/categories/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[SQLite与“继承映射”]]></title>
    <link href="http://3meng.github.io/2015/07/16/SQLite-and-inheritance-mapping/"/>
    <id>http://3meng.github.io/2015/07/16/SQLite-and-inheritance-mapping/</id>
    <published>2015-07-16T15:02:19.000Z</published>
    <updated>2016-02-22T14:29:46.000Z</updated>
    <content type="html"><![CDATA[<h2 id="SQLite"><a href="#SQLite" class="headerlink" title="SQLite"></a>SQLite</h2><p>SQLite 的网站 (<a href="http://www.sqlite.org/" target="_blank" rel="external">sqlite.org</a>) 对SQL进行了如下描述：</p>
<blockquote>
<p>SQLite 是一个可实现独立、无服务器、零配置、事务性 SQL 数据库引擎的软件库。</p>
</blockquote>
<p>SQLite 完全驻留在客户端进程中，这使之成为一种<strong>嵌入式</strong>数据库。 在使用期间，SQLite 数据库的运行空间是一个存储在客户端文件系统的某一位置中的单个文件，并且安装空间通常也相当小。 </p>
<p>尽管如此，SQLite 数据库的功能却是极其丰富的，因为它支持大部分<em>SQL-92</em> 规范，只是去除了 RIGHT 和 FULL OUTER JOIN、ALTER TABLE、某一触发器支持、GRANT/REVOKE 以及写入 VIEW 等几项内容（更详细的说明请参见<a href="http://www.sqlite.org/" target="_blank" rel="external">SQLite 网站</a>）。令人印象深刻的是支持的功能数量，包括事务和各种数据类型。这使 SQLite 十分适合只需<strong>轻型 SQL</strong>的情形。 </p>
<p>有关更详细的 SQLite 体系结构和用法说明，还可以查看<a href="https://www.microsoft.com/china/msdn/x-platform/developing_17.html" target="_blank" rel="external">这里</a>。</p>
<a id="more"></a>
<h2 id="u7EE7_u627F_u6620_u5C04"><a href="#u7EE7_u627F_u6620_u5C04" class="headerlink" title="继承映射"></a>继承映射</h2><p>关系数据库中的表之间不存在继承关系，为了将面向对象中的继承关系映射到关系数据库中，可以使用以下三种继承映射策略：</p>
<ul>
<li><p>每个继承层次一张表</p>
<blockquote>
<p>描述一个继承关系只用一张表，也就是说子类所使用的表与父类相同。</p>
<p><strong>优点：</strong></p>
<ul>
<li>维护方便，在任何情况下都只需要处理一张表。</li>
<li>执行效率最高（无需外连接）。</li>
</ul>
<p><strong>缺点：</strong> </p>
<ul>
<li>需要在数据库中加入额外的区分子类的字段。</li>
<li>不允许对子类成员属性对应的字段定义<code>Not Null</code>约束。</li>
<li>灵活性差，表中冗余字段会随着子类的增加而越来越多。</li>
</ul>
</blockquote>
</li>
<li><p>每个具体类一张表</p>
<blockquote>
<p>每个具体类对应一张表，有多少具体类就需要建立多少个独立的表。每张表中包含了具体类的所有属性，包括从基类继承过来的属性。</p>
<p><strong>优点：</strong></p>
<ul>
<li>映射的灵活性大，可以对每个属性进行单独的配置（包括继承的属性）。</li>
<li>对于子类的查询只需要一张表。</li>
</ul>
<p><strong>缺点：</strong></p>
<ul>
<li>存在太多冗余字段。</li>
<li>如果需要对基类进行修改，则需要对基类及其所有子类都进行修改。</li>
</ul>
</blockquote>
</li>
<li><p>每个子类一张表</p>
<blockquote>
<p>每个子类使用一张表，但这些子类所对应的表都关联到基类所对应的表中。也就是子类对应的表中仅保存当前类中定义的属性，不包含父类的属性。</p>
<p><strong>优点：</strong></p>
<ul>
<li>不存在冗余。</li>
<li>可以对每个属性进行单独配置。</li>
<li>维护方便，对每个类的修改只需要修改其所对应的表。</li>
</ul>
<p><strong>缺点：</strong></p>
<ul>
<li>查询时需要进行连接，性能不如另外两个。</li>
</ul>
</blockquote>
</li>
</ul>
<p>有关<code>继承映射</code>的更多内容，可以自行搜索。</p>
<h2 id="SQLite_u5904_u7406"><a href="#SQLite_u5904_u7406" class="headerlink" title="SQLite处理"></a>SQLite处理</h2><p>对于<code>.Net</code>平台，有许多的SQLite帮助程序库，可以简化SQLite的操作。这里在<code>Windows Phone 8</code>平台上使用相应的帮助库来测试SQLite数据库。有关如何在<code>Windows Phone 8</code>中使用SQLite数据库，可以查看<code>sqlite-net-wp8</code>的<a href="https://github.com/peterhuene/sqlite-net-wp8" target="_blank" rel="external">说明</a>。</p>
<h3 id="u521B_u5EFA_u6570_u636E_u5E93_u8868"><a href="#u521B_u5EFA_u6570_u636E_u5E93_u8868" class="headerlink" title="创建数据库表"></a>创建数据库表</h3><p>要创建一个数据库表，我们需要定义相对应的实体类，并且使用对应的特性（<code>Attribute</code>）去修饰相应的类（<code>class</code>）和属性（<code>Property</code>）。如下是一个实体类定义：</p>
<pre><code class="csharp">[Table(&quot;base_data&quot;)]
public class BaseData
{
    [PrimaryKey, AutoIncrement, Column(&quot;id&quot;)]
    public int ID { get; set; }

    [Column(&quot;name&quot;)]
    public string Name { get; set; }

    [Column(&quot;key&quot;), NotNull]
    public string Key { get; set; }
}
</code></pre>
<h3 id="u7EE7_u627F_u6620_u5C04_uFF1F"><a href="#u7EE7_u627F_u6620_u5C04_uFF1F" class="headerlink" title="继承映射？"></a>继承映射？</h3><p>对于一个实体类，我们需要使用<code>TableAttribute</code>修饰，并传入表名称。而在查找的时候，同样需要传入要查找的表对应的实体类型，因此，我觉得SQLite-net在对继承映射处理时采用了一种更简单的实现：对于每个具体的实体类都对应一个表，在这张表中会包含有该类所有的（包括基类）具有<code>ColumnAttribute</code>特性的属性，但是SQLite-net并不提供在继承映射中最重要的一个特性：查询父类时同时返回所有符合条件的子类。</p>
<p>本来SQLite就是一个轻量级的数据库，因此SQLite-net在实现的时候，只是把我们定义的实体类作为一个类似参照的东西，所以对于<code>Table</code>的修饰也没有要求更多的与继承映射有关的字段。不过这样也好，毕竟一般当我们需要使用类似SQLite的数据库时，也不会有太多的要求，而SQLite-net这样的处理，一般并不会影响我们对数据的处理。</p>
<h3 id="u5206_u6790_-__u6E90_u4EE3_u7801"><a href="#u5206_u6790_-__u6E90_u4EE3_u7801" class="headerlink" title="分析 - 源代码"></a>分析 - 源代码</h3><p>为了验证SQLite-net对具有继承关系的实体类的处理方式，我们可以查看它的源代码。而与SQLite-net对类的处理方式直接相关联的就是那几个<code>Attribute</code>了，从<code>MSDN</code>中可以查到，对于一个<code>Attribute</code>特性，可以使用<code>AttributeUsageAttribute</code>类来指示其使用方法，该类的声明如下：</p>
<pre><code class="csharp">/// &lt;summary&gt;
/// 指定另一特性类的用法。无法继承此类。
/// &lt;/summary&gt;
public sealed class AttributeUsageAttribute : System.Attribute
{
    /// &lt;summary&gt;
    /// 用指定的 &lt;see cref=&quot;System.AttributeTargets&quot;/&gt;、
    /// &lt;see cref=&quot;System.AttributeUsageAttribute.AllowMultiple&quot;/&gt; 值和 
    /// &lt;see cref=&quot;System.AttributeUsageAttribute.Inherited&quot;/&gt; 值列表初始化
    /// System.AttributeUsageAttribute 类的新实例。
    /// &lt;/summary&gt;
    /// &lt;param name=&quot;validOn&quot;&gt; 使用按位 OR 运算符组合的一组值，用于指示哪些程序元素是有效的。&lt;/param&gt;
    public AttributeUsageAttribute(System.AttributeTargets validOn);

    /// &lt;summary&gt;
    /// 获取一组值，这组值标识指示的特性可应用到的程序元素。
    /// &lt;/summary&gt;
    public System.AttributeTargets ValidOn { get; private set; }

    /// &lt;summary&gt;
    /// 获取或设置一个布尔值，该值指示能否为一个程序元素指定多个指示特性实例。
    /// &lt;/summary&gt;
    public bool AllowMultiple { set; get; }

    /// &lt;summary&gt;
    /// 获取或设置一个布尔值，该值指示指示的特性能否由派生类和重写成员继承。
    /// &lt;/summary&gt;
    public bool Inherited { set; get; }
}
</code></pre>
<p>我们可以指定一个<code>Attribute</code>的使用范围（使用<code>AttributeTargets</code>枚举，例如类、属性、方法、参数等），还可以指定该特性能否在一个元素上重复使用（使用<code>AllowMultiple</code>属性），而最后一个<code>Inherited</code>属性则是我们关注的重点，该值指示这个特性能否被继承，也就是在基类的某个元素中定义的特性，在子类中是否有效，这个属性的默认值为<code>true</code>。</p>
<p>而在<code>SQLite.cs</code>文件中，我们可以找到<code>TableAttribute</code>、<code>ColumnAttribute</code>等的定义：</p>
<pre><code class="csharp">[AttributeUsage(AttributeTargets.Class)]
public class TableAttribute : System.Attribute { ... }

[AttributeUsage(AttributeTargets.Property)]
public class ColumnAttribute : System.Attribute { ... }
</code></pre>
<p>从定义中可以看出，这些特性都可以被继承，因此对于一个子类来说，基类中的数据库表字段它也会拥有，这就简化了我们对实体类的定义，我们可以按照一般的对象抽象方式，为实体类创建相应的继承关系。例如我们可以把一些在所有的数据库表中都存在的字段移到一个公共基类中去定义，而且这样做，以后我们对数据库进行操作时，也可以利用面向对象的多态来进行处理。</p>
<h3 id="u5206_u6790_-__u8C03_u8BD5"><a href="#u5206_u6790_-__u8C03_u8BD5" class="headerlink" title="分析 - 调试"></a>分析 - 调试</h3><p>实验是检验真理的唯一标准。为了更明确的观察SQLite-net对继承的实体类的处理，我们可以构建相应的测试程序。</p>
<p>在这里，首先定义如下的测试数据库实体类：</p>
<pre><code class="csharp">public class Data
{
    [PrimaryKey, AutoIncrement, Column(&quot;id&quot;)]
    public int ID { get; set; }
}

[Table(&quot;base_data&quot;)]
public class BaseData : Data
{
    [Column(&quot;name&quot;)]
    public string Name { get; set; }

    [Column(&quot;key_value&quot;)]
    public string KeyValue { get; set; }

    public override string ToString()
    {
        return string.Format(&quot;ID: {0}; Name: {1}; KeyValue: {2}&quot;, ID, Name, KeyValue);
    }
}

[Table(&quot;child_data&quot;)]
public class ChildData : BaseData
{
    [Column(&quot;list&quot;)]
    public string List { get; set; }

    [Column(&quot;date&quot;)]
    public DateTime? Date { get; set; }

    [Column(&quot;bool_null&quot;)]
    public bool? BoolNull { get; set; }

    public override string ToString()
    {
        return string.Format(&quot;{0}\nList: {1}; Date:{2}; Bool: {3}&quot;, 
            base.ToString(), List, Date, BoolNull);
    }
}
</code></pre>
<p>然后再应用中创建数据库并向两个表中填充一些数据。之后在进行查询操作，通过<code>select * from table</code>列出数据库表中的所有数据，从查询结果可以看出，对于基类<code>BaseData</code>所对应的数据库表的查询并不会返回其子类所对应的表中的数据。</p>
<h2 id="u7ED3_u8BBA"><a href="#u7ED3_u8BBA" class="headerlink" title="结论"></a>结论</h2><p>SQLite-net并没有完整的实现一种继承映射，但是依靠<code>.Net</code>中的<code>Attribute</code>，使得我们在为数据库创建实体类的时候，完全可以按照一般的分析分析方法，而对数据库的操作，在SQLite-net中也是反映到对类的操作上，因此我们也可以完全的利用面向对象中的各种特性，例如多态。</p>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="SQLite"><a href="#SQLite" class="headerlink" title="SQLite"></a>SQLite</h2><p>SQLite 的网站 (<a href="http://www.sqlite.org/">sqlite.org</a>) 对SQL进行了如下描述：</p>
<blockquote>
<p>SQLite 是一个可实现独立、无服务器、零配置、事务性 SQL 数据库引擎的软件库。</p>
</blockquote>
<p>SQLite 完全驻留在客户端进程中，这使之成为一种<strong>嵌入式</strong>数据库。 在使用期间，SQLite 数据库的运行空间是一个存储在客户端文件系统的某一位置中的单个文件，并且安装空间通常也相当小。 </p>
<p>尽管如此，SQLite 数据库的功能却是极其丰富的，因为它支持大部分<em>SQL-92</em> 规范，只是去除了 RIGHT 和 FULL OUTER JOIN、ALTER TABLE、某一触发器支持、GRANT/REVOKE 以及写入 VIEW 等几项内容（更详细的说明请参见<a href="http://www.sqlite.org/">SQLite 网站</a>）。令人印象深刻的是支持的功能数量，包括事务和各种数据类型。这使 SQLite 十分适合只需<strong>轻型 SQL</strong>的情形。 </p>
<p>有关更详细的 SQLite 体系结构和用法说明，还可以查看<a href="https://www.microsoft.com/china/msdn/x-platform/developing_17.html">这里</a>。</p>]]>
    
    </summary>
    
      <category term="SQLite" scheme="http://3meng.github.io/tags/SQLite/"/>
    
      <category term="继承映射" scheme="http://3meng.github.io/tags/%E7%BB%A7%E6%89%BF%E6%98%A0%E5%B0%84/"/>
    
      <category term="数据库" scheme="http://3meng.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[从CHK文件中恢复数据]]></title>
    <link href="http://3meng.github.io/2015/06/11/recovery-data-from-chk-file/"/>
    <id>http://3meng.github.io/2015/06/11/recovery-data-from-chk-file/</id>
    <published>2015-06-11T15:21:29.000Z</published>
    <updated>2016-02-22T14:32:23.000Z</updated>
    <content type="html"><![CDATA[<p>在使用电脑的过程中，总会遇到各种各样的故障，导致电脑非正常关机，或者由于其它的原因，最终使得磁盘某些文件（夹）存储出现错误。一般表现为文件夹无法访问，或者是在资源管理器中看不到对应文件或文件夹（而实际上这些文件还是可访问），这时候我们就需要想办法将这些数据恢复到正常状态或者从磁盘中删除了，因为虽然你无法通过资源管理器或者一般应用去访问这些数据，但是它们其实还是被存储在磁盘中某一个区域，仍然占据着磁盘空间。</p>
<a id="more"></a>
<h2 id="u8D77_u56E0"><a href="#u8D77_u56E0" class="headerlink" title="起因"></a>起因</h2><p>前一阵子电脑偶尔出现开机黑屏或者运行时死机的现象，没办法，都是直接长按电源键直接关机了（这里顺便提一下，如果你在碰倒电脑无反应需要强制关机的时候，建议等一等，看一看这个时候硬盘灯是不是亮着，如果亮着，请尽量等待它熄了之后在强关。当然，如果没有硬盘指示灯的就没办法了，可以试着听一下声音看硬盘是否正在被访问），而就在不久前一次开机，就突然发现一个绿色小软件打不开了，提示无法找到路径（桌面快捷方式打开的），于是进资源管理器一看，文件夹还在，但是双击就提示“文件或目录已损坏且无法读取，请运行chkdsk工具修复”，对该文件夹也无法进行任何操作，包括改名删除等。</p>
<p>于是上网搜了一下，大概就是说磁盘文件目录出错，按照提示用<code>chkdsk</code>命令修复就行了。那么首先就是用管理员权限运行命令提示符（<code>cmd</code>），然后可以输入<code>chkdsk /?</code>来查看这个命令的帮助以及参数：</p>
<pre><code>Microsoft Windows [版本 6.3.9600]
(c) 2013 Microsoft Corporation。保留所有权利。

C:\Windows\system32&gt;chkdsk /?
检查磁盘并显示状态报告。

CHKDSK [volume[[path]filename]]] [/F] [/V] [/R] [/X] [/I] [/C] [/L[:size]] [/B] [/scan] [/spotfix]

  volume          指定驱动器号(后面跟一个冒号)、
                  装入点或卷名。
  filename        仅 FAT/FAT32: 指定要检查
                  碎片的文件。
  /F              修复磁盘上的错误。
  /R              查找坏扇区并恢复可读信息
                  (未指定 /scan 时，隐含 /F)。
  /X              如果必要，则先强制卸除卷。
                  该卷的所有打开的句柄都将无效
                  (隐含 /F)。
  /scan           仅 NTFS: 在卷上运行联机扫描
  /offlinescanandfix  在卷上运行脱机扫描并进行修复。
  ...

/I 或 /C 开关通过跳过对卷的某些检查，
来减少运行 Chkdsk 所需的时间长度。
</code></pre><p>因为我的受损的文件存储在D盘，所以直接输入<code>chkdsk D: /R</code>，这是如果被检查的盘上有文件正在被使用，就会提示是否强制卸载该卷（y/n），一般选择n，然后就会提示是否创建计划任务，在下次开机时运行检查，这时可以选择是，然后重启就会开始进行检查。</p>
<p>当重启进入系统后，可以发现损坏的目录已经消失了，然后我就去重新下载了那个软件，放到原来的路径下，就继续开始使用了。本以为一切就此结束，但是今天却在用另外一个软件（也是在D盘）的时候发现了问题。</p>
<h2 id="CHK_u6587_u4EF6"><a href="#CHK_u6587_u4EF6" class="headerlink" title="CHK文件"></a>CHK文件</h2><p>由于突然想来亲自验证一下C++中<code>static</code>成员变量的初始化顺序，以便确定前几天所想的适用于多线程环境中的单实例类是否能正确运行，于是从桌面快捷方式直接启动<em>CodeBlocks</em>，结果进入之后右下角提示在指定的位置找不到编译器。</p>
<p>于是在桌面右键程序图标查看快捷方式属性，结果突然提示快捷方式起始位置不存在，然后就发现快捷方式中<strong>目标</strong>属性指向了地址<code>D:\found.000\dir0000.chk\codeblocks.exe</code>，而<strong>起始位置</strong>属性则是指向了<code>D:\Program Files(x86)\Codeblocks</code>；于是进入资源管理器，D盘根目录下找不到<em>found.000</em>文件夹，而<em>Program Files(x86)</em>目录下也没有<em>CodeBlocks</em>文件夹…没办法，只有从任务管理器进入进程所在目录了，结果提示文件夹无法访问，在地址栏输入路径也是一样的结果。</p>
<p>但是明明通过快捷方式是可以打开程序的，这说明程序文件夹依然完好无损，而且在<em>CodeBlocks</em>编译器设置中通过点击自动设置编译器所在目录，编译器也可以正常启动运行了，此时在设置中可以看到设置的编译器位置为<code>D:\found.000\dir0000.chk\MinGW\bin</code>，也说明这个路径是存在的，只是我们需要一些特殊的方法进去了。</p>
<p>首先在网上搜索了一下CHK文件，结果显示这是Windows磁盘修复时创建的文件，描述为“恢复的文件碎片”，也就是当Windows进行磁盘修复时检测到出现错误的文件或文件夹，会在当前磁盘根目录下创建<em>found.000</em>、<em>found.001</em>等文件夹保存这些恢复的文件，所以通过将这个文件夹中的东西恢复，就可以找回丢失的数据了，当然，不一定全部且正确。</p>
<h2 id="u6062_u590D_u6587_u4EF6"><a href="#u6062_u590D_u6587_u4EF6" class="headerlink" title="恢复文件"></a>恢复文件</h2><p>那么接下来依然是<code>CMD</code>了，使用管理员权限启动，尝试通过<code>cd</code>命令进入<em>found.000</em>文件夹，居然成功了，那么看起来似乎可行。然后通过<code>dir</code>命令查看这个文件夹下面的所有文件和文件夹信息，结果没有看到<em>dir0000.chk</em>目录，于是查看<code>dir</code>命令帮助：</p>
<pre><code>Microsoft Windows [版本 6.3.9600]
(c) 2013 Microsoft Corporation。保留所有权利。

C:\Windows\system32&gt;dir /?
显示目录中的文件和子目录列表。

DIR [drive:][path][filename] [/A[[:]attributes]] [/B] [/C] [/D] [/L] [/N]
  [/O[[:]sortorder]] [/P] [/Q] [/R] [/S] [/T[[:]timefield]] [/W] [/X] [/4]

  [drive:][path][filename]
              指定要列出的驱动器、目录和/或文件。

  /A          显示具有指定属性的文件。
  属性         D  目录                R  只读文件
               H  隐藏文件            A  准备存档的文件
               S  系统文件            I  无内容索引文件
               L  解析点             -  表示“否”的前缀
  /S          显示指定目录和所有子目录中的文件。
  ...

可以在 DIRCMD 环境变量中预先设定开关。通过添加前缀 - (破折号)
来替代预先设定的开关。例如，/-W。
</code></pre><p>于是使用<code>dir . /A:H</code>，<em>dir0000.chk</em>目录就可以看到了，当然即使看不到我们也可以使用<code>cd dir0000.chk</code>命令直接进入，这里之所以显示全部文件，是为了看看到底有多少CHK文件。那么接下来就该想办法把文件夹从这里面原样复制出去了，毕竟我们通过资源管理器没办法访问到这里，由于这是一个目录，那么就不能通过<code>copy</code>命令了，这里我们使用<code>copy</code>命令的增强版<code>xcopy</code>命令：</p>
<pre><code>Microsoft Windows [版本 6.3.9600]
(c) 2013 Microsoft Corporation。保留所有权利。

C:\Windows\system32&gt;xcopy /?
复制文件和目录树。

XCOPY source [destination] [/A | /M] [/D[:date]] [/P] [/S [/E]] [/V] [/W]
                           [/C] [/I] [/Q] [/F] [/L] [/G] [/H] [/R] [/T] [/U]
                           [/K] [/N] [/O] [/X] [/Y] [/-Y] [/Z] [/B] [/J]
                           [/EXCLUDE:file1[+file2][+file3]...]

  source       指定要复制的文件。
  destination  指定新文件的位置和/或名称。
  /S           复制目录和子目录，不包括空目录。
  /E           复制目录和子目录，包括空目录。
               与 /S /E 相同。可以用来修改 /T。
  /C           即使有错误，也继续复制。
  /G           允许将加密文件复制到
               不支持加密的目标。
  /H           也复制隐藏文件和系统文件。
  /K           复制属性。一般的 Xcopy 会重置只读属性。
  /O           复制文件所有权和 ACL 信息。
  /X           复制文件审核设置(隐含 /O)。
  /J           复制时不使用缓冲的 I/O。推荐复制大文件时使用。
  ...

开关 /Y 可以预先在 COPYCMD 环境变量中设置。
这可能被命令行上的 /-Y 覆盖。
</code></pre><p>在这里，最好将目录中的所有文件和目录结构都复制出去，而且能保持文件属性是最好的，因此在<em>D:\found.000</em>目录下执行命令<code>xcopy dir0000.chk E:\temp /H /K</code>尝试复制所有文件及目录，其中<em>E:\temp</em>是选择的临时存放位置；复制完成后，经过测试，文件没有损坏，可以正常运行，于是删除<em>D:\found.000\dir0000.chk</em>文件夹，执行<code>rd</code>命令即可：</p>
<pre><code>Microsoft Windows [版本 6.3.9600]
(c) 2013 Microsoft Corporation。保留所有权利。

C:\Windows\system32&gt;rd /?
删除一个目录。

RMDIR [/S] [/Q] [drive:]path
RD [/S] [/Q] [drive:]path

    /S      除目录本身外，还将删除指定目录下的所有子目录和
            文件。用于删除目录树。

    /Q      安静模式，带 /S 删除目录树时不要求确认
</code></pre><p>在目录<em>D:\found.000</em> 下输入<code>rd dir0000.chk /s</code>即可。</p>
<h2 id="u5176_u5B83"><a href="#u5176_u5B83" class="headerlink" title="其它"></a>其它</h2><p>当然，在<code>found.000</code>目录中不一定只有一个文件夹或文件（这里如果丢失的文件属于目录，那么会被命名为<code>dir0000.chk</code>、<code>dir0001.chk</code>…如果不是目录，那么会被命名为<code>file0000.chk</code>、<code>file0001.chk</code>…），具体情况视磁盘错误情况而定，而一般情况下我们可以按照上面的步骤配合使用<code>dir</code>、<code>cd</code>、<code>xcopy</code>等命令将文件夹恢复，然后根据文件夹内容来确定这个文件夹的本来名称；但是对于文件则比较麻烦，如果不是比较重要的文件，或者文件数目不多且大概可以确定文件类型，也可以按照上面的方法，只是最后使用<code>copy</code>命令复制文件即可，但是复制出来的文件是<em>.CHK</em>类型，所以需要手动修改回本来的扩展名，这里也可以借助网上的一些工具来判断文件类型并自动修改。</p>
<p>当文件都恢复之后，便可以删除<code>found.xxx</code>文件夹了。</p>
<p>最后，如果你想在资源管理器中浏览查看有无类似<code>found.000</code>文件夹，可以进入文件夹选项中取消“隐藏受保护的操作系统文件”选项前的对勾。</p>
<h2 id="u9644"><a href="#u9644" class="headerlink" title="附"></a>附</h2><p>上面所说的恢复方式仅仅针对CHK文件而言，也就是你丢失的文件被Windows磁盘修复工具找回来了；但是这些修复工具不是万能的，并不是每次由于磁盘错误造成的文件丢失都能完整的被找回来。至于如果是由于其它情况或者误删文件，那么建议寻找一些<strong>专业的恢复工具</strong>来找回数据（尽量不要用某些非专业数据恢复工具来和丢失的数据开玩笑），并且在数据恢复之前也尽可能的不往数据所在磁盘中写入数据。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>在使用电脑的过程中，总会遇到各种各样的故障，导致电脑非正常关机，或者由于其它的原因，最终使得磁盘某些文件（夹）存储出现错误。一般表现为文件夹无法访问，或者是在资源管理器中看不到对应文件或文件夹（而实际上这些文件还是可访问），这时候我们就需要想办法将这些数据恢复到正常状态或者从磁盘中删除了，因为虽然你无法通过资源管理器或者一般应用去访问这些数据，但是它们其实还是被存储在磁盘中某一个区域，仍然占据着磁盘空间。</p>]]>
    
    </summary>
    
      <category term="CHK文件" scheme="http://3meng.github.io/tags/CHK%E6%96%87%E4%BB%B6/"/>
    
      <category term="数据恢复" scheme="http://3meng.github.io/tags/%E6%95%B0%E6%8D%AE%E6%81%A2%E5%A4%8D/"/>
    
      <category term="随笔" scheme="http://3meng.github.io/categories/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Windows Sockets：多线程WEB服务器]]></title>
    <link href="http://3meng.github.io/2015/06/10/Windows-Sockets/"/>
    <id>http://3meng.github.io/2015/06/10/Windows-Sockets/</id>
    <published>2015-06-09T16:32:10.000Z</published>
    <updated>2016-02-22T14:24:35.000Z</updated>
    <content type="html"><![CDATA[<p>平时如果一个项目需要网络连接，一般都是直接用如<code>C#</code>、<code>Java</code>等高级语言直接调用相关的函数去实现功能，甚至从未关注过在底层这些函数是怎么运作的；而截至不久前，也只是用<code>C#</code>中的Socket相关类做过一点有关长连接的事情。</p>
<p>而最近，恰好由于网络课程实验要求，使用<code>Windows Sockets API</code> + <code>C/C++</code>来实现一个简单的多线程Web服务器，于是开始一边摸索，一边实现功能。在这个实验中，不仅仅是简单的<code>Windows Socket</code>函数调用，其实主要的工作还在于多线程（包括GUI线程）之间的通信，对于HTTP请求，也只是简单的实现了<code>GET</code>方法。</p>
<h2 id="u5B9E_u9A8C_u8981_u6C42"><a href="#u5B9E_u9A8C_u8981_u6C42" class="headerlink" title="实验要求"></a>实验要求</h2><ol>
<li>可配置IP地址、监听端口和主目录</li>
<li>能够在监听端口上进行监听</li>
<li>支持服务的启动</li>
<li>支持服务的关闭</li>
<li>能够响应客户端的请求，并定位相应的html文件</li>
<li>对每个请求能够创建单独的响应线程</li>
<li>能够发送可被客户端解析的响应报文</li>
<li>对于错误的请求能够定位错误的原因并给出相应的响应</li>
<li>支持多种类型文件的输出</li>
<li>具备图形GUI界面</li>
</ol>
<a id="more"></a>
<h2 id="u5F00_u59CB"><a href="#u5F00_u59CB" class="headerlink" title="开始"></a>开始</h2><p>在介绍主要流程之前，先说一些完成实验之后的体会，或者说学到的东西吧。首先是在调试时，启动服务器后需要绑定IP地址和端口，这里IP地址只能是<code>127.0.0.1</code>或者<code>0.0.0.0</code>，据说也可以是你的网卡IP地址，但是我没有测试成功；而端口号必须大于<strong>1024</strong>，否则虽然绑定地址时虽然不会发生错误，但是也无法监听客户端请求。</p>
<p>其次，为了及时响应GUI界面的操作，需要使用异步I/O模式，因此需要将Socket操作设置为非阻塞模式，这时在Socket上的各种操作就需要自己去干涉了；虽然这看起来更复杂，但是也可以更好的认识Socket。</p>
<p>第三，要注意线程之间的通信，特别是传递引用类型时，更需要注意局部变量的陷阱。因为我们是要在另一个线程中访问数据，所以需要保证在另一个线程结束之前，传递的数据是有效的，通常可以采用静态变量/全局变量、动态分配内存等方式来实现，但是在这里，由于需要确保线程函数是线程安全的，也就是可重入的，因此不宜采用静态变量方式，所以将需要传递的数据保存在堆中，只是最后需要记得手动释放这块内存。</p>
<p>最后说一句，无论什么时候，要记得及时释放资源，如果你的代码中有未释放的资源，特别是内核资源，请不要急着调试或运行程序，虽然一般调试器都会在程序运行结束之后释放其占用的资源，但是万一出现某些内核对象没有释放的情况，也许下一次再运行你的程序时会出现本不该出现的错误。当然，重启是一个办法。</p>
<h3 id="u5F00_u53D1_u73AF_u5883"><a href="#u5F00_u53D1_u73AF_u5883" class="headerlink" title="开发环境"></a>开发环境</h3><p>由于要求有图形化界面，所以使用 <a href="http://www.qt.io/" target="_blank" rel="external">Qt</a> 进行快速开发，其中核心类是完全用<strong><em>Windows API</em></strong>实现，通过预留的接口与Qt界面进行交互。</p>
<blockquote>
<p>由于安装的Qt版本是<em>MSVC2013</em> 版的，所以安装完成后Qt无法自动设置调试器，因此无法在Qt中进行调试（如果希望在Qt中调试，需要单独下载<a href="https://msdn.microsoft.com/zh-cn/windows/hardware/hh852365" target="_blank" rel="external">WinDbg工具</a>，并在Qt中进行配置），前期还好，通过在关键处打印的方式，即使不用调试器也能找到错误并修正，但是到后来，需要调试多线程以及指针等，仅仅凭借简单的打印方式效率太低了，所以又去Qt官网下载了<a href="http://download.qt.io/official_releases/vsaddin/" target="_blank" rel="external">Qt-VS-Addin</a>，这是一个适用于<em>Visual Studio</em> 的Qt插件，安装之后，就可以在VS中编写和调试Qt项目了，而相比Qt，我更喜欢用VS调试。</p>
</blockquote>
<h2 id="Socket_u6838_u5FC3_u7C7B_u5206_u6790"><a href="#Socket_u6838_u5FC3_u7C7B_u5206_u6790" class="headerlink" title="Socket核心类分析"></a>Socket核心类分析</h2><p>在编写Socket核心类之前，首先需要想好要预留那些接口与GUI进行交互，毕竟虽然实际上这个核心类和GUI类是在同一个项目工程中，但是为了让核心类的可移植性更高，或者说将UI和底层操作隔离开来，我们应该设计好Socket类的通信方式，这样，在完成Socket类时可以不用考虑UI操作，而在UI设计过程中也无需深入探究Socket实现方式。</p>
<blockquote>
<p>在这里，根据实验的要求，图形化界面应该提供启动、停止服务的操作，而且还要能设置一些基本参数，因此在<em>Socket</em> 类中，应该提供一个启动和停止监听的接口，而为了简单考虑，我们将在UI界面设定的一些基本配置参数通过启动接口传递到<em>Socket</em> 类中，而不是要求在初始化<em>Socket</em> 类时传入，这样在GUI类中就可以将<em>Socket</em> 类的初始化和启动操作放到不同的方法中，而且通过重新调用启动方法就可以实现监听新的端口，而不用去构造一个新的<em>Socket</em> 类。此外，为了让UI界面知道当前监听的状态（是否正在监听端口），还需要在<em>Socket</em> 类中提供一个只读属性方法。</p>
</blockquote>
<p>这里，Socket核心类被命名为<strong><em>SocketUnits</em></strong>。</p>
<h3 id="u516C_u5F00_u65B9_u6CD5"><a href="#u516C_u5F00_u65B9_u6CD5" class="headerlink" title="公开方法"></a>公开方法</h3><p>Socket核心类定义的公开方法如下：</p>
<pre><code class="c++">bool Start(const string &amp;ip, unsigned short port, const wstring &amp;baseDir);
void Stop();
bool GetIsListening()
{
    DWORD extCode = 0;
    GetExitCodeThread(_lastThread, &amp;extCode);
    return extCode == STILL_ACTIVE;
}
</code></pre>
<p>其中<code>GetIsListening</code>用于获取监听状态，此处作为内联函数存在。_lastThread保存了监听线程的句柄，如果还没有创建监听线程，则<code>_lastThread = INVALID_HANDLE_VALUE</code>。</p>
<h3 id="u56DE_u8C03_u63A5_u53E3"><a href="#u56DE_u8C03_u63A5_u53E3" class="headerlink" title="回调接口"></a>回调接口</h3><p>上面是外部与Socket类通信的主要接口，由外部方法调用，设置Socket的属性，但却无法获取Socket类的当前状态，因为采用了异步Socket实现，所以如果还是像上面一样单纯的提供接口，让调用者使用轮询的方式查询Socket状态，那么不仅让调用类的实现难度增加，同时也会无端的消耗CPU时间片。因此这里采用了一种类似Windows消息事件的回调机制，利用纯虚类定义回调接口，当Socket类满足某一状态时会自动调用回调接口中定义的对应方法。</p>
<blockquote>
<p>回调接口中需要哪些方法，这个我们也要根据实际情况来决定，在这里，我们暂时只需将一些基本状态传递给UI即可。首先是服务的启动和关闭信息，虽然提供了公开的启动和关闭方法，但是由于在该方法内部是需要创建新的线程来进行<em>Socket</em> 的监听工作，因此，当启动方法（<em>SocketUnits::Start</em> 函数）返回时，并不意味着监听<em>Socket</em> 创建成功，所以我们需要在监听线程中来告诉调用者服务是否启动；同理，关闭时也需要在监听线程中实现。其次，对于每一个来自客户端的连接<em>Socket</em>，我们也需要向外通知这个连接的状态，包括建立连接、关闭连接，此外为了方便查看连接信息，将与客户端的具体请求和响应消息也发送出去。最后，还需要一个出现错误时的回调接口，方便调用者在出错时及时作出反应。</p>
</blockquote>
<p>回调接口<strong><em>ISocketEvent</em></strong> 定义如下：</p>
<pre><code class="c++">class ISocketEvent
{
public:
    virtual void OnListenSocketChanged(const char *ip, unsigned short port, 
        const wchar_t *dir) = 0;
    /* stopCode：结束状态码 */
    virtual void OnServiceStopped(int stopCode) = 0;
    virtual void OnSocketConnected(const char *ip) = 0;
    virtual void OnSocketFinished(const char *ip) = 0;
    /* isSend：指示是发送还是接收数据。 info：发送或接收的数据 */
    virtual void OnNewLogs(const char *ip, const char *info, bool isSend) = 0;
    /* eor：错误代码。 msg：错误说明 */
    virtual void OnError(int eor, const char *msg) = 0;
};
</code></pre>
<p>这里的形参<code>ip</code>是字符串形式的点分十进制IP地址。<code>OnListenSocketChanged</code>函数的形参含义依次为IP地址、监听端口号、主目录。</p>
<p><strong><em>ISocketEvent</em></strong> 类中各方法解释：</p>
<blockquote>
<ul>
<li><em>OnListenSocketChanged</em>：当监听Socket配置发生变化时（包括启动）调用</li>
<li><em>OnServiceStopped</em>：当监听Socket关闭时调用</li>
<li><em>OnSocketConnected</em>：当有来自客户端的Socket请求时调用</li>
<li><em>OnSocketFinished</em>：当与客户端的Socket连接关闭时调用</li>
<li><em>OnNewLogs</em>：当与客户端进行数据传递（发送或者接收）时调用</li>
<li><em>OnError</em>：当Socket连接出现错误时调用</li>
</ul>
</blockquote>
<h3 id="u7EBF_u7A0B_u51FD_u6570_u5B9A_u4E49"><a href="#u7EBF_u7A0B_u51FD_u6570_u5B9A_u4E49" class="headerlink" title="线程函数定义"></a>线程函数定义</h3><p>前面的都是为实现Socket类与外部通信和发送数据所定义的方法，而实现一个多线程WEB服务器最核心的部分则是此处要说的，线程以及Socket的处理。我们需要将监听Socket和响应Socket都放在单独的线程中进行处理，因此需要定义两个线程函数，分别用于处理监听操作和响应操作。在C++中，如果一个线程函数是类的成员，那么它必须被定义为<code>static</code>的，这里涉及到一个<code>this</code>指针的问题。</p>
<p>因此，按照线程函数的格式定义如下两个函数：</p>
<pre><code class="c++">static DWORD WINAPI ListenThread(LPVOID lpParameter);
static DWORD WINAPI WorkerThread(LPVOID lpParameter);
</code></pre>
<p>形参<code>lpParameter</code>是一个<code>void *</code>型的指针，它的值在创建线程时通过线程创建方法传入。返回值会作为线程的退出值，可以由方法<code>bool GetExitCodeThread(HANDLE, LPDWORD)</code>获取。</p>
<p>此外，还定义了两个静态方法，以便在线程函数中调用，完成相应的功能：</p>
<pre><code class="c++">static int GetType(const wstring &amp;fileName, string &amp;type);
static bool SignalSend(SOCKET s, const char *buf, size_t len, bool *stop);
</code></pre>
<p><code>GetType</code>函数用于获取指定文件（文件名由<code>fileName</code>指示）的类型，在这里，仅仅对一些WEB中常用的文件进行判断，返回值指示文件是二进制格式还是文本格式。<code>SignalSend</code>函数则是对Socket对象非阻塞模式下的<code>send</code>方法进行了一个封装。</p>
<h3 id="u7C7B_u578B_u5B9A_u4E49"><a href="#u7C7B_u578B_u5B9A_u4E49" class="headerlink" title="类型定义"></a>类型定义</h3><p>这里简要说明一下Socket类中用到的一些自定义数据格式。</p>
<p>首先定义了一个<code>HANDLE</code>列表的标识符：</p>
<pre><code class="c++">typedef list&lt;HANDLE&gt; ThreadList;
</code></pre>
<p>之后在<strong><em>SocketUnits</em></strong> 类中定义了两个结构体类型，用于向线程函数传递参数：</p>
<pre><code class="c++">/* 监听线程函数参数类型定义 */
struct ListenParameter
{
    HANDLE lastThread;
    ISocketEvent *event;
    unsigned short port;
    string ip;
    wstring baseDir;
    bool *stop;
    bool *notifyStop;
};

/* 响应线程函数参数类型定义 */
struct ThreadParameter
{
    sockaddr_in remoteAddr;
    SOCKET remoteSocket;
    ISocketEvent *event;
    wstring baseDir;
    bool *stop;
};
</code></pre>
<h2 id="Socket_u6838_u5FC3_u7C7B_u5B9E_u73B0"><a href="#Socket_u6838_u5FC3_u7C7B_u5B9E_u73B0" class="headerlink" title="Socket核心类实现"></a>Socket核心类实现</h2><p>完成Socket类的定义之后，可以开始实现每个方法的功能了。</p>
<h3 id="u521D_u59CB_u5316_u548C_u9000_u51FA"><a href="#u521D_u59CB_u5316_u548C_u9000_u51FA" class="headerlink" title="初始化和退出"></a>初始化和退出</h3><p>首先当然是Socket类的构造函数了，这里我们定义一个构造函数，带一个<strong>ISocketEvent * </strong>类型的形参，这里不对实际传入的值做任何检查，也就是要求调用者必须传入一个在Socket类生存期间保持有效的值，这个值被用来初始化Socket类，从而实现回调。</p>
<p>初始化主要代码如下：</p>
<pre><code class="c++">SocketUnits::SocketUnits(ISocketEvent *event)
{
    WSADATA wsd;
    _stop = false;
    _lastThread = INVALID_HANDLE_VALUE;
    _lsParam.event = event;
    _lsParam.stop = &amp;_stop;
    _lsParam.notifyStop = &amp;_notifyStop;

    _nRC = WSAStartup(MAKEWORD(2, 2), &amp;wsd);
    if (_nRC)
    {
        event-&gt;OnError(-1, &quot;初始化WinSock时出错！&quot;);
        return;
    }
    if (wsd.wVersion != MAKEWORD(2, 2))
    {
        _nRC = -1;
        WSACleanup();
        event-&gt;OnError(-2, &quot;不受支持的WinSock版本。&quot;);
        return;
    }
}
</code></pre>
<p>其中<code>_lsParam</code>是一个<code>SocketUnit::ListenParameter</code>类型的变量，此处对它进行初始化，当创建监听线程时，它被作为一个参数传入到线程中。</p>
<p>接下来就是调用<code>WSAStartup</code>函数完成Windows Socket的一系列初始化工作，这个函数是应用程序应该第一个调用的 Winsock API 函数。</p>
<p>而在Socket类被析构时，则应该完成一些清理工作。</p>
<pre><code class="c++">SocketUnits::~SocketUnits()
{
    Stop();
    if (!_nRC)
        WSACleanup();
}
</code></pre>
<p><code>WSACleanup</code>就是用来清除WinSock的函数。</p>
<h3 id="u5F00_u59CB_u4E0E_u7ED3_u675F_u670D_u52A1"><a href="#u5F00_u59CB_u4E0E_u7ED3_u675F_u670D_u52A1" class="headerlink" title="开始与结束服务"></a>开始与结束服务</h3><p>虽然真正的监听工作是在另外一个线程中完成的，但是对于开始方法来说，我们也必须返回一个状态表示方法是否调用成功，而不能让调用者仅仅依赖<code>OnListenSocketChanged</code>方法回调。</p>
<p>在<code>Start</code>方法中，做了一些简单的判断，来确定其返回状态值。</p>
<pre><code class="c++">bool SocketUnits::Start(const string &amp;ip, unsigned short port, const wstring &amp;baseDir)
{
    if (_stop || (_lsParam.ip.compare(ip) == 0 &amp;&amp; _lsParam.port == port &amp;&amp;
                  _lsParam.baseDir.compare(baseDir) == 0))
        return false;
    _notifyStop = false;
    _stop = true;

    _lsParam.ip = ip;
    _lsParam.baseDir = baseDir;
    _lsParam.port = port;
    _lsParam.lastThread = _lastThread;
    if (_lastThread != INVALID_HANDLE_VALUE)
        CloseHandle(_lastThread);

    _lastThread = CreateThread(NULL, 0, (LPTHREAD_START_ROUTINE)(SocketUnits::ListenThread),
        (LPVOID)&amp;_lsParam, 0, NULL);
    if (_lastThread == INVALID_HANDLE_VALUE)
    {
        _lsParam.event-&gt;OnError(1, &quot;启动监听失败！&quot;);
    }
    return true;
}
</code></pre>
<p>注意此处当创建线程失败的时候，并没有返回<code>false</code>，是因为线程创建失败时，则原来运行的监听线程（如果有）也会停止，那么调用者此时会接收到<code>OnServiceStopped</code>回调，此时，调用者应该响应这个回调函数，而不是依赖<code>Start</code>方法的返回值。</p>
<p>由于采用非阻塞I/O，所以要结束整个服务，只需要做一个类似广播的操作即可。在这里，我们只需要将<code>_stop</code>置为<code>true</code>且<code>_notifyStop</code>也置为<code>true</code>即可，此时所有的线程（包括监听线程和响应线程）均会执行线程结束部分代码，并正常结束线程，回收线程所占用资源。</p>
<pre><code class="c++">void SocketUnits::Stop()
{
    _notifyStop = true;
    _stop = true;
    if (_lastThread == INVALID_HANDLE_VALUE)
        return;
    CloseHandle(_lastThread);
    _lastThread = INVALID_HANDLE_VALUE;
}
</code></pre>
<h3 id="u7EBF_u7A0B_u51FD_u6570_u5B9E_u73B0"><a href="#u7EBF_u7A0B_u51FD_u6570_u5B9E_u73B0" class="headerlink" title="线程函数实现"></a>线程函数实现</h3><p>这里就是整个Socket类的核心实现了，主要需要注意的是线程之间传递数据时一定要保持数据在线程生存期间的有效性，否则可能导致不可预见的逻辑错误。此外就是采用异步I/O时需要进行的处理和优化。</p>
<p>首先是监听线程函数。</p>
<pre><code class="c++">DWORD WINAPI SocketUnits::ListenThread(LPVOID lpParameter)
{
    ListenParameter *lp = (ListenParameter*)lpParameter;
    HANDLE handle = lp-&gt;lastThread;
    ISocketEvent *event = lp-&gt;event;
    bool *stop = lp-&gt;stop;
    if (handle != INVALID_HANDLE_VALUE)
        WaitForSingleObject(handle, INFINITE);
    *stop = false;

    // ......
}
</code></pre>
<p>在函数的开头，首先从传入参数中取出各个值，其中<code>handle</code>保存上一个监听线程的句柄，在这里线程会首先判断<code>handle</code>的有效性，如果有效，说明程序曾经创建过一个监听线程，那么此处会调用<code>WaitForSingleObject</code>方法来等待上一个监听线程结束，然后才会开始执行。</p>
<pre><code class="c++">DWORD WINAPI SocketUnits::ListenThread(LPVOID lpParameter)
{
    // ......

    SOCKET server = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
    if (server == INVALID_SOCKET)
    {
        event-&gt;OnError(2, &quot;无法创建Socket连接！&quot;);
        event-&gt;OnServiceStopped(WSAGetLastError());
        return 2;
    }
    sockaddr_in addr;
    addr.sin_family = AF_INET;
    addr.sin_addr.S_un.S_addr = inet_addr(lp-&gt;ip.c_str());
    addr.sin_port = htons(lp-&gt;port);
    if (bind(server, (LPSOCKADDR)&amp;addr, sizeof(addr)) == SOCKET_ERROR)
    {
        event-&gt;OnError(3, &quot;无法绑定服务器地址！&quot;);
        event-&gt;OnServiceStopped(WSAGetLastError());
        return 3;
    }
    if (listen(server, SOMAXCONN) == SOCKET_ERROR)
    {
        event-&gt;OnError(4, &quot;无法设置Socket为等待连接状态！&quot;);
        event-&gt;OnServiceStopped(WSAGetLastError());
        return 4;
    }
    u_long mode = 1;
    ioctlsocket(server, FIONBIO, &amp;mode);
    event-&gt;OnListenSocketChanged(lp-&gt;ip.c_str(), lp-&gt;port, lp-&gt;baseDir.c_str());

    // ......
}
</code></pre>
<p>接下来就是创建Socket了，这个Socket就是用来监听指定端口的。这里通过调用<code>ioctlsocket</code>方法将此Socket设置为非阻塞模式。</p>
<pre><code class="c++">DWORD WINAPI SocketUnits::ListenThread(LPVOID lpParameter)
{
    // ......

    ThreadList workerTrds;
    while (true)
    {
        ThreadParameter *tp = new ThreadParameter();
        int nAddrLen = sizeof(sockaddr_in);
        while ((int)(tp-&gt;remoteSocket = accept(server, (LPSOCKADDR)&amp;(tp-&gt;remoteAddr),
            &amp;nAddrLen)) &lt; 0)
        {
            if (*stop)
                goto finish;
            Sleep(400);
        }

        tp-&gt;baseDir = lp-&gt;baseDir;
        tp-&gt;event = lp-&gt;event;
        tp-&gt;stop = lp-&gt;stop;
        HANDLE thandle = CreateThread(NULL, 0,
            (LPTHREAD_START_ROUTINE)(SocketUnits::WorkerThread),
            tp, 0, NULL);
        if (thandle == INVALID_HANDLE_VALUE)
        {
            closesocket(tp-&gt;remoteSocket);
            delete tp;
            event-&gt;OnError(5, &quot;无法创建与客户端通信的线程！&quot;);
        }
        else
        {
            workerTrds.push_back(thandle);
        }
    }

    // ......
}
</code></pre>
<p>这里开始正式监听，如果有来自客户端的请求，则会创建一个新的线程，将<code>tp</code>作为参数传递进去，<code>tp</code>中保存了这个请求的所有信息。由于此处<code>tp</code>是一个局部变量，因此我们需要在堆中分配它的内存，以免当本次循环结束时其内容所在内存区域被回收。</p>
<pre><code class="c++">DWORD WINAPI SocketUnits::ListenThread(LPVOID lpParameter)
{
    // ......

finish:
    closesocket(server);
    ThreadList::iterator itor = workerTrds.begin();
    for (; itor != workerTrds.end(); ++itor)
    {
        WaitForSingleObject((HANDLE)*itor, INFINITE);
        CloseHandle((HANDLE)*itor);
    }
    Sleep(800);
    if (*(lp-&gt;notifyStop))
    {
        *stop = false;
        event-&gt;OnServiceStopped(0);
    }
    return 0;
}
</code></pre>
<p>这里就是结束代码了，当这个线程结束时，便执行这一部分代码，关闭Socket、释放资源并通知调用者。</p>
<p>然后便是响应函数了。</p>
<pre><code class="c++">DWORD WINAPI SocketUnits::WorkerThread(LPVOID lpParameter)
{
    ThreadParameter *tp = (ThreadParameter*)lpParameter;
    SOCKET remoteSocket = tp-&gt;remoteSocket;
    sockaddr_in remoteAddr = tp-&gt;remoteAddr;
    ISocketEvent *event = tp-&gt;event;
    bool *stop = tp-&gt;stop;
    char addr[16];
    strncpy(addr, inet_ntoa(remoteAddr.sin_addr), 15);
    addr[15] = 0;
    event-&gt;OnSocketConnected(addr);

    // ......
}
</code></pre>
<p>首先同样是取出参数中的值。<code>remoteSocket</code>保存了与客户端连接的Socket对象，<code>remoteAddr</code>保存了客户端IP地址。</p>
<pre><code class="c++">DWORD WINAPI SocketUnits::WorkerThread(LPVOID lpParameter)
{
    // ......

    char buffer[1024] = { 0 };
    int byteRecv = 0;
    stringstream ss;
    wstring filepath;
    string filetype;
    string header = &quot;HTTP/1.1 200 OK\r\nContent-Type: &quot;;
    while (true)    // 接收数据
    {
        byteRecv = recv(remoteSocket, buffer, 1023, 0);
        if (byteRecv == 0)
            goto finish;
        else if (byteRecv &lt; 0)
        {
            if (*stop)
                goto finish;

            Sleep(10);
            int err = WSAGetLastError();
            //if (errno == EINTR || errno == EAGAIN || errno == EWOULDBLOCK)
            if (err == WSAEWOULDBLOCK)
                continue;
            else
            {
                event-&gt;OnError(WSAGetLastError(), &quot;无法从套接字接收数据。&quot;);
                goto finish;
            }
        }
        else
            break;
    }
    buffer[byteRecv] = 0;
    event-&gt;OnNewLogs(addr, buffer, false);

    // ......
}
</code></pre>
<p>接下来开始从客户端接收数据。注意异步调用需要进行的判断，这里仅处理了一些简单错误，实现基本的接收数据功能。同时，在循环之前定义了一些变量，这是因为在循环中含有<code>goto</code>语句，而C++不允许在<code>goto</code>语句后面进行非基本类型变量的初始化操作，因此将这些变量（<code>string</code>类型）的初始化移到循环体之前。</p>
<pre><code class="c++">DWORD WINAPI SocketUnits::WorkerThread(LPVOID lpParameter)
{
    // ......

    ss &lt;&lt; buffer;
    char tbuff[128];
    while (ss.getline(tbuff, sizeof(tbuff)))
    {
        char *p = strstr(tbuff, &quot;GET&quot;);
        if (p)
        {
            strrchr(p, &#39; &#39;)[0] = 0;
            string fp = strchr(p, &#39;/&#39;);
            int len = fp.size();
            if (len &gt; 0 &amp;&amp; fp.c_str()[len - 1] == &#39;/&#39;)
                fp += &quot;index.html&quot;;
            wstring ws(fp.size(), &#39; &#39;);
            copy(fp.begin(), fp.end(), ws.begin());
            filepath = tp-&gt;baseDir + ws;
            string ft;
            int tp = GetType(ws, ft);
            if (tp == 0)
                filepath += L&quot;/index.html&quot;;
            break;
        }
    }
    if (filepath.size() == 0)
    {
        const char *notSupport = &quot;HTTP/1.1 501 Not Implemented\r\n\r\n&quot;;
        SignalSend(remoteSocket, notSupport, strlen(notSupport), stop);
        event-&gt;OnNewLogs(addr, notSupport, true);
        goto finish;
    }

    // ......
}
</code></pre>
<p>在收到客户端发送的请求数据之后，就开始解析。此处仅仅检查<code>GET</code>方法，对于其他的请求方法，服务器会直接返回<code>501 Not Implemented</code>响应报文，表示不支持的方法。对于<code>GET</code>方法，这里会检查其请求的URL，并将其映射到本地文件路径，保存在<code>filepath</code>中。</p>
<pre><code class="c++">DWORD WINAPI SocketUnits::WorkerThread(LPVOID lpParameter)
{
    // ......

    int type = GetType(filepath, filetype);
    header.append(filetype);
    header.append(&quot;\r\nConnection: close\r\n\r\n&quot;);
    if (type &gt; 0 &amp;&amp; type &lt; 6)
    {
        ifstream in(filepath.c_str());
        if (!in)
            goto fileNotExist;

        if (!SignalSend(remoteSocket, header.c_str(), header.size(), stop))
            goto finish;
        event-&gt;OnNewLogs(addr, header.c_str(), true);
        string data;
        while (getline(in, data))
        {
            if (data.size() == 0) continue;
            if (!SignalSend(remoteSocket, data.c_str(), data.size(), stop))
                goto finish;
        }
    }
    else
    {
        ifstream in(filepath.c_str(), ios::binary);
        if (!in)
            goto fileNotExist;

        if (!SignalSend(remoteSocket, header.c_str(), header.size(), stop))
            goto finish;
        event-&gt;OnNewLogs(addr, header.c_str(), true);
        while (!in.eof())
        {
            char str[1024];
            in.read(str, 1024);
            if (!SignalSend(remoteSocket, str, sizeof(char) * in.gcount(), stop))
                goto finish;
        }
    }
    goto finish;

fileNotExist:
    const char *resp = &quot;HTTP/1.1 404 Not Found\r\n\r\n&quot;;
    SignalSend(remoteSocket, resp, strlen(resp), stop);
    event-&gt;OnNewLogs(addr, resp, true);

    // ......
}
</code></pre>
<p>接下来就是响应客户端请求，发送指定的文件给客户端了。这里通过<code>GetType</code>方法简单的判断请求文件的类型，然后进行读取并发送给客户端，这里需要注意文本文件和二进制文件的读取方法是不同的，我们需要根据文件的格式来确定读取方法。发送操作通过<code>SignalSend</code>来完成，此方法会返回一个布尔值，表示操作是否成功完成。如果请求的文件不存在，则会发送响应报文<code>404 Not Found</code>给客户端，表示请求资源不存在。</p>
<pre><code class="c++">DWORD WINAPI SocketUnits::WorkerThread(LPVOID lpParameter)
{
    // ......

finish:
    closesocket(remoteSocket);
    event-&gt;OnSocketFinished(addr);
    delete tp;
    Sleep(800);
    return 0;
}
</code></pre>
<p>结束代码，关闭Socket连接，并通知调用者。此处需要注意，要释放<code>tp</code>所占内存，因为这个<code>tp</code>是我们在<code>ListenThread</code>方法中通过<code>new</code>创建的，所以要在不再使用的时候通过<code>delete</code>释放它。</p>
<p>最后，写一下在编写这两个线程函数时学到的东西。</p>
<blockquote>
<p>在对Socket进行非阻塞方法调用时，不仅要对某些调用错误进行处理，同时还需要注意调用频率，因为一般我们都是在一个死循环中执行这些方法的，所以如果不进行一些处理，肯定会严重浪费CPU时间片，甚至占用全部CPU时间。我在第一次进行调试的时候，便是因为没有进行线程调度处理，结果程序运行几秒钟之后，整个电脑便彻底无响应了，连鼠标都无法移动，CPU时间被这个死循环耗尽了，最后被迫强制关机，所以之后几次调试我都是开着任务管理器然后再进行调试的，这个也算是Windows系统程序调度机制的优点和缺点了，虽然这里跑的是一个线程，但是这个线程是可以在任意一个CPU核心上被调度。说到这里，其实我也很好奇当时明明这个程序都无法继续运行了，为什么Windows还不提示强行关闭？还有，Windows居然不给一些核心程序（例如任务管理器、CMD等）预留一些时间片……</p>
</blockquote>
<p><strong> 因此，我们需要主动请求Windows对我们的线程进行调度。一般情况下是通过使用网上所说的<code>select</code>模式，而这里，我则是简单的通过调用<code>Sleep</code>函数来让Windows将线程休眠指定时间，从而让出CPU。 </strong></p>
<h3 id="u4E24_u4E2A_u5E2E_u52A9_u65B9_u6CD5"><a href="#u4E24_u4E2A_u5E2E_u52A9_u65B9_u6CD5" class="headerlink" title="两个帮助方法"></a>两个帮助方法</h3><p>最后还有两个在线程函数中被调用的帮助方法：<code>GetType</code>方法和<code>SignalSend</code>方法。</p>
<p>先介绍<em>GetType</em>方法，此方法主要就是判断指定文件的类型和格式，通过文件扩展名进行判断，比如在常用WEB文件中，<code>.html</code>、<code>.css</code>、<code>.js</code>等文件就是文本格式文件，而像<code>.jpg</code>、<code>.png</code>、<code>.gif</code>等文件则是二进制文件。此方法同时还返回一个<code>Content-Type</code>字符串，虽然这个属性值也可以从HTTP请求头中获取。</p>
<p><em>GetType</em>方法主要代码如下：</p>
<pre><code class="c++">int SocketUnits::GetType(const wstring &amp;fileName, string &amp;type)
{
    size_t pos = fileName.rfind(&#39;.&#39;);
    if (pos &lt; 0 || pos &gt;= fileName.size() - 1)
    {
        type = &quot;file/file&quot;;
        return 0;
    }
    wstring extName = fileName.substr(pos + 1);
    if (extName.compare(L&quot;html&quot;) == 0)
    {
        type = &quot;text/html&quot;;
        return 1;
    }
    if (extName.compare(L&quot;css&quot;) == 0)
    {
        type = &quot;text/css&quot;;
        return 2;
    }
    if (extName.compare(L&quot;js&quot;) == 0)
    {
        type = &quot;application/javascript&quot;;
        return 3;
    }
    if (extName.compare(L&quot;json&quot;) == 0)
    {
        type = &quot;application/json&quot;;
        return 4;
    }
    if (extName.compare(L&quot;txt&quot;) == 0)
    {
        type = &quot;plain/text&quot;;
        return 5;
    }

    string str(extName.size(), &#39; &#39;);
    copy(extName.begin(), extName.end(), str.begin());
    if (extName.compare(L&quot;jpg&quot;) == 0 || extName.compare(L&quot;gif&quot;) == 0 ||
        extName.compare(L&quot;png&quot;) == 0 || extName.compare(L&quot;jpeg&quot;) == 0)
    {
        type.assign(&quot;image/&quot;);
        type.append(str);
        return 6;
    }
    if (extName.compare(L&quot;mp3&quot;) == 0 || extName.compare(L&quot;mp4&quot;) == 0)
    {
        type.assign(&quot;audio/&quot;);
        type.append(str);
        return 7;
    }
    type.assign(&quot;file/&quot;);
    type.append(str);
    return -1;
}
</code></pre>
<p>至于<em>SignalSend</em>方法，则是对非阻塞<code>send</code>方法的封装，实现发送指定长度字符串的功能。当发送期间出现错误、或者接收到结束线程的信号时，此方法会返回<code>false</code>值，否则返回<code>true</code>。</p>
<p><em>SignalSend</em>方法主要代码如下：</p>
<pre><code class="c++">bool SocketUnits::SignalSend(SOCKET s, const char *buf, size_t len, bool *stop)
{
    size_t total = len;
    while (true)
    {
        int slen = send(s, buf, (int)total, 0);
        if (slen &lt; 0)
        {
            if (*stop)
                return false;

            Sleep(10);
            int err = WSAGetLastError();
            //if (errno == EINTR || errno == EAGAIN || errno == EWOULDBLOCK)
            if (err == WSAEWOULDBLOCK)
                continue;
            else
                return false;
        }
        else if (slen == 0)
            return false;

        if (slen == total)
            break;
        buf += slen;
        total -= len;
    }

    return true;
}
</code></pre>
<p>至此，Socket核心类就已经完成了，可以实现基本的WEB服务功能。</p>
<h2 id="UI_u754C_u9762"><a href="#UI_u754C_u9762" class="headerlink" title="UI界面"></a>UI界面</h2><p>在完成Socket类之后，就可以开始设计UI界面了，这里使用Qt创建界面，具体内容就和Socket无关了，所以此处也不做详细分析了。</p>
<p>唯一要注意的就是，Qt的UI类是不允许重入的，因此我们只能在主线程、或者说UI线程中去访问，因此要注意回调接口类的实现，保证接口中的方法是在主线程中被调用的。</p>
<h2 id="u7ED3_u675F_u8BED"><a href="#u7ED3_u675F_u8BED" class="headerlink" title="结束语"></a>结束语</h2><p>经过几天的间断工作，终于完成了这个多线程WEB服务器的实现，虽然功能不甚完整，但是好歹是基本的工作还是能完成，一些简单的网页也可以通过浏览器进行打开（从浏览器中输入监听地址）。</p>
<p>这期间一边学习Windows Sockets，一边又复习了操作系统中的线程相关知识，到结束时，也算是获益匪浅了。</p>
<h2 id="u53C2_u8003"><a href="#u53C2_u8003" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="http://www.oschina.net/code/snippet_816473_35413" title="使用windows socket写的多线程web http服务器" target="_blank" rel="external">http://www.oschina.net/code/snippet_816473_35413</a></li>
<li><a href="http://www.cnblogs.com/yelaiju/archive/2010/09/29/1838065.html" title="HTTP 请求返回代码含义 " target="_blank" rel="external">http://www.cnblogs.com/yelaiju/archive/2010/09/29/1838065.html</a></li>
<li><a href="http://blog.csdn.net/shupan001/article/details/7045430" title="http请求头 " target="_blank" rel="external">http://blog.csdn.net/shupan001/article/details/7045430</a></li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<p>平时如果一个项目需要网络连接，一般都是直接用如<code>C#</code>、<code>Java</code>等高级语言直接调用相关的函数去实现功能，甚至从未关注过在底层这些函数是怎么运作的；而截至不久前，也只是用<code>C#</code>中的Socket相关类做过一点有关长连接的事情。</p>
<p>而最近，恰好由于网络课程实验要求，使用<code>Windows Sockets API</code> + <code>C/C++</code>来实现一个简单的多线程Web服务器，于是开始一边摸索，一边实现功能。在这个实验中，不仅仅是简单的<code>Windows Socket</code>函数调用，其实主要的工作还在于多线程（包括GUI线程）之间的通信，对于HTTP请求，也只是简单的实现了<code>GET</code>方法。</p>
<h2 id="u5B9E_u9A8C_u8981_u6C42"><a href="#u5B9E_u9A8C_u8981_u6C42" class="headerlink" title="实验要求"></a>实验要求</h2><ol>
<li>可配置IP地址、监听端口和主目录</li>
<li>能够在监听端口上进行监听</li>
<li>支持服务的启动</li>
<li>支持服务的关闭</li>
<li>能够响应客户端的请求，并定位相应的html文件</li>
<li>对每个请求能够创建单独的响应线程</li>
<li>能够发送可被客户端解析的响应报文</li>
<li>对于错误的请求能够定位错误的原因并给出相应的响应</li>
<li>支持多种类型文件的输出</li>
<li>具备图形GUI界面</li>
</ol>]]>
    
    </summary>
    
      <category term="Windows Sockets" scheme="http://3meng.github.io/tags/Windows-Sockets/"/>
    
      <category term="Socket" scheme="http://3meng.github.io/categories/Socket/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Hello World]]></title>
    <link href="http://3meng.github.io/2015/03/21/hello-world/"/>
    <id>http://3meng.github.io/2015/03/21/hello-world/</id>
    <published>2015-03-20T16:52:19.000Z</published>
    <updated>2016-02-22T15:04:26.000Z</updated>
    <content type="html"><![CDATA[<p>第一篇博文，不知道该写个什么名字最好，干脆就保持默认的标题<code>Hello World</code>吧，这也算是学计算机软件的一个启蒙标志吧。<br><a id="more"></a></p>
<h2 id="u7B80_u8981_u8BF4_u660E"><a href="#u7B80_u8981_u8BF4_u660E" class="headerlink" title="简要说明"></a>简要说明</h2><h3 id="u8D77_u56E0"><a href="#u8D77_u56E0" class="headerlink" title="起因"></a>起因</h3><p>其实很早就有了创建自己的博客的想法，只是一来没有找到托管的地方（那些提供博客服务的站点一般都没有太多的自定义权限，所以直接不考虑了），二来也是这个想法只是在偶然间会闪现出来，然后一拖延就没了= =，所以一直等到最近才下定决心。</p>
<p>其实平时是经常与博文打交道的，一般都是搜索一些软件开发的问题，而通常获取答案的位置都是在别人的博文之中，这也是搭建自己的博客的一个起因吧：记录那些平时开发过程中的问题和解决方案，以及一些想法等，还有偶尔的随笔也可以。</p>
<p>而这次下定决心也是因为如此，拿一个<code>Windows Runtime</code>开发中的细节问题去Google上搜索了半天，都是千篇一律的答案，而且是我最不想使用的解决方案，最后无奈之下只好又找上了<code>MSDN</code>文档，在窗口页面终于找到了看起来应该合适的属性，虽然看起来“权限”比较高，所以就先测试了一下（有些真的需要自己测试，<code>Windows Runtime</code>方面的还好，以前的<code>Windows Phone Silverlight</code>开发，一般像我找到的属性类型都是<code>[安全关键]</code>的，看起来属性介绍很正常，但是真正运行起来之后，就会丢出异常，因为无权访问……）。这次测试当然是成功了，而这也从一方面说明微软在Windows 8.1时代确实就已经构建了初步的通用平台了，虽然API的描述很多都是用电脑操作介绍的，但是在手机上也能跑起来，所以，希望对Windows 8.1进一步完善的Windows 10能带给我们更大的惊喜吧。题外话了，经过这次之后，我终于决定要开始搭建一个自己的博客了，这次在不能拖延了，一方面记录自己遇到的问题，以后也可做个参考比较，另一方面也可以给遇到相同问题的人一些提示，何乐而不为？</p>
<h3 id="u8FC7_u7A0B"><a href="#u8FC7_u7A0B" class="headerlink" title="过程"></a>过程</h3><p>一开始想到的是使用<code>WordPress</code>，因为曾今见到一个同学用它搭建过博客站点，页面风格很符合我的要求，但是需要找支持的主机，看了一下SAE，注册认证过程太耽误时间了，刚好这一段时间我是真的没时间去为一个博客托管站点弄那么多东西了，所以只有放弃了。之后又了解到<code>GitHub</code>上可以托管站点，从网上搜索了一些资料，最后决定使用<code>hexo</code>配合<code>GitHub</code>来创建一个个人静态博客。</p>
<p>有关<code>hexo</code>的介绍就不多说了，网上很多资料，找一个完整一点的很快就可以搭建起个人博客了。下面附一段<code>hexo</code>安装后默认文章里面的简介：</p>
<blockquote>
<p>Welcome to <a href="http://hexo.io/" target="_blank" rel="external">Hexo</a>! This is your very first post. Check <a href="http://hexo.io/docs/" target="_blank" rel="external">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="http://hexo.io/docs/troubleshooting.html" target="_blank" rel="external">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="external">GitHub</a>.</p>
</blockquote>
<h2 id="u5F00_u59CB_u4F7F_u7528"><a href="#u5F00_u59CB_u4F7F_u7528" class="headerlink" title="开始使用"></a>开始使用</h2><h3 id="Markdown"><a href="#Markdown" class="headerlink" title="Markdown"></a>Markdown</h3><p><code>hexo</code>使用命令行创建文章，但其实也就是一个<code>.md</code>文件，而在这之前，其实我从来没使用过<code>Markdown</code>语法来写东西，所以在大概了解完<code>hexo</code>基本知识之后，又开始学习<code>Markdown</code>文件的常用规则，从网络上找到了一篇比较详细的说明，具体可以自己进去看看：<a href="http://wowubuntu.com/markdown/" target="_blank" rel="external">Markdown语法</a>。而编辑<code>Markdown</code>文件我一般是用<code>Notepad++</code>，没有使用网上传说的神器<code>Sublime</code>，因为习惯了。</p>
<h3 id="u5176_u5B83"><a href="#u5176_u5B83" class="headerlink" title="其它"></a>其它</h3><p>最近也没有更多的时间来学习关于<code>hexo</code>的更多东西了，所以有很多内容都只能等过一阵子闲下来了才能开始继续。主要在于博客的完善与自定义上。</p>
<h2 id="u5B8C_u5584"><a href="#u5B8C_u5584" class="headerlink" title="完善"></a>完善</h2><h3 id="u4EE3_u7801_u9AD8_u4EAE"><a href="#u4EE3_u7801_u9AD8_u4EAE" class="headerlink" title="代码高亮"></a>代码高亮</h3><p>代码高亮是肯定要弄的，虽然<code>hexo</code>自带了有高亮功能，但是支持的太有限了，<del>特别对.Net这一块，几乎没有支持</del>，所以需要自己去寻找新的方案。</p>
<blockquote>
<p>之前未曾过多了解<code>Hexo</code>以及一般代码高亮的约定。有关代码高亮的更改可以参见文章<strong>自定义Hexo主题</strong></p>
</blockquote>
<p><del>下面同样一段代码，作为C#标记时全然见不到高亮效果，甚至连行号都出错了</del>……</p>
<p>[C#]</p>
<pre><code class="csharp">public class Class
{
    private int _index;
    public Class(int index) 
    {
        this._index = index;
    }
}
</code></pre>
<p>[Java]</p>
<pre><code class="java">public class Class
{
    private int _index;
    public Class(int index) 
    {
        this._index = index;
    }
}
</code></pre>
<h3 id="u5E03_u5C40_u3001_u4E3B_u9898"><a href="#u5E03_u5C40_u3001_u4E3B_u9898" class="headerlink" title="布局、主题"></a>布局、主题</h3><p><code>hexo</code>有很多主题可选，我当前使用的是一个名叫<code>Jacman</code>的主题，大概框架很符合我的要求，不过具体细节有些还是需要调整，具体到<code>_config.yml</code>文件还有很多东西没有测试呢。</p>
<h3 id="u5176_u5B83-1"><a href="#u5176_u5B83-1" class="headerlink" title="其它"></a>其它</h3><p>其实还有很多东西需要完善，仅仅看网上一个介绍<code>hexo</code>的文章，后面都是介绍统计功能和评论框的，而这两个我也考虑有时间加进来，其中统计其实<code>Jacman</code>默认是提供了代码的，只需要在<code>_config.yml</code>文件中配置相应的统计跟踪ID即可，百度统计还需要单独注册账号，所以目前我是用的<code>Google Analytics</code>，只能但愿一般时候不要被墙。。。（话说我昨天一天都无法进入Google Analytics，挂代理都打不开了）。评论框和其它的优化等有时间在弄了。</p>
<h2 id="u5199_u5728_u6700_u540E"><a href="#u5199_u5728_u6700_u540E" class="headerlink" title="写在最后"></a>写在最后</h2><p>断断续续的用了几个夜晚，终于大概配置完了，中间走了一些弯路，比如主题一块，一开始我是慢慢从默认的那个主题<code>landscape</code>上摸索修改的，后来发现是在太慢了，只能简单的修改一些内容，要想配置好估计得将整个主题全部文件关联都弄清楚，于是尝试了一下<code>GitHub</code>上的<code>hexo</code>主题，发现也很不错的，而有了前面的经验，修改这个主题也要快多了。</p>
<p>最后要说的就是Google Chrome浏览器有点坑了，居然删除了RSS订阅模块，导致我每次从Chrome中预览时，点击那个RSS都会直接打开xml文件，而不是提示订阅RSS源，就因为这个停了几个夜晚，知道今天突然从IE上打开一次，才发现RSS功能正常= =。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>第一篇博文，不知道该写个什么名字最好，干脆就保持默认的标题<code>Hello World</code>吧，这也算是学计算机软件的一个启蒙标志吧。<br>]]>
    
    </summary>
    
      <category term="Hexo" scheme="http://3meng.github.io/tags/Hexo/"/>
    
      <category term="随笔" scheme="http://3meng.github.io/categories/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
</feed>
